[{"content":"动态数据结构：链表\r到目前为止，我们接触到的数据结构还只有2种：数组和结构体；\n如果只需要储存同一种数据类型，那么数组无疑是最合适的选择；\n但是，数组也有它的缺陷：大小固定，增减元素困难；\n同时，即使你数组还有空位，要在数组里面插入一个元素，也不得不移动数组里面的大量元素，效率极低；\n因此，我们需要一种新的数据结构，它应该具有以下优点：\n大小不固定，甚至不需要在定义时确定大小； 插入元素方便，无需挪动整个结构； 这个新的数据结构就是链表；\n链表是一种大小可变，通过节点存储数据，通过指针实现连接的数据结构；可以看成一根线串着若干个节点；\n当它插入和删除元素时，只需要修改相邻2个元素的连接关系就可以了，无需移动任何其它东西；\n节点以结构体的形式呈现，结构体里面存放着一个节点数据和指向下一个（也可能是上一个）的1个或2个指针；一般形式如下：\n1 2 3 4 5 typedef struct tagNODE { int data; struct tagNODE *link; } node; 这时通过对指针link取值可以访问到它连接的另一个节点数据；\n由于链表可以存放1~2个指针，因此也有单链表和双链表之分；\n通常链表里面还包含一个头节点L，它作为链表访问的入口，不储存数据，只有1~2个指针值；\n单链表\r单链表差不多就是上面这种形式：\n1 2 3 4 5 typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; 其中node是节点的结构体数据类型，通过node可以知道任意节点占用的内存；\n而*linklist是指向链表某一节点的指针；\n至于为什么要设计成指针，这与后面链表的创建有关；\n取下一个节点数据只需要next-\u0026gt;data即可；\n双链表\r双链表相比于单链表，多了指向上一个元素的指针：这样头尾可以互换；\n1 2 3 4 5 typedef struct tagNODE { int data; struct tagNODE *prev,*next; } node,*linklist; 它不仅可以取下一个节点数据，还可以往回取，因此这种链表虽然更加复杂，但是更加容易维护，一条链断了或者数据缺失了都可以使用另外的方法恢复链表；\n循环链表\r循环链表就是最后一个节点的指针指向第一个节点；循环链表让链表数据的访问变得更加快捷；\n比如，从倒数第2个节点访问第2个节点只需要跨过2个节点，而不是将近整个链表；\n单双链表和是否循环使得链表有4种形式；但是考虑到占用空间和访问速度，常用的链表只有2种：不循环单链表和循环双链表；\n链表的创建\r在C语言中，一般使用动态内存分配的方法为链表里的数据分配内存空间，然后再使用头插法或者尾插法实现数据的填写；\n因此，头文件stdlib.h在链表的创建里面是必要的；\n头节点的创建\r每个链表都需要一个头节点作为入口，同时和其它链表进行区分；\n当程序中只出现一个链表时，一般将其设置成L;\n创建一个链表时，必须先创建一个头节点，并为其分配空间； 代码如下：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdlib.h\u0026gt; // 定义链表结构体 typedef struct tagNODE { int data; struct tagNODE *prev,*next; } node,*linklist; linklist L=NULL; L=(linklist)malloc(sizeof(node)); 分配空间\r只能一个节点一个节点的分配；且和头节点的内存分配类似；\n由于malloc的内存分配的地址具有随机性，因此链表的数据是不连续存放的，这点与数组不同；\n但是不妨碍，通过指针prev和next可以轻松访问到相邻的节点，而且这样还可以充分利用内存空间；\n创建单链表\r在创建链表的时候，需要知道头节点L的地址和节点的个数n;\n常常用到头节点指针p进行辅助，它的作用是记录当前节点的地址，以让下一个节点与当前节点相邻；\n头插法\r头插法最先插入的是最后一个节点，它的next设定为NULL；\n头插法的步骤如下：\n创建节点指针p，为其数据分配空间，并设置p-\u0026gt;next为NULL；这时p-\u0026gt;next可以充当链表末尾； 创建节点s，并为其动态分配内存；然后输入s的数据； 将s插入到链表末尾的位置，然后把p-\u0026gt;next移动到s； 重复2~3步骤以插入更多节点； 以下是图示:\n初始状态(p和L在同一个位置)： 将s插入到链表末尾： 将p-\u0026gt;next移动到s： 重复操作： 具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void CreateLinkF(linklist L,int n) { linklist p,s; int i; // 创建节点指针p p=L; p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); // 将s插入到p的位置，然后把p向上移动一个节点； s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; } } 尾插法\r尾插法最先插入的是第一个节点，再逐步添加节点，最后将末尾节点的next设置成NULL；\n尾插法的步骤如下：\n创建头节点p，为其数据分配空间； 创建节点s，并为其动态分配内存；然后输入s的数据； 将s插入到p的下一个节点，然后将p移动到s的位置； 重复2~3步骤以插入更多节点； 插入完毕后，将最后一个节点的next设置为NULL； 以下是图示： 初始状态： 将s移动到p-\u0026gt;next： 将p移动到s： 重复操作： 将最后一个节点的next设置成NULL： 具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void CreateLinkR(linklist L,int n) { linklist p,s; int i; // 创建节点指针 p=L; p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); //将s插入到p的下一个节点，然后将p移动到s的位置； p-\u0026gt;next=s; p=s; } // 将最后一个节点的next设置为NULL； p-\u0026gt;next=NULL; } 循环链表\r循环链表即最后一个节点指向的是第一个节点（不是头节点L！），而不是NULL；\n故需要tmp指针记录第一个节点的地址，并让最后一个节点的next指向它；\n空链表\r空链表指的是没有节点的链表；\n省略掉循环步骤就可以创建一个空链表；\n创建双链表\r双链表和单链表不同的地方在于双链表有2个结构体指针，分别指向前面和后面的节点，换句话说，双链表每两个相邻节点之间都有2条链；\n因此，只需要在加入一个节点时，把另外一条链(prev)连上就可以了；\n头插法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void CreateLinkF(linklist L,int n) { linklist p,s; int i; // 创建节点指针p p=L; p-\u0026gt;prev=p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); // 将s插入到p的位置 s-\u0026gt;next=p-\u0026gt;next; // 设置s的前后指针，以让两条链都链接 if(p-\u0026gt;next!=NULL)p-\u0026gt;next-\u0026gt;prev=s; p-\u0026gt;next=s; } } 尾插法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void CreateLinkR(linklist L,int n) { linklist p,s; int i; // 创建节点指针 p=L; p-\u0026gt;prev=p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); //链接s和p的2条链，然后将p移动到s的位置； p-\u0026gt;next=s; s-\u0026gt;prev=p; p=s; } // 将最后一个节点的next设置为NULL； p-\u0026gt;next=NULL; } 循环链表\r需要tmp指针记录第一个节点的地址，并让最后一个节点的next指向它；\n空链表\r省略掉循环步骤就可以创建一个空链表；\n链表的遍历\r注：此后的内容均以不循环单链表为例，循环及双链表同理可得。\n创建链表后可以像数组一样遍历它； 它的大致步骤如下：\n令节点指针p指向链表的头节点； 访问完一个节点后，让p指向p-\u0026gt;next以访问下一个节点； 重复步骤2，直到p=0; 以下是代码：\n1 2 3 4 5 6 7 8 9 void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d\\n\u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } } 其中printf可以更改为其它函数，以实现定制功能；\n比如输出节点个数（不包含头节点）、输出特定节点数据、检测链表是否循环等等；\n链表的销毁\r链表也是动态内存分配来的，它的内存也需要释放；\n不过，由于链表的内存是不连续存放的，它的销毁较为复杂；\n链表的销毁一般通过链表的遍历和free函数实现；\n链表的销毁根据对头节点的去留分为彻底销毁和重置为空表两类；\n由于2种方法仅有头节点处理的问题，因此这里只说彻底销毁的方法；\n步骤如下：\n定义节点指针p=L,q=L-\u0026gt;next; 释放p的内存，然后p和q下移1个节点； 重复步骤2直到p==NULL; 将L扔到NULL里面去，以免产生野指针；(如果还需要使用的话，就令L-\u0026gt;next=NULL) 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { // 释放`p`的内存，然后`p`和`q`下移1个节点； q=p-\u0026gt;next; free(p); p=q; } L=NULL; } 链表节点的插入和删除\rOK啊，我们对着链表说了这么多，费了那么多力气创建、遍历、销毁链表，为的是什么呢？当然就是为了现在更加快捷的插入和删除元素！\n换句话说：就是为了这碟醋包的饺子！\n节点的插入\r现在有一个孤立的节点s,现在要把插入到链表的第i个位置上，该如何做？简单分三步。\n首先，应该找到当前的第i-1个节点；\n然后，将s的next转到原来第i个，现在第i+1个节点上；\n最后，将i-1节点的next从转到s上；\n（这两步不能颠倒，否则找不到第i+1个节点）\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int ListInsert(linklist s,linklist L,int i) { linklist p=L; int t=0; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } // 如果i的值过小或过大都会报错 if(p==NULL||i\u0026lt;0)return 0; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return 1; } 节点的删除\r我们现在要删除链表的第i个节点；\n并且，为了防止误操作，需要输出被删除的节点的数据；\n步骤如下：\n找到第i-1个节点； 将第i-1个节点的next指向第i+1个节点； 将第i个节点的next指向NULL； 输出删除的节点数据，并释放内存； 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int ListDelete(linklist L,int i) { linklist p,q; int t=0; p=L; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } if(p==NULL||i\u0026lt;0)return 0; p-\u0026gt;next=q-\u0026gt;next; q-\u0026gt;next=NULL; printf(\u0026#34;%d\u0026#34;,q-\u0026gt;data); free(q); return 1; } 实例\r以下是一些链表操作的实例；\n头插法（CreateLinkF.c）\r输入：\n第一行输入插入元素的个数n，然后第二行输入n个数；\n输出：\n储存的链表数据，和输入的数据是倒序的；\n程序运行结束后销毁链表；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; void CreateLinkF(linklist L,int n) { linklist p,s; int i; p=L; p-\u0026gt;next=NULL; for(i=0;i\u0026lt;n;i++) { s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; } } void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } L=NULL; } int main() { linklist L=NULL; int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); L=(linklist)malloc(sizeof(node)); CreateLinkF(L,n); ListTrarse(L); printf(\u0026#34;\\n\u0026#34;); DestroyLink(L); return 0; } 输入：\n1 2 5 1 2 3 4 5 输出：\n1 5 4 3 2 1 尾插法（CreateLinkR.c）\r该代码和头插法仅有链表创建时使用的函数不同，其余部分均一致；\n这个输出是正序的；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; void CreateLinkR(linklist L,int n) { linklist p,s; int i; p=L; p-\u0026gt;next=NULL; for(i=0;i\u0026lt;n;i++) { s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); p-\u0026gt;next=s; p=s; } p-\u0026gt;next=NULL; } void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } L=NULL; } int main() { linklist L=NULL; int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); L=(linklist)malloc(sizeof(node)); CreateLinkR(L,n); ListTrarse(L); printf(\u0026#34;\\n\u0026#34;); DestroyLink(L); return 0; } 输入：\n1 2 5 1 2 3 4 5 输出：\n1 1 2 3 4 5 插入和删除元素(InsAndDel.c)\r在尾插法的基础上，增添了增删元素功能；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; void CreateLink(linklist L,int n) { linklist p,s; int i; p=L; p-\u0026gt;next=NULL; for(i=0;i\u0026lt;n;i++) { s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); p-\u0026gt;next=s; p=s; } p-\u0026gt;next=NULL; } void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } int ListInsert(linklist s,linklist L,int i) { linklist p=L; int t=0; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } if(p==NULL||i\u0026lt;0)return 0; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return 1; } int ListDelete(linklist L,int i) { linklist p,q; int t=0; p=L; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } if(p==NULL||i\u0026lt;0)return 0; q=p-\u0026gt;next; p-\u0026gt;next=q-\u0026gt;next; q-\u0026gt;next=NULL; printf(\u0026#34;Deleted: %d\\n\u0026#34;,q-\u0026gt;data); free(q); return 1; } void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } L=NULL; } int main() { linklist L=NULL; int n,i; L=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); CreateLink(L,n); ListTrarse(L); linklist s=NULL; s=(linklist)malloc(sizeof(node)); s-\u0026gt;next=NULL; printf(\u0026#34;Enter a node\u0026#39;s data:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); printf(\u0026#34;Enter a number to insert:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); if(ListInsert(s,L,i)!=1) { printf(\u0026#34;Error in insert.\\n\u0026#34;); return 0; } ListTrarse(L); printf(\u0026#34;Enter a number to delete:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); if(ListDelete(L,i)!=1) { printf(\u0026#34;Error in delete.\\n\u0026#34;); } ListTrarse(L); return 0; } 程序运行输入和输出：\n1 2 3 4 5 6 7 8 9 5 1 2 3 4 5 1 2 3 4 5 Enter a node\u0026#39;s data:6 Enter a number to insert:3 1 2 6 3 4 5 Enter a number to delete:5 Deleted: 4 1 2 6 3 5 ","date":"2025-08-11T00:00:00Z","image":"http://localhost:1313/post/tutor/datastucture_learning/c/01.linklist/data_hu_555a8affd78a0ff6.png","permalink":"http://localhost:1313/post/tutor/datastucture_learning/c/01.linklist/","title":"数据结构-C-01.链表"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 2000 typedef struct { int elem[N]; int top; } stack; void initStack(stack* s) { s-\u0026gt;top = -1; } int isEmpty(stack *s) { return s-\u0026gt;top == -1; } int isFull(stack *s) { return s-\u0026gt;top == N-1; } int push(stack* s, int x) { if(isFull(s))return -1; s-\u0026gt;top++; s-\u0026gt;elem[s-\u0026gt;top] = x; return 1; } int pop(stack *s, int *x) { if(isEmpty(s))return -1; *x = s-\u0026gt;elem[s-\u0026gt;top]; s-\u0026gt;top--; return 1; } int getTop(stack *s, int *x) { if(isEmpty(s))return -1; *x = s-\u0026gt;elem[s-\u0026gt;top]; return 1; } int clearStack(stack *s) { if(s == NULL)return -1; free(s); return 1; } void input(stack *s) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) { int tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); push(s, tmp); } } void output(stack *s) { int *x = (int*)malloc(sizeof(int)); while (!isEmpty(s)) { pop(s, x); printf(\u0026#34;%d \u0026#34;, *x); } printf(\u0026#34;\\n\u0026#34;); } int main() { stack *s = (stack*)malloc(sizeof(stack)); initStack(s); input(s); output(s); clearStack(s); return 0; } /* input： 5 1 2 3 4 5 output: 5 4 3 2 1 */ ","date":"2025-08-11T00:00:00Z","image":"http://localhost:1313/post/tutor/datastucture_learning/c/02.stack/data_hu_555a8affd78a0ff6.png","permalink":"http://localhost:1313/post/tutor/datastucture_learning/c/02.stack/","title":"数据结构-C-02.栈"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 2000 typedef struct { int elem[N]; int front; int rear; } queue; void initQueue(queue* q) { q-\u0026gt;front = q-\u0026gt;rear = 0; } int isEmpty(queue *q) { return q-\u0026gt;front == q-\u0026gt;rear; } int isFull(queue *q) { return (q-\u0026gt;rear+1) % N == q-\u0026gt;front; } int push(queue *q, int x) { if(isFull(q))return -1; q-\u0026gt;elem[q-\u0026gt;rear] = x; q-\u0026gt;rear = (q-\u0026gt;rear+1) % N; return 1; } int pop(queue *q, int *x) { if(isEmpty(q))return -1; *x = q-\u0026gt;elem[q-\u0026gt;front]; q-\u0026gt;front = (q-\u0026gt;front+1) % N; return 1; } int clearQueue(queue *q) { if(q == NULL)return -1; free(q); return 1; } void input(queue *q) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) { int tmp; scanf(\u0026#34;%d\u0026#34;, \u0026amp;tmp); push(q, tmp); } } void output(queue *q) { int *x = (int*)malloc(sizeof(int)); while(!isEmpty(q)) { pop(q, x); printf(\u0026#34;%d \u0026#34;, *x); } printf(\u0026#34;\\n\u0026#34;); } int main() { queue *q = (queue*)malloc(sizeof(queue)); initQueue(q); input(q); output(q); clearQueue(q); return 0; } /* input: 5 1 2 3 4 5 output: 1 2 3 4 5 */ ","date":"2025-08-11T00:00:00Z","image":"http://localhost:1313/post/tutor/datastucture_learning/c/03.queue/data_hu_555a8affd78a0ff6.png","permalink":"http://localhost:1313/post/tutor/datastucture_learning/c/03.queue/","title":"数据结构-C-03.队列"},{"content":"二叉树\r顺序表表示二叉树\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 2000 // 树的存储结构：数组 typedef struct { int elem[N]; } tree; // 初始化：所有值修改为-1 void initTree(tree *t) { for(int i = 0; i \u0026lt; N; i++) { t-\u0026gt;elem[i] = -1; } } // 返回结点的双亲节点 int parent(tree *t, int x) { if(x == 1 || t-\u0026gt;elem[x] == -1)return -1; return x/2; } // 返回结点的左孩子结点 int lChild(tree *t, int x) { if(t-\u0026gt;elem[x] == -1 || t-\u0026gt;elem[2*x] == -1)return -1; return 2*x; } // 返回结点的右孩子结点 int rChild(tree *t, int x) { if(t-\u0026gt;elem[x] == -1 || t-\u0026gt;elem[2*x+1] == -1)return -1; return 2*x+1; } // 输入 void input(tree *t) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 1; i \u0026lt; n+1; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;(t-\u0026gt;elem[i])); } } // 先序遍历 void traverse(tree *t, int cnt) { if(t-\u0026gt;elem[cnt] == -1)return; printf(\u0026#34;%d \u0026#34;, t-\u0026gt;elem[cnt]); traverse(t, 2*cnt); traverse(t, 2*cnt+1); } int main() { tree *t = (tree*)malloc(sizeof(tree)); initTree(t); input(t); traverse(t, 1); return 0; } /* input: 7 1 2 3 4 5 6 7 output: 1 2 4 5 3 6 7 */ 树的结构： 二叉链表\r按先序输入二叉树各结点，其中#表示取消建立子树结点。\n二叉树建立完成后，对其进行先序、中序、后序遍历，并输出叶子节点个数和树的深度。\n例如，要建立上图所示二叉树，需要输入：\n1 ABD..EH...CF.I..G.. 实现代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define N 2000 int cnt = 0; // 二叉链表结点 typedef struct node { char data; struct node *lChild; struct node *rChild; } node; // 创建二叉链表 void init(node** n, char *str) { char tmp = str[cnt]; cnt++; if(tmp == \u0026#39;.\u0026#39;) { *n = NULL; return; } *n = (node*)malloc(sizeof(node)); (*n)-\u0026gt;data = tmp; init(\u0026amp;((*n)-\u0026gt;lChild), str); init(\u0026amp;((*n)-\u0026gt;rChild), str); } // 访问结点 void visit(node* n) { printf(\u0026#34;%c \u0026#34;, n-\u0026gt;data); } // 先序遍历 void preOrder(node* n) { if(n != NULL) { visit(n); preOrder(n-\u0026gt;lChild); preOrder(n-\u0026gt;rChild); } } // 中序遍历 void inOrder(node* n) { if(n != NULL) { inOrder(n-\u0026gt;lChild); visit(n); inOrder(n-\u0026gt;rChild); } } // 后序遍历 void postOrder(node* n) { if(n != NULL) { postOrder(n-\u0026gt;lChild); postOrder(n-\u0026gt;rChild); visit(n); } } // 返回结点表示树的叶子节点个数 int leaf(node* n) { if(n == NULL)return 0; else if(n-\u0026gt;lChild == NULL \u0026amp;\u0026amp; n-\u0026gt;rChild == NULL) return 1; else return leaf(n-\u0026gt;lChild)+leaf(n-\u0026gt;rChild); } // 返回树的深度 int depth(node* n) { if(n == NULL)return 0; else if(n-\u0026gt;lChild == NULL \u0026amp;\u0026amp; n-\u0026gt;rChild == NULL)return 1; else return (depth(n-\u0026gt;lChild)\u0026gt;depth(n-\u0026gt;rChild) ? depth(n-\u0026gt;lChild) : depth(n-\u0026gt;rChild))+1; // the max depth of two children + 1; } int main() { node* tree; char str[N] = {0}; scanf(\u0026#34;%s\u0026#34;, str); init(\u0026amp;tree, str); preOrder(tree); printf(\u0026#34;\\n\u0026#34;); inOrder(tree); printf(\u0026#34;\\n\u0026#34;); postOrder(tree); printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;The leaf(ves) in the tree: %d\\n\u0026#34;, leaf(tree)); printf(\u0026#34;The depth of the tree: %d\\n\u0026#34;, depth(tree)); return 0; } /* input: ABD..EH...CF.I..G.. output: preOrder: A B D E H C F I G inOrder: D B H E A F I C G postOrder: D H E B I F G C A The leaf(ves) in the tree: 4 The depth of the tree: 4 */ 线索二叉树\r二叉链表中，若一个结点没有左右孩子，可将其左右孩子节点设置为中序遍历时的前驱和后继节点以充分利用空间（没有时为NULL）。\n如下图: 可以通过线索更快捷找到后继节点。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 // in-order thread #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define N 2000 int cnt = 0; typedef struct node { char data; int Ltag, Rtag; struct node *lChild; struct node *rChild; } node; void init(node** n, char *str) { char tmp = str[cnt]; cnt++; if(tmp == \u0026#39;.\u0026#39;) { *n = NULL; return; } *n = (node*)malloc(sizeof(node)); (*n)-\u0026gt;data = tmp; init(\u0026amp;((*n)-\u0026gt;lChild), str); init(\u0026amp;((*n)-\u0026gt;rChild), str); } node* pre = NULL; void tag(node* n) { if(n-\u0026gt;lChild == NULL) { n-\u0026gt;Ltag = 1; n-\u0026gt;lChild = pre; } else { n-\u0026gt;Ltag = 0; } if(pre != NULL \u0026amp;\u0026amp; pre-\u0026gt;rChild == NULL) { pre-\u0026gt;Rtag = 1; pre-\u0026gt;rChild = n; } else if(pre != NULL) { pre-\u0026gt;Rtag = 0; } pre = n; } void thread(node *n) { if(n != NULL) { thread(n-\u0026gt;lChild); tag(n); thread(n-\u0026gt;rChild); } } node* first(node* tree) { node* p = tree; if(p == NULL)return NULL; while(p-\u0026gt;Ltag == 0) p = p-\u0026gt;lChild; return p; } void visit(node* n) { printf(\u0026#34;%c \u0026#34;, n-\u0026gt;data); } node* next(node *n) { if(n-\u0026gt;Rtag == 1)return n-\u0026gt;rChild; if(n-\u0026gt;rChild == NULL)return NULL; node *p = NULL; for(node *q = n-\u0026gt;rChild;; q = q-\u0026gt;lChild) { p = q; if(q-\u0026gt;Ltag == 1)break; } return p; } void traverse(node* tree) { node* p = first(tree); while(p != NULL) { visit(p); p = next(p); } } int main() { node* tree; char str[N] = {0}; scanf(\u0026#34;%s\u0026#34;, str); init(\u0026amp;tree, str); thread(tree); traverse(tree); return 0; } /* input: ABD.G...CE.H..F.. output: D G B A E H C F */ 哈夫曼树\r输入\r输入表示字符集大小为 n（n\u0026lt;=100）的正整数，以及 n 个字符和 n 个权值（正整数，值越大表示该字符出现的概率越大）；输入串长小于或等于 100 的目标报文。\n输出\r经过编码后的二进制码，占一行；\n以及对应解码后的报文，占一行；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 // the type of huffman: static tree // // The small weight will be put in the left child while the big one in the right. // When encoding, the left is 0 and the right is 1. #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define N 2000 char str[N] = {0}; char code[N] = {0}; char restr[N] = {0}; typedef struct { char data; int weight; int parent, lChild, rChild; } node; void input(char *a, int *w, int n) { int cnt = 0; for(int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34; %c\u0026#34;, \u0026amp;a[i]); } for(int i = 0; i \u0026lt; n; i++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;w[i]); } scanf(\u0026#34;%s\u0026#34;, str); } void init(node* tree, int n, char *a, int *w) { for(int i = 0; i \u0026lt; 2*n-1; i++) { tree[i].data = 0; tree[i].lChild = -1; tree[i].rChild = -1; tree[i].parent = -1; tree[i].weight = 0; } for(int i = 0; i \u0026lt; n; i++) { tree[i].data = a[i]; tree[i].weight = w[i]; } for(int i = 0; i \u0026lt; n-1; i++) { int l = N+1, r = N+1, pl = -1, pr = -1; for(int j = 0; j \u0026lt; n+i; j++) { int tmp = tree[j].weight; if(tmp \u0026lt; l \u0026amp;\u0026amp; tree[j].parent == -1) { r = l; pr = pl; l = tmp; pl = j; } else if(tmp \u0026lt; r \u0026amp;\u0026amp; tree[j].parent == -1) { r = tmp; pr = j; } } tree[n+i].weight = tree[pl].weight + tree[pr].weight; tree[n+i].lChild = pl; tree[n+i].rChild = pr; tree[pl].parent = n+i; tree[pr].parent = n+i; } } void encode(node* tree, int n) { int slen = strlen(str); int clen = 0; for(int i = 0; i \u0026lt; slen; i++) { char tmp = str[i]; int p=0, q=0; char part[N] = {0}; int cnt = 0; for(int j = 0; j \u0026lt; n; j++) { if(tree[j].data == tmp) { p = j; break; } } while(q != 2*n-2) { q = tree[p].parent; if(tree[q].lChild == p) { part[cnt] = \u0026#39;0\u0026#39;; } else if(tree[q].rChild == p) { part[cnt] = \u0026#39;1\u0026#39;; } cnt++; p = q; } for(int j = cnt-1; j \u0026gt;= 0; j--) { code[clen] = part[j]; clen++; } } // printf(\u0026#34;%s\\n\u0026#34;, code); // printf(\u0026#34;%s\\n\u0026#34;, str); } void decode(node* tree, int n) { int clen = 0; int slen = 0; while(clen \u0026lt; strlen(code)) { int p = 2*n-2; while(p \u0026gt;= n) { char tmp = code[clen]; if(tmp == \u0026#39;0\u0026#39;) { p = tree[p].lChild; } else if(tmp == \u0026#39;1\u0026#39;) { p = tree[p].rChild; } clen++; } restr[slen] = tree[p].data; slen++; } // printf(\u0026#34;%s\u0026#34;, restr); } void output() { printf(\u0026#34;%s\\n%s\u0026#34;, code, restr); } int main() { node *tree = NULL; char a[N] = {0}; int w[N] = {0}; char c[N][N] = {0}; int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); tree = (node*)malloc(sizeof(node) * (2*n-1)); input(a, w, n); init(tree, n, a, w); encode(tree, n); decode(tree, n); output(); return 0; } /* input: 5 a b c d e 12 40 15 8 25 bbbaddeccbbb output: 00011111110111010110110000 bbbaddeccbbb */ ","date":"2025-08-11T00:00:00Z","image":"http://localhost:1313/post/tutor/datastucture_learning/c/05.tree/data_hu_555a8affd78a0ff6.png","permalink":"http://localhost:1313/post/tutor/datastucture_learning/c/05.tree/","title":"数据结构-C-05.二叉树"},{"content":"图\r邻接矩阵的遍历\r包含深度优先和广度优先。\n图的结构： 输入\r先输入一个数m，表示G1的结点个数。\n接下来m行，每行输入2个数，代表G1的一条边（有向图）。\n再输入一个数n，表示G2的结点个数。 接下来n行，每行输入2个数，代表G2的一条边（无向图）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 200 int g1[N][N] = {0}; // directed graph int g2[N][N] = {0}; // undirected graph int s[N] = {0}; typedef struct { int elem[N]; int front; int rear; } queue; void initQueue(queue* q) { q-\u0026gt;front = q-\u0026gt;rear = 0; } int isEmpty(queue *q) { return q-\u0026gt;front == q-\u0026gt;rear; } int isFull(queue *q) { return (q-\u0026gt;rear+1) % N == q-\u0026gt;front; } int push(queue *q, int x) { if(isFull(q))return -1; q-\u0026gt;elem[q-\u0026gt;rear] = x; q-\u0026gt;rear = (q-\u0026gt;rear+1) % N; return 1; } int pop(queue *q, int *x) { if(isEmpty(q))return -1; *x = q-\u0026gt;elem[q-\u0026gt;front]; q-\u0026gt;front = (q-\u0026gt;front+1) % N; return 1; } void init1(int g[N][N]) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) { int p, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;q); g[p][q] = 1; } } void init2(int g[N][N]) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) { int p, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;q); g[p][q] = g[q][p] = 1; } } void reset() { for(int i = 0; i \u0026lt; N; i++) { s[i] = 0; } } void visit(int p) { if(s[p] == 0) { printf(\u0026#34;%d \u0026#34;, p); s[p] = 1; } } void dfs(int g[N][N], int p) { visit(p); for(int i = 0; i \u0026lt; N; i++) { if(g[p][i] == 1 \u0026amp;\u0026amp; s[i] == 0) { dfs(g, i); } } } void bfs(int g[N][N], int p) { queue *q = (queue*)malloc(sizeof(queue)); initQueue(q); push(q, p); while(!isEmpty(q)) { int *x = (int*)malloc(sizeof(int)); pop(q, x); visit(*x); for(int i = 0; i \u0026lt; N; i++) { if(g[*x][i] == 1 \u0026amp;\u0026amp; s[i] == 0) { push(q, i); } } } } int main() { init1(g1); init2(g2); reset(); printf(\u0026#34;dfs for g1: \u0026#34;); dfs(g1, 0); printf(\u0026#34;\\n\u0026#34;); reset(); printf(\u0026#34;dfs for g2: \u0026#34;); dfs(g2, 0); printf(\u0026#34;\\n\u0026#34;); reset(); printf(\u0026#34;bfs for g1: \u0026#34;); bfs(g1, 0); printf(\u0026#34;\\n\u0026#34;); reset(); printf(\u0026#34;bfs for g2: \u0026#34;); bfs(g2, 0); printf(\u0026#34;\\n\u0026#34;); return 0; } /* input: 4 0 1 0 2 2 3 3 1 6 0 1 0 2 0 3 1 2 2 3 2 4 output: dfs for g1: 0 1 2 3 dfs for g2: 0 1 2 3 4 bfs for g1: 0 1 2 3 bfs for g2: 0 1 2 3 4 */ 邻接表的遍历\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 200 int s[N] = {0}; typedef struct node { int data; struct node *next; } node; typedef struct { int elem[N]; int front; int rear; } queue; void initQueue(queue* q) { q-\u0026gt;front = q-\u0026gt;rear = 0; } int isEmpty(queue *q) { return q-\u0026gt;front == q-\u0026gt;rear; } int isFull(queue *q) { return (q-\u0026gt;rear+1) % N == q-\u0026gt;front; } int push(queue *q, int x) { if(isFull(q))return -1; q-\u0026gt;elem[q-\u0026gt;rear] = x; q-\u0026gt;rear = (q-\u0026gt;rear+1) % N; return 1; } int pop(queue *q, int *x) { if(isEmpty(q))return -1; *x = q-\u0026gt;elem[q-\u0026gt;front]; q-\u0026gt;front = (q-\u0026gt;front+1) % N; return 1; } void init1(node *g[N]) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; N; i++) { g[i] = (node*)malloc(sizeof(node)); g[i]-\u0026gt;next = NULL; } for(int i = 0; i \u0026lt; n; i++) { int m, n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n); node *p = g[m]; while(p-\u0026gt;next != NULL) { p = p-\u0026gt;next; } p-\u0026gt;next = (node*)malloc(sizeof(node)); p = p-\u0026gt;next; p-\u0026gt;data = n; p-\u0026gt;next = NULL; } } void init2(node *g[N]) { int n; scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; N; i++) { g[i] = (node*)malloc(sizeof(node)); g[i]-\u0026gt;next = NULL; } for(int i = 0; i \u0026lt; n; i++) { int m, n; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;m, \u0026amp;n); node *p = NULL; p = g[m]; while(p-\u0026gt;next != NULL) { p = p-\u0026gt;next; } p-\u0026gt;next = (node*)malloc(sizeof(node)); p = p-\u0026gt;next; p-\u0026gt;data = n; p-\u0026gt;next = NULL; p = g[n]; while(p-\u0026gt;next != NULL) { p = p-\u0026gt;next; } p-\u0026gt;next = (node*)malloc(sizeof(node)); p = p-\u0026gt;next; p-\u0026gt;data = m; p-\u0026gt;next = NULL; } } void reset() { for(int i = 0; i \u0026lt; N; i++) { s[i] = 0; } } void visit(int p) { if(s[p] == 0) { printf(\u0026#34;%d \u0026#34;, p); s[p] = 1; } } void dfs(node *g[N], int x) { visit(x); node *p = g[x]-\u0026gt;next; while(p != NULL) { if(!s[p-\u0026gt;data]) dfs(g, p-\u0026gt;data); p = p-\u0026gt;next; } } void bfs(node *g[N], int x) { queue *q = (queue*)malloc(sizeof(queue)); initQueue(q); push(q, x); while(!isEmpty(q)) { int *t = (int*)malloc(sizeof(int)); pop(q, t); visit(*t); node *p = g[*t]-\u0026gt;next; while(p != NULL) { if(!s[p-\u0026gt;data]) push(q, p-\u0026gt;data);; p = p-\u0026gt;next; } } } int main() { node *g1[N]; node *g2[N]; init1(g1); init2(g2); reset(); printf(\u0026#34;dfs for g1: \u0026#34;); dfs(g1, 0); printf(\u0026#34;\\n\u0026#34;); reset(); printf(\u0026#34;dfs for g2: \u0026#34;); dfs(g2, 0); printf(\u0026#34;\\n\u0026#34;); reset(); printf(\u0026#34;bfs for g1: \u0026#34;); bfs(g1, 0); printf(\u0026#34;\\n\u0026#34;); reset(); printf(\u0026#34;bfs for g2: \u0026#34;); bfs(g2, 0); printf(\u0026#34;\\n\u0026#34;); return 0; } /* input: 4 0 1 0 2 2 3 3 1 6 0 1 0 2 0 3 1 2 2 3 2 4 output: dfs for g1: 0 1 2 3 dfs for g2: 0 1 2 3 4 bfs for g1: 0 1 2 3 bfs for g2: 0 1 2 3 4 */ 最小生成树\r输入\r一个无向图，规则与之前一样。\n输出\r一个最小生成树的所有边和路径之和。\n无向图和最小生成树\rprim\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 #include \u0026lt;stdio.h\u0026gt; #define N 200 #define INF 10000 int arcs[N][N] = {0}; // 邻接矩阵 int s[N] = {0}; // 结点是否加入 int p[N] = {0}; int min[N] = {0}; int road = 0; void init(int g[N][N], int n, int cnt) { for(int i = 0; i \u0026lt; cnt; i++) { int p, q, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;p, \u0026amp;q, \u0026amp;v); g[p][q] = g[q][p] = v; } for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { if(g[i][j] == 0) g[i][j] = INF; } } } void reset() { for(int i = 0; i \u0026lt; N; i++) { s[i] = 0; p[i] = 0; min[i] = INF; road = 0; } } void prim(int x, int n) { for(int i = 0; i \u0026lt; n; i++) { min[i] = arcs[x][i]; } s[x] = 1; for(int i = 0; i \u0026lt; n-1; i++) { int m = INF, t = -1; for(int j = 0; j \u0026lt; n; j++) { if(s[j])continue; if(min[j] \u0026lt; m) { m = min[j]; t = j; } } s[t] = 1; road += m; printf(\u0026#34;%d %d\\n\u0026#34;, p[t], t); for(int j = 0; j \u0026lt; n; j++) { if(arcs[t][j] \u0026lt; min[j] \u0026amp;\u0026amp; s[j] == 0) { min[j] = arcs[t][j]; p[j] = t; } } } printf(\u0026#34;%d\\n\u0026#34;, road); } int main() { int n, cnt; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;cnt); init(arcs, n, cnt); reset(); prim(0, n); return 0; } /* input: 6 10 0 1 6 0 2 1 0 3 5 1 2 5 1 4 3 2 3 5 2 4 6 2 5 4 3 5 2 4 5 6 output: 0 2 2 5 5 3 2 1 1 4 15 */ kruscal\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 #include \u0026lt;stdio.h\u0026gt; #define N 200 #define INF 10000 int arcs[N][N] = {0}; // 邻接矩阵 int s[N] = {0}; // 结点集合 int n = 0; // 结点个数 int road = 0; // 最短路径长度 void init(int g[N][N], int cnt) { for(int i = 0; i \u0026lt; cnt; i++) { int p, q, v; scanf(\u0026#34;%d%d%d\u0026#34;, \u0026amp;p, \u0026amp;q, \u0026amp;v); g[p][q] = g[q][p] = v; } for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { if(g[i][j] == 0) g[i][j] = INF; } } } void reset() { for(int i = 0; i \u0026lt; n; i++) { s[i] = i; } road = 0; } int find(int x) { if(s[x] == x) return x; else return find(s[x]); } int isRing(int p, int q) { return find(p) == find(q); } void kruscal() { for(int _ = 0; _ \u0026lt; n-1; _++) { int min = INF, p = -1, q = -1; for(int i = 0; i \u0026lt; n; i++) { for(int j = i+1; j \u0026lt; n; j++) { if(arcs[i][j] \u0026lt; min) { if(!isRing(i, j)) { min = arcs[i][j]; p = i; q = j; } } } } s[find(q)] = p; road += min; printf(\u0026#34;%d %d\\n\u0026#34;, p, q); } printf(\u0026#34;%d\\n\u0026#34;, road); } int main() { int cnt; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;cnt); init(arcs, cnt); reset(); kruscal(); return 0; } /* input: 6 10 0 1 6 0 2 1 0 3 5 1 2 5 1 4 3 2 3 5 2 4 6 2 5 4 3 5 2 4 5 6 output: 0 2 3 5 1 4 2 5 1 2 15 */ 拓扑序列\r给定有向图，生成其中一个拓扑序列。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define N 200 typedef struct { int elem[N]; int front; int rear; } queue; void initQueue(queue* q) { q-\u0026gt;front = q-\u0026gt;rear = 0; } int isFull(queue *q) { return (q-\u0026gt;rear+1) % N == q-\u0026gt;front; } int isEmpty(queue *q) { return q-\u0026gt;front == q-\u0026gt;rear; } int push(queue *q, int x) { if(isFull(q))return -1; q-\u0026gt;elem[q-\u0026gt;rear] = x; q-\u0026gt;rear = (q-\u0026gt;rear+1) % N; return 1; } int pop(queue *q, int *x) { if(isEmpty(q))return -1; *x = q-\u0026gt;elem[q-\u0026gt;front]; q-\u0026gt;front = (q-\u0026gt;front+1) % N; return 1; } int arcs[N][N] = {0}; int in[N] = {0}; // 结点的入度 int s[N] = {0}; int n = 0; void init() { int cnt = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;n, \u0026amp;cnt); for(int i = 0; i \u0026lt; cnt; i++) { int p, q; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;q); arcs[p][q] = 1; } for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { in[i] += arcs[j][i]; } } } void top() { queue *q = (queue*)malloc(sizeof(queue)); initQueue(q); while(1) { for(int i = 0; i \u0026lt; n; i++) { if(in[i] == 0 \u0026amp;\u0026amp; s[i] == 0) { s[i] = 1; push(q, i); } } if(isEmpty(q)) break; int *x = (int*)malloc(sizeof(int)); pop(q, x); printf(\u0026#34;%d \u0026#34;, *x); for(int i = 0; i \u0026lt; n; i++) { in[i] -= arcs[*x][i]; } } printf(\u0026#34;\\n\u0026#34;); } int main() { init(); top(); return 0; } /* input: 8 9 0 2 0 6 1 2 1 4 2 3 3 5 3 7 4 5 6 7 output: 0 1 6 2 4 3 5 7 */ 结点之间的最短路径\r输入图的邻接矩阵（若两节点没有相连，则距离为无穷大，此处默认为10000）\n对于给定的两个结点，要按顺序输出最短路径所包含的结点，同时还要输出路径长度。\ndijkstra\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 #include \u0026lt;stdio.h\u0026gt; #define N 100 // 最大顶点数 #define INF 10000 // 无穷 int arcs[N][N] = {0}; // 邻接矩阵 int path[N][N][N] = {0}; // 最短路径所含顶点 int n = 0; // 输入n和邻接矩阵 void init() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arcs[i][j]); } } for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { for(int k = 0; k \u0026lt; n; k++) { path[i][j][k] = -1; } } } } // 使用dijkstra算法计算start到其它顶点的最短路径 void dijkstra(int start) { int dist[N] = {0}; // 最短路径长度 int s[N] = {0}; // 顶点是否找到最短路径，是1否0 s[start] = 1; // 初始只有顶点start有最短路径 // 通过n次循环设置arcs和path的初始值 for(int i = 0; i \u0026lt; n; i++) { dist[i] = arcs[start][i]; // 将最短长度初始值设置成两顶点之间的弧长 // 如果不是INF的话，就可以设置path的值 if(dist[i] != INF) { // 起始点是它自己 path[start][i][0] = start; // 如果最短路径不是自己和自己连的话，那么第二个点就是终结点了。 if(i != start) { path[start][i][1] = i; path[start][i][2] = -1; } else { path[start][i][1] = -1; } } } // 进行n-1次循环，每次检索一个最短路径 for(int i = 0; i \u0026lt; n-1; i++) { // k为可能要加入s的顶点下标，min为它的目前最短值 int k = -1, min = INF; // 进行n次循环，找到k和min，然后加入s for(int j = 0; j \u0026lt; n; j++) { if(s[j] == 1)continue; // 如果已经在s里面了就跳过 if(dist[j] \u0026lt; min) { min = dist[j]; k = j; } } if(min \u0026lt; INF)s[k] = 1; // 把INF放进去就说不过去了，那不等于没找吗！ // 进行n次循环，利用顶点k更新当前最短路径 for(int j = 0; j \u0026lt; n; j++) { if(s[j] == 1)continue; // 如果已经在s里面了就跳过 int tmp = dist[k] + arcs[k][j]; // 可能的新长度：k的最短路径 + k到j的弧 // 如果比现在的短，就更新dist和path if(tmp \u0026lt; dist[j]) { dist[j] = tmp; int l; for(l = 0; path[start][k][l] != -1; l++) { path[start][j][l] = path[start][k][l]; } path[start][j][l] = j; path[start][j][l+1] = -1; } } } // 将找不到最短路径的顶点path设置为只有它自己 for(int i = 0; i \u0026lt; n; i++) { if(s[i] == 0) { path[start][i][0] = i; path[start][i][1] = -1; } } } // 输出p到q的最短路径长度和所含顶点（p和q在里面输入） void output() { int t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for(int _ = 0; _ \u0026lt; t; _++) { int p = -1, q = -1, dist = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;q); // 逐个输出path里面的顶点，输出到它自己时停止 for(int i = 0;; i++) { printf(\u0026#34;%d \u0026#34;, path[p][q][i]); if(path[p][q][i] == q)break; dist += arcs[ path[p][q][i] ] [ path[p][q][i+1] ]; } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, dist); } } int main() { init(); // 对每个顶点执行一次dijkstra算法 for(int i = 0; i \u0026lt; n; i++) { dijkstra(i); } output(); return 0; } /* input: 4 0 2 10 10000 2 0 7 3 10 7 0 6 10000 3 6 0 2 0 2 0 3 output: 0 1 2 9 0 1 3 5 */ floyd\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 #include \u0026lt;stdio.h\u0026gt; #define N 100 // 最大顶点数 #define INF 10000 // 无穷 int arcs[N][N] = {0}; // 邻接矩阵 int dist[N][N] = {0}; // 最短路径长度 int path[N][N][N] = {0}; // 最短路径所含顶点 int n = 0; // 图的顶点数 // 输入n和邻接矩阵 void init() { scanf(\u0026#34;%d\u0026#34;, \u0026amp;n); for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { scanf(\u0026#34;%d\u0026#34;, \u0026amp;arcs[i][j]); } } // 把path的值设置成-1（空） for(int i = 0; i \u0026lt; n; i++) for(int j = 0; j \u0026lt; n; j++) for(int k = 0; k \u0026lt; n; k++) path[i][j][k] = -1; } void floyd() { // 通过n次循环设置arcs和path的初始值 for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { dist[i][j] = arcs[i][j]; // 将最短长度初始值设置成两顶点之间的弧长 // 如果不是INF的话，就可以设置path的值 if(dist[i][j] != INF) { path[i][j][0] = i; // 起始点是它自己 // 如果最短路径不是自己和自己连的话，那么第二个点就是终结点了。 if(i != j) path[i][j][1] = j; } } } // 进行k*i*j次循环，更新dist和path for(int k = 0; k \u0026lt; n; k++) { for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { int tmp = dist[i][k] + dist[k][j]; // 可能的更短路径长度 // 如果更短，就更新dist和path if(tmp \u0026lt; dist[i][j]) { dist[i][j] = tmp; int cnt = 0; for(int l = 0; path[i][k][l] != -1; l++) { path[i][j][cnt] = path[i][k][l]; cnt++; } for(int l = 1; path[k][j][l] != -1; l++) { path[i][j][cnt] = path[k][j][l]; cnt++; } } } } } // 将找不到最短路径的顶点path设置为只有它自己 for(int i = 0; i \u0026lt; n; i++) { for(int j = 0; j \u0026lt; n; j++) { if(dist[i][j] == INF) { path[i][j][0] = i; } } } } void output() { int t = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;t); for(int _ = 0; _ \u0026lt; t; _++) { int p = -1, q = -1, dist = 0; scanf(\u0026#34;%d%d\u0026#34;, \u0026amp;p, \u0026amp;q); // 逐个输出path里面的顶点，输出到它自己时停止 for(int i = 0;; i++) { printf(\u0026#34;%d \u0026#34;, path[p][q][i]); if(path[p][q][i] == q)break; dist += arcs[ path[p][q][i] ] [ path[p][q][i+1] ]; } printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;, dist); } } int main() { init(); floyd(); output(); return 0; } /* input: 4 0 2 10 10000 2 0 7 3 10 7 0 6 10000 3 6 0 2 0 2 3 0 output: 0 1 2 9 3 1 0 5 */ ","date":"2025-08-11T00:00:00Z","image":"http://localhost:1313/post/tutor/datastucture_learning/c/06.graph/data_hu_555a8affd78a0ff6.png","permalink":"http://localhost:1313/post/tutor/datastucture_learning/c/06.graph/","title":"数据结构-C-06.图"},{"content":"EasyX环境下实现扫雷\r前言\r开发工具\rVisual Studio 2022\nEasyX_202440601\n开发语言\rC++\n参考资料\rEasyX官方中文教程： https://docs.easyx.cn/zh-cn/intro\n项目下载\r百度网盘： https://pan.baidu.com/s/1dhvY02UOOAVBnHm2uqUs5Q 提取码: iube\n夸克网盘： https://pan.quark.cn/s/533f41786df9 提取码：Fx7i\nGithub： https://github.com/TSR-solar/MineSweeper\nGitee： https://gitee.com/solxr/MineSweeper\n项目截图\r使用说明\r进入游戏方法\r点击Minesweeper应用程序即可开始游玩。\n里面有进一步的游戏帮助。\n游玩须知\r不要删掉diff.txt Tbest.txt rate.txt。原因同第一条。 如果发现计时器不动了，移动鼠标即可恢复。 该游戏没有设置保护机制，所以你第一下就有可能点到雷而失败。 查看源代码\r源代码在名为“源代码”的文件夹中，打开文件夹后点击Minesweeper.sln打开Visual Studio解决方案，即可查看所有头文件和源文件。 或者也可以点击“源代码”里的Minesweeper文件夹查看。 如果你在解决方案内直接运行，统计数据可能会出错，原因是两个应用程序读取的不是同一个文本文件。 内置外挂：打开initGame.cpp，然后取消掉调试下方代码的注释，并重新编译运行，这时候就会产生一个自带透视的应用程序（在x64\\Debug中），开始游戏后可以在终端查看所有地块的状态。 项目内容\r主要功能\r支持调整难度、自定义地图大小和地雷数量。 支持右键标记地雷、连锁挖开地块以及双击数字快速挖开地块。 游戏中显示计时器和未标记地雷数量。 支持数据统计和重置，包括各难度最快纪录和胜负局数。 除了游戏主体玩法之外，大部分内容和Escape from MAZE相近，比如祖传的开始页面，以及退出时的对话框。但是这次由于使用了一些C++的新功能，所以代码要更加简洁。 实时检测游戏是否达到胜利或者失败条件。 当所有安全地块被挖开后，判定为胜利，此时将所有未标记的地块标记，并弹出对话框。 当任意地雷地块被挖开后，判定为失败，此时将所有地雷翻开，并弹出对话框。 胜利后根据计时器的时间来判定是否打破纪录，并提醒玩家。如果打破纪录会刷新统计信息。 本项目没有使用图片，所有的图案都是字符。 支持游戏中重新开始和退出（通过键盘操作）。 设计原理\r由于Visual Studio的安全问题，有关TCHAR的字符串操作必须要在预处理器里面加入宏_CRT_SECURE_NO_WARNING； 在等待用户操作、主界面的离开与返回、游戏进行阶段使用循环结构，只有达到了特定的条件才会用break结束循环；\n一般来说，各个判定的函数如果有2个值，则是返回1，否返回0。\n如果有3个值，则进入下一步返回1，退出该界面返回-1，不做任何操作返回0。 将游戏中的图案提前用initImage()函数绘制在备用窗口img1上，等到要用的时候直接放出来，不需要重新绘制。 连锁挖开地块使用了广度优先搜索算法，将空地块周围8个地块全部设置成已经挖开，再对这8个地块分别判定是否连锁。 游戏会实时绘制地块状态，同时为了防止过快刷新导致的屏幕闪烁，使用了Batchdraw系列函数，先缓存操作再一次性绘制。 捕获鼠标信息方面采用了easyx.h里的getmessage()函数，主要用于按钮或者地块的操作。 读取键盘的操作不再使用GetAsyncKeyState()函数，因为就2个按键。 摆脱了单文件结构。实现了以函数为单位的多文件结构。 将所有的头文件、宏、函数声明、变量声明都放到一个大的头文件里面，便于调用。其中变量采用了extern修饰符。 游戏开始时记录起始时间，此后，将记录的时间与开始时间之差显示在屏幕右上角（计时器）。 采用了文件读写的形式来记录统计信息，但是文件地址采用的是相对路径，意味着无法移动应用程序（但可以创建快捷方式）。 地块的生成采用了2重指针的动态内存分配，好处是可以变换大小。游戏退出后释放内存。 项目中共有4个类，分别记录模式信息，地块信息，按钮信息以及图案信息。成员全部都是public。 模式类包含地图的长、宽和地雷数。 图案类包含了图案左上角的横纵坐标以及构造函数。 按钮类包含了四条边的位置坐标以及绘制按钮和检测按钮的成员函数。当然也有构造函数。 地块类包含4个成员变量，3个成员函数。\n成员变量包含dig mine type。\ndig表示该地块是否被挖，0是没被挖，1是被挖，2是旗无法被挖，3是准备挖（高亮显示）。 mine表示该地块是否含有地雷。0是没有，1是有雷。\ntype表示该地块的类型。0是空格，1~8是数字，X是雷。 typeset()函数可以根据自己以及周围8个地块的mine值来设置type的属性。 chain()函数会将mine=0的地块周围8个中dig=0的设置成dig=2。 check()函数可以检测鼠标操作。光标移动会令dig=3，离开时令dig=0。左右键仅对dig=3的地块有用。左键双击仅对dig=2的地块有用，且要满足地块周围有足够多的标记。会执行一次chain()函数。 文件汇总\rminesweeper.h\r总头文件。\nblock.h\r扫雷时的地块类的头文件。\nblock.cpp\r扫雷时的地块类的源文件。\nbutton.h\r按钮类的头文件。\nbutton.cpp\r按钮类的源文件。\nitem.h\r游戏中的图片的头文件。\nitem.cpp\r游戏中的图片的源文件。\nMode.h\r模式类的头文件。\nMode.cpp\r模式类的源文件。\nmain.cpp\r主函数。\nwelcome.cpp\r绘制初始界面以及跳转。\nSet.cpp\r绘制设置界面以及跳转。\nHelp.cpp\r绘制设置界面以及跳转。\nDiff.cpp\r绘制难度界面以及跳转。\nStats.cpp\r绘制统计界面以及跳转。\nReset.cpp\r询问是否重置统计数据。\nload.cpp\r读取文件信息（主要是统计数据）。\ninitImage.cpp\r预绘制图片到缓冲窗口。\ninitGame.cpp\r游戏初始化。\nEndGame.cpp\r游戏结束收尾操作。\npaint.cpp\r绘制游戏画面。\ninGame.cpp\r游戏内操作以及跳转。\nQuit.cpp\r询问是否退出游戏。\nEnd.cpp\r询问是否结束游戏并返回初始界面。\nRestart.cpp\r询问是否开始新的游戏。\nWin.cpp\r游戏胜利时操作。\nFail.cpp\r游戏失败时操作。\n项目总结\r这一次项目开发相比上次简单了很多，虽然文件体量更大，功能更加多样，但是开发时间却从一周减少到了3天。这主要还是得益于使用了类的功能以及多文件结构来增加开发效率。\n源代码查看\r太多了，请到文件夹中查看。\n","date":"2025-02-27T00:00:00Z","image":"http://localhost:1313/post/project/mine/image_hu_ca0574f21a642401.png","permalink":"http://localhost:1313/post/project/mine/","title":"MineSweeper"},{"content":"\nEasyX环境下实现逃离迷宫游戏：Escape from MAZE\r前言\r参考资料\rEasyX官方中文教程： https://docs.easyx.cn/zh-cn/intro\n迷宫项目模板（这也是官网里面的）： https://codebus.cn/zhaoh/maze-game\n开发工具\rVisual Studio 2022\nEasyX_202440601\n开发语言\rC（主要）、C++\n项目下载\r百度网盘: https://pan.baidu.com/s/18o6Wn49p3gW8MeKb9AEecg 提取码: 2uz1\n夸克网盘： https://pan.quark.cn/s/af2ad575b024 提取码：1wy5\n项目截图\r使用说明\r点击Escape from MAZE文件夹里面的Escape from MAZE应用程序即可运行；\n若没有找到Escape from MAZE.exe，可以使用Visual Studio打开Escape from MAZE.sln，按CTRL+F5运行；\n查看源代码可以使用Visual Studio打开Escape from MAZE.sln，查看源文件main.cpp；\n常见问题及解决方法\r若无法运行应用程序，请先关闭上一次运行打开的终端；再重新尝试； 若仍无法运行，且显示项目里面有错误，尝试点击Visual Studio项目上面的项目，选择“Escape From Maze和属性”，在“C/C++”目录里面选择“预处理器”，在预处理器里面点击“编辑”，在最后一行加上_CRT_SECURE_NO_WARNING；然后点击确定，再重新运行；\n项目内容\r主要功能\r运行Escape from MAZE.exe 后，显示开始页面，内有4个按钮，通过捕获鼠标信息来检测按钮是否被按下，从而执行接下来的操作。 游戏设置里可以调整迷宫大小；游戏说明里面有帮助。 点开始后，会绘制游戏图片到另一个image中；该过程在.exe运行直到结束不会进行第二次。 弹出对话框提醒用户输入长宽（不能超出约定范围）；若此前已经设置过则不会弹出此提示。 使用动态内存分配分配迷宫内存；当游戏结束后迷宫内存会被释放。该过程涉及了C++相关内容。 使用广度优先搜索生成迷宫元素，包括墙、空地、起点、终点；用函数rand()、srand()和time随机生成迷宫，迷宫保证有唯一解。 根据迷宫生成的数据在对应的地方绘制元素对应的游戏图片，游戏过程中由于涉及视角转换所以每0.1s都会重新绘制。 记录起始时间，此后每0.1s记录一次时间，将其与开始时间之差显示在屏幕右上角。 捕获键盘数据来实现玩家的移动和标记、取消标记操作，以及返回开始界面，每0.1s才会捕获一次，以免玩家移动过快； 玩家移动时，不会穿墙。 到达终点后，会询问用户是否重新开始；如果不重新开始则返回主界面； 按ESC和在初始界面点击退出游戏都会询问，以免误触； 设计原理\r文件的拓展名是.cpp而不是.c，是因为EasyX的库、动态内存分配、迷宫生成中涉及到了C++的内容； 由于Visual Studio的安全问题，有关TCHAR的字符串操作必须要在预处理器里面加入宏_CRT_SECURE_NO_WARNING； 在等待用户操作、主界面的离开与返回、游戏进行阶段使用循环结构，只有达到了特定的条件才会用break结束循环； 将迷宫元素和键盘操作数据常量均封装在枚举数据结构中，将所有按钮封装在结构体数据结构中，提高程序易读性； 将迷宫图片提前绘制在g_imgItem中缓存，不会显示在游戏界面； 迷宫生成方面，先把整个地图变成墙，再采用广度优先搜索算法生成路（把墙变成空地）；\n每次搜索前随机打乱遍历方向，如果路径之间可以联通就停止搜索；因此保证了随机的迷宫有唯一的解； 视野会随着玩家的移动而转换，防止玩家走到屏幕外面，但不会移出地图。因此地图必须不停地绘制； 捕获鼠标信息方面采用了easyx.h里的getmessage()函数，主要用于检测按钮是否被按下；当鼠标移到按钮上时按钮会高亮显示；如果同时按下左键就会执行按钮相应功能； 捕获键盘信息方面采用了WinUser.h里的GetAsyncKeyState()函数；并采用位运算处理按下多个按键的情形，最后使用DispatchCmd()函数处理这些信息并执行相关功能； 采用sleep(100)来保证每0.1s才捕获一次键盘信息；防止玩家移动速度过快； 游戏开始时记录起始时间，此后每0.1s记录一次时间，将其与开始时间之差显示在屏幕右上角（计时器）。 使用WinUser.h里的MessageBox来生成对话框，包含输入数据、选择是/否等功能； 开始界面通过for循环连续绘制矩形的功能，绘制了一个渐变色的外框； 文件汇总（单文件战神！）\rmain.cpp\r程序的源文件；\ngraphic.h\rEasyX中用于绘图的头文件；\ntime.h\r用于生成随机数种子以及计时；\n主要函数\rint welcome()\r显示初始界面。\nint checkButton(button btn)\r检测按钮是否被按下。\nvoid Setting()\r显示设置界面。\nvoid Help()\r显示帮助界面。\nvoid initImage()\r初始化游戏图片。\nvoid initGame()\r初始化游戏数据。\nvoid GetMazeSize()\r提示用户输入迷宫大小。\nvoid MakeMaze(int width, int height)\r生成迷宫：初始化（注意：宽高必须是奇数）\nvoid TravelMaze(int x, int y)\r生成迷宫：遍历(x,y)四周。\nMAPITEM GetMazeItem(int x, int y)\r获取指定坐标的迷宫元素。\nvoid Paint()\r绘制视野范围内的迷宫。\nint GetCmd()\r获取用户输入的指令。\nvoid DispatchCmd(int cmd)\r处理用户输入的指令。\nvoid OnUp()\r向上移动。\nvoid OnDown()\r向下移动。\nvoid OnLeft()\r向左移动。\nvoid OnRight()\r向右移动。\nvoid OnMark(MAPITEM value)\r在地图中做标记。\nbool CheckWin()\r检测是否到出口以及是否再来一局。\nbool Quit()\r询问用户是否退出游戏。\nbool EndGame()\r询问用户是否结束游戏并返回主界面。\n项目总结\r这是我首次利用程序设计制作游戏，其实很多东西很不熟悉，包括不知道图形库里的函数怎么用，迷宫是怎样生成的，如何读取鼠标和键盘操作，如何控制视角转换，如何进入和退出游戏。\n总之，从0开始确实困难，因此直接看了网上现有的代码，然后自己绘制了一个开始页面，并调大了游戏的窗口，然后把墙体、角色以及标记的图案换了一下，其它像绘制迷宫、视角移动、迷宫生成、内存管理、读取鼠标和键盘信息都是现有的。。总之我并没有做什么工作。。。\n但是也对源代码进行了深入分析，现已读懂所有内容，知道每一步要干什么了。\n虽然现在这个项目还有许多未实现的功能，也有一些地方不尽人意，比如无法缩放窗口，迷宫难度太大，没有倒计时功能等等，但是总体来说，我基本掌握了EasyX图形库的基本功能，也让我的C语言的基本语法、数据结构、算法有了实战的机会。\n所以还会有下次的，把这次的不足弥补回来。\n源代码查看\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 #pragma once #include \u0026lt;graphics.h\u0026gt;\t// EasyX 绘图工具头文件 #include \u0026lt;time.h\u0026gt;\t// 用于计时器和生成随机数头文件 //全局变量与宏 #define LENTH 1600\t// 窗口的长度 #define WIDTH 960\t// 窗口的宽度 #define ROUNDRATE 30\t// 按钮圆弧的弧度 #define STRLEN 50\t// 按钮文字的字符串长度 ExMessage m;\t// 记录鼠标信息的结构体 BYTE** g_aryMap = NULL;\t// 迷宫地图 IMAGE\tg_imgItem(360, 40);\t// 地图元素 IMAGE\tg_imgSight(1600, 960);\t// 游戏的视野（与窗口大小一致） POINT\tg_ptPlayer;\t// 游戏者的位置 RECT\tg_rtSight;\t// 游戏的视野的范围 SIZE\tg_szMap;\t// 迷宫地图的尺寸 // 枚举地图元素，兼做元素位置的 x 坐标 enum MAPITEM { MAP_WALL = 0, MAP_PLAYER = 20, MAP_GROUND = 40, MAP_MARK = 80, MAP_ENTRANCE = 120, MAP_EXIT = 140, MAP_OUTSIDE = 160 }; enum CMD { CMD_QUIT = 1, CMD_UP = 2, CMD_DOWN = 4, CMD_LEFT = 8, CMD_RIGHT = 16, CMD_MARK = 32, CMD_CLEARMARK = 64 }; typedef struct tagBUTTON\t// 定义按钮结构体 { int left;\t// 按钮的左部 int top;\t// 按钮的顶部 int right;\t// 按钮的右部 int bottom;\t// 按钮的底部 TCHAR str[STRLEN];\t// 按钮的文字提示 } button; button start, set, help, difficulty, back, quit;\t// 定义游戏中的所有按钮 clock_t tStart, tNow, tPass;\t// 记录起始、现在和经过的时间\tint Game;\t// 记录游戏状态（欢迎、开始、退出）\t// 函数声明 int welcome();\t// 显示初始界面 int checkButton(button btn);\t// 检测按钮是否被按下 void Setting();\t// 显示设置界面 void Help();\t// 显示帮助界面 void initImage();\t// 初始化游戏图片 void initGame();\t// 初始化游戏数据 void GetMazeSize();\t// 提示用户输入迷宫大小 void MakeMaze(int width, int height);\t// 生成迷宫：初始化（注意：宽高必须是奇数） void TravelMaze(int x, int y);\t// 生成迷宫：遍历(x,y)四周 MAPITEM GetMazeItem(int x, int y);\t// 获取指定坐标的迷宫元素 void Paint();\t// 绘制视野范围内的迷宫 int GetCmd();\t// 获取用户输入的指令 void DispatchCmd(int cmd);\t// 处理用户输入的指令 void OnUp();\t// 向上移动 void OnDown();\t// 向下移动 void OnLeft();\t// 向左移动 void OnRight();\t// 向右移动 void OnMark(MAPITEM value);\t// 在地图中做标记 bool CheckWin();\t// 检测是否到出口以及是否再来一局 bool Quit();\t// 询问用户是否退出游戏 bool EndGame();\t// 询问用户是否结束游戏并返回主界面 //函数定义 //主函数 int main() { initgraph(LENTH, WIDTH);\t// 创建绘图窗口 srand((unsigned)time(0));\t// 用时间设置随机数种子 int error = 0; // 窗口页面循环，若离开循环则关闭窗口 while (1)\t{ // 初始界面循环，若离开循环则退出初始界面 while (1) { cleardevice();\t// 清屏 // 通过初始页面按钮给 Game 赋值，决定要跳转的窗口 Game = welcome();\tif (Game == 1 || Game == -1) { break; //如果 Game 为 1 则开始游戏，为 -1 则退出游戏 } } // 退出游戏 if (Game == -1) { break; } cleardevice();\t// 清屏 if (error == 0) { initImage();\t// 初始化游戏图片 error = 1; } initGame();\t// 初始化游戏数据 // 游戏过程 int c;\ttStart = clock();\t// 记录游戏开始的时间 while (!(((c = GetCmd()) \u0026amp; CMD_QUIT) \u0026amp;\u0026amp; EndGame()))\t//如果按 ESC 则询问是否返回初始界面 { tNow = clock();\t// 记录当前的时间 // 根据开始时间和当前时间判断游戏进行的时间，并转换为以秒为单位 tPass = (int)((tNow - tStart) / CLOCKS_PER_SEC);\tDispatchCmd(c);\t// 检测按下的按键 Paint();\t// 实时 绘制游戏画面 if (CheckWin()) // 如果到出口就询问是否再来一局，否则返回初始界面 { break; } // 延时0.1s Sleep(100); } cleardevice();\t// 清屏 } closegraph();\t// 关闭窗口 return 0; } // 显示初始界面 int welcome() { // 打印游戏名称及作者 settextstyle(114, 0, _T(\u0026#34;Consolas\u0026#34;)); settextcolor(RED); outtextxy(350, 200, _T(\u0026#34;Escape from MAZE\u0026#34;)); settextstyle(50, 0, _T(\u0026#34;Consolas\u0026#34;)); settextcolor(RED); outtextxy(1100, 350, _T(\u0026#34;By solxr\u0026#34;)); // 绘制渐变色外框（背景） for (int i = 0; i \u0026lt; 256; i++) { setlinecolor(RGB((127 - i / 2) \u0026lt;\u0026lt; 1, 0, 0)); rectangle(256 - i, 128 - (i \u0026gt;\u0026gt; 1), 1344 + i, 832 + (i \u0026gt;\u0026gt; 1)); } // 定义按钮的各项参数属性；包括开始、设置、说明、退出； start.left = 470; start.top = 500; start.right = 730; start.bottom = 570; set.left = 870; set.top = 500; set.right = 1130; set.bottom = 570; help.left = 470; help.top = 650; help.right = 730; help.bottom = 720; quit.left = 870; quit.top = 650; quit.right = 1130; quit.bottom = 720; _tcscpy(start.str, _T(\u0026#34;开始游戏\u0026#34;)); _tcscpy(set.str, _T(\u0026#34;游戏设置\u0026#34;)); _tcscpy(help.str, _T(\u0026#34;游戏说明\u0026#34;)); _tcscpy(quit.str, _T(\u0026#34;退出游戏\u0026#34;)); // 绘制按钮 setlinestyle(PS_SOLID, 5, 0, 0); setlinecolor(RED); settextstyle(40, 0, _T(\u0026#34;黑体\u0026#34;)); settextcolor(RED); roundrect(start.left, start.top, start.right, start.bottom, ROUNDRATE, ROUNDRATE); roundrect(set.left, set.top, set.right, set.bottom, ROUNDRATE, ROUNDRATE); roundrect(help.left, help.top, help.right, help.bottom, ROUNDRATE, ROUNDRATE); roundrect(quit.left, quit.top, quit.right, quit.bottom, ROUNDRATE, ROUNDRATE); RECT r1 = { start.left, start.top + 15, start.right, start.bottom }; RECT r2 = { set.left, set.top + 15, set.right, set.bottom }; RECT r3 = { help.left, help.top + 15, help.right, help.bottom }; RECT r4 = { quit.left, quit.top + 15, quit.right, quit.bottom }; drawtext(start.str, \u0026amp;r1, DT_CENTER); drawtext(set.str, \u0026amp;r2, DT_CENTER); drawtext(help.str, \u0026amp;r3, DT_CENTER); drawtext(quit.str, \u0026amp;r4, DT_CENTER); // 等待用户点击按钮 while (1) { m = getmessage(EX_MOUSE);\t//读取鼠标信息 // 定义变量，检测按钮是否被按下 bool cbStart = checkButton(start); bool cbSet = checkButton(set); bool cbHelp = checkButton(help); bool cbQuit = checkButton(quit); //按下 start 则开始游戏 if (cbStart == 1) { return 1; } //按下 set 则进入游戏设置界面 else if (cbSet == 1) { Setting(); break; } //按下 help 则进入游戏说明界面 else if (cbHelp == 1) { Help(); break; } //按下 quit 则退出游戏 else if (cbQuit == 1) { if (Quit() == 1) { return -1; } } } return 0;\t//其它操作则返回0；什么也不做 } //检测按钮是否被按下 int checkButton(button btn) { // 确定按钮的位置 RECT r = { btn.left,btn.top + 15,btn.right,btn.bottom }; // 如果鼠标在按钮里面，则高亮显示按钮 if (m.x \u0026gt;= btn.left \u0026amp;\u0026amp; m.x \u0026lt;= btn.right \u0026amp;\u0026amp; m.y \u0026gt;= btn.top \u0026amp;\u0026amp; m.y \u0026lt;= btn.bottom) { setlinecolor(LIGHTRED); settextcolor(LIGHTRED); roundrect(btn.left, btn.top, btn.right, btn.bottom, ROUNDRATE, ROUNDRATE); drawtext(btn.str, \u0026amp;r, DT_CENTER); // 如果按下左键，则执行按钮内容 switch (m.message) { case WM_LBUTTONDOWN: { return 1; } } } // 如果鼠标不在按钮里面，则恢复原来的颜色 else { setlinecolor(RED); settextcolor(RED); roundrect(btn.left, btn.top, btn.right, btn.bottom, ROUNDRATE, ROUNDRATE); drawtext(btn.str, \u0026amp;r, DT_CENTER); } return 0; } // 显示设置界面 void Setting() { cleardevice();\t// 清屏 // 背景不能消失！ settextstyle(114, 0, _T(\u0026#34;Consolas\u0026#34;)); settextcolor(RED); outtextxy(350, 200, _T(\u0026#34;Escape from MAZE\u0026#34;)); settextstyle(50, 0, _T(\u0026#34;Consolas\u0026#34;)); settextcolor(RED); outtextxy(1100, 350, _T(\u0026#34;By solxr\u0026#34;)); for (int i = 0; i \u0026lt; 256; i++) { setlinecolor(RGB((127 - i / 2) \u0026lt;\u0026lt; 1, 0, 0)); rectangle(256 - i, 128 - (i \u0026gt;\u0026gt; 1), 1344 + i, 832 + (i \u0026gt;\u0026gt; 1)); } // 定义调整难度、返回按钮并绘制 difficulty.left = 670; difficulty.top = 500; difficulty.right = 930; difficulty.bottom = 570; back.left = 670; back.top = 700; back.right = 930; back.bottom = 770; roundrect(difficulty.left, difficulty.top, difficulty.right, difficulty.bottom, ROUNDRATE, ROUNDRATE); roundrect(back.left, back.top, back.right, back.bottom, ROUNDRATE, ROUNDRATE); settextstyle(40, 0, _T(\u0026#34;黑体\u0026#34;)); settextcolor(RED); _tcscpy(difficulty.str, _T(\u0026#34;调整难度\u0026#34;)); _tcscpy(back.str, _T(\u0026#34;返回\u0026#34;)); RECT r1 = { difficulty.left, difficulty.top + 15, difficulty.right, difficulty.bottom }; RECT r2 = { back.left, back.top + 15, back.right, back.bottom }; drawtext(difficulty.str, \u0026amp;r1, DT_CENTER); drawtext(back.str, \u0026amp;r2, DT_CENTER); //等待玩家操作 while (1) { m = getmessage(EX_MOUSE); bool cbDifficulty = checkButton(difficulty); bool cbBack = checkButton(back); if (cbDifficulty == 1) { // 提示用户输入迷宫大小 GetMazeSize(); } // 若点击返回，则返回初始界面 else if (cbBack == 1) { break; } } return; } // 显示游戏说明界面 void Help() { cleardevice();//清屏 // 重新绘制背景 settextstyle(114, 0, _T(\u0026#34;Consolas\u0026#34;)); settextcolor(RED); outtextxy(350, 200, _T(\u0026#34;Escape from MAZE\u0026#34;)); settextstyle(50, 0, _T(\u0026#34;Consolas\u0026#34;)); settextcolor(RED); outtextxy(1100, 350, _T(\u0026#34;By solxr\u0026#34;)); for (int i = 0; i \u0026lt; 256; i++) { setlinecolor(RGB((127 - i / 2) \u0026lt;\u0026lt; 1, 0, 0)); rectangle(256 - i, 128 - (i \u0026gt;\u0026gt; 1), 1344 + i, 832 + (i \u0026gt;\u0026gt; 1)); } settextstyle(40, 0, _T(\u0026#34;黑体\u0026#34;)); settextcolor(RED); // 打印说明以及绘制返回按钮 RECT r0 = { 0, 430, 1600, 860 }; drawtext(_T(\u0026#34;MAZE means AMAZING!!!\\n现在,你被困在了一个叫做“MAZE”的地方;\\n出口在右下角,赶快逃离出去!\\n按方向键或者WSAD进行移动;\\n按空格键做标记,按C取消标记;\\n按ESC返回主界面;\\n\u0026#34;), \u0026amp;r0, DT_CENTER); back.left = 670; back.top = 700; back.right = 930; back.bottom = 770; settextstyle(40, 0, _T(\u0026#34;黑体\u0026#34;)); settextcolor(RED); _tcscpy(back.str, _T(\u0026#34;返回\u0026#34;)); RECT r1 = { back.left, back.top + 15, back.right, back.bottom }; roundrect(back.left, back.top, back.right, back.bottom, ROUNDRATE, ROUNDRATE); drawtext(back.str, \u0026amp;r1, DT_CENTER); // 等待用户操作 while (1) { m = getmessage(EX_MOUSE); bool cbBack = checkButton(back); if (cbBack == 1) { break; } } } // 初始化游戏图片 void initImage() { // 预绘制游戏图片到 IMAGE 缓存 SetWorkingImage(\u0026amp;g_imgItem); cleardevice(); // 绘制 PLAYER setorigin(MAP_PLAYER, 0); setfillcolor(GREEN); setlinecolor(GREEN); fillellipse(2, 2, 17, 17); setlinecolor(BLACK); line(7, 7, 7, 8); line(12, 7, 12, 8); // 绘制墙壁 setorigin(MAP_WALL, 0); settextcolor(LIGHTRED); setfillstyle((BYTE*)\u0026#34;\\x20\\x20\\x20\\xff\\x04\\x04\\x04\\xff\u0026#34;); setlinecolor(RED); solidrectangle(1, 1, 18, 18); rectangle(0, 0, 19, 19); // 绘制入口 setorigin(MAP_ENTRANCE, 0); setlinecolor(GREEN); settextstyle(12, 0, _T(\u0026#34;宋体\u0026#34;)); outtextxy(4, 4, _T(\u0026#34;入\u0026#34;)); // 绘制出口 setorigin(MAP_EXIT, 0); outtextxy(4, 4, _T(\u0026#34;出\u0026#34;)); // 绘制标记（ 一个绿色的 “ X ” ） setorigin(MAP_MARK, 0); setlinestyle(PS_SOLID, 3, 0, 0); setlinecolor(GREEN); line(5, 5, 15, 15); line(5, 15, 15, 5); // 绘制迷宫外面的空地 setorigin(MAP_OUTSIDE, 0); settextcolor(RED); setfillstyle((BYTE*)\u0026#34;\\x50\\x55\\x22\\x20\\x05\\x55\\x22\\x02\u0026#34;); solidrectangle(0, 0, 19, 19); // 恢复坐标系 setorigin(0, 0); } // 初始化游戏数据 void initGame() { // 提示用户输入迷宫大小(如果没有调整难度的话) if (g_szMap.cx == 0 || g_szMap.cy == 0) { GetMazeSize(); } // 初始化参数 if (g_aryMap != NULL) {\t// 清理迷宫地图占用的内存 for (int x = 0; x \u0026lt; g_szMap.cx + 2; x++) delete[] g_aryMap[x]; delete[] g_aryMap; } MakeMaze(g_szMap.cx, g_szMap.cy);\t// 创建迷宫 g_ptPlayer.x = 2;\t// 设置游戏者的位置 g_ptPlayer.y = 2; g_rtSight.left = 0;\t// 设置视野范围 g_rtSight.top = 0; g_rtSight.right = 80; g_rtSight.bottom = 48; // 绘制游戏区 Paint(); } // 提示用户输入迷宫大小 void GetMazeSize() { g_szMap.cx = g_szMap.cy = 0; // 获取用户输入的宽高 TCHAR s[4]; while (g_szMap.cx \u0026lt; 80 || g_szMap.cx \u0026gt; 150) { InputBox(s, 4, _T(\u0026#34;请输入Maze的长度\\n范围：80～150(默认为100)\u0026#34;), _T(\u0026#34;输入\u0026#34;), _T(\u0026#34;100\u0026#34;)); g_szMap.cx = _ttoi(s); } while (g_szMap.cy \u0026lt; 40 || g_szMap.cx \u0026gt; 150) { InputBox(s, 4, _T(\u0026#34;请输入Maze的宽度\\n范围：48～150(默认为60)\u0026#34;), _T(\u0026#34;输入\u0026#34;), _T(\u0026#34;60\u0026#34;)); g_szMap.cy = _ttoi(s); } // 确保宽高为奇数 if (g_szMap.cx % 2 != 1) g_szMap.cx++; if (g_szMap.cy % 2 != 1) g_szMap.cy++; } // 生成迷宫：初始化（注：宽高必须是奇数） void MakeMaze(int width, int height) { // 确保宽高为奇数 if (width % 2 != 1 || height % 2 != 1) return; int x, y; // 定义迷宫尺寸，并分配迷宫内存 g_aryMap = new BYTE * [width + 2]; for (x = 0; x \u0026lt; width + 2; x++) { g_aryMap[x] = new BYTE[height + 2]; memset(g_aryMap[x], MAP_WALL, height + 2); } // 定义边界 for (x = 0; x \u0026lt;= width + 1; x++) g_aryMap[x][0] = g_aryMap[x][height + 1] = MAP_GROUND; for (y = 1; y \u0026lt;= height; y++) g_aryMap[0][y] = g_aryMap[width + 1][y] = MAP_GROUND; // 定义入口和出口( 左上和右下 ) g_aryMap[1][2] = MAP_ENTRANCE; g_aryMap[width][height - 1] = MAP_EXIT; // 从任意点开始遍历生成迷宫 TravelMaze(((rand() % (width - 1)) \u0026amp; 0xfffe) + 2, ((rand() % (height - 1)) \u0026amp; 0xfffe) + 2); // 将边界标记为迷宫外 for (x = 0; x \u0026lt;= width + 1; x++) g_aryMap[x][0] = g_aryMap[x][height + 1] = MAP_OUTSIDE; for (y = 1; y \u0026lt;= height; y++) g_aryMap[0][y] = g_aryMap[width + 1][y] = MAP_OUTSIDE; } // 生成迷宫：遍历 (x, y) 四周 void TravelMaze(int x, int y) { // 定义遍历方向 int d[4][2] = { 0, 1, 1, 0, 0, -1, -1, 0 }; // 将遍历方向乱序 int n, t, i; for (i = 0; i \u0026lt; 4; i++) { n = rand() % 4; t = d[i][0], d[i][0] = d[n][0], d[n][0] = t; t = d[i][1], d[i][1] = d[n][1], d[n][1] = t; } // 尝试周围四个方向 g_aryMap[x][y] = MAP_GROUND; for (i = 0; i \u0026lt; 4; i++) if (g_aryMap[x + 2 * d[i][0]][y + 2 * d[i][1]] == MAP_WALL) { g_aryMap[x + d[i][0]][y + d[i][1]] = MAP_GROUND; TravelMaze(x + d[i][0] * 2, y + d[i][1] * 2);\t// 递归 } } // 获取指定坐标的迷宫元素 MAPITEM GetMazeItem(int x, int y) { return (MAPITEM)g_aryMap[x][y]; } // 绘制视野范围内的迷宫 void Paint() { int x1, y1; SetWorkingImage(\u0026amp;g_imgSight); // 绘制视野内的迷宫 for (int x = g_rtSight.left; x \u0026lt;= g_rtSight.right; x++) { for (int y = g_rtSight.top; y \u0026lt;= g_rtSight.bottom; y++) { x1 = (x - g_rtSight.left) * 20; y1 = (y - g_rtSight.top) * 20; putimage(x1, y1, 20, 20, \u0026amp;g_imgItem, GetMazeItem(x, y), 0); } } // 绘制游戏者 x1 = (g_ptPlayer.x - g_rtSight.left) * 20; y1 = (g_ptPlayer.y - g_rtSight.top) * 20; putimage(x1, y1, 20, 20, \u0026amp;g_imgItem, MAP_PLAYER, 0); // 绘制计时器 settextstyle(40, 0, _T(\u0026#34;黑体\u0026#34;)); settextcolor(RED); TCHAR strTime[STRLEN]; _stprintf(strTime, _T(\u0026#34;%lds\u0026#34;), tPass); outtextxy(1500, 50, strTime); // 更新到绘图窗口 SetWorkingImage(NULL); putimage(0, 0, 1600, 960, \u0026amp;g_imgSight, 10, 10); } // 获取用户输入的命令 int GetCmd() { int c = 0; // 使用位运算节省空间，同时处理多个按键； if (GetAsyncKeyState(VK_LEFT) \u0026amp; 0x8000)\tc |= CMD_LEFT; if (GetAsyncKeyState(VK_RIGHT) \u0026amp; 0x8000)\tc |= CMD_RIGHT; if (GetAsyncKeyState(VK_UP) \u0026amp; 0x8000)\tc |= CMD_UP; if (GetAsyncKeyState(VK_DOWN) \u0026amp; 0x8000)\tc |= CMD_DOWN; if (GetAsyncKeyState(\u0026#39;A\u0026#39;) \u0026amp; 0x8000)\tc |= CMD_LEFT; if (GetAsyncKeyState(\u0026#39;D\u0026#39;) \u0026amp; 0x8000)\tc |= CMD_RIGHT; if (GetAsyncKeyState(\u0026#39;W\u0026#39;) \u0026amp; 0x8000)\tc |= CMD_UP; if (GetAsyncKeyState(\u0026#39;S\u0026#39;) \u0026amp; 0x8000)\tc |= CMD_DOWN; if (GetAsyncKeyState(\u0026#39; \u0026#39;) \u0026amp; 0x8000)\tc |= CMD_MARK; if (GetAsyncKeyState(\u0026#39;C\u0026#39;) \u0026amp; 0x8000)\tc |= CMD_CLEARMARK; if (GetAsyncKeyState(VK_ESCAPE) \u0026amp; 0x8000)\tc |= CMD_QUIT; return c; } // 处理用户输入的命令 void DispatchCmd(int cmd) { // 将按键转换为操作再转换为函数 if (cmd \u0026amp; CMD_UP)\tOnUp(); if (cmd \u0026amp; CMD_DOWN)\tOnDown(); if (cmd \u0026amp; CMD_LEFT)\tOnLeft(); if (cmd \u0026amp; CMD_RIGHT)\tOnRight(); if (cmd \u0026amp; CMD_MARK)\tOnMark(MAP_MARK); if (cmd \u0026amp; CMD_CLEARMARK)\tOnMark(MAP_GROUND); } // 向上移动 void OnUp() { // 上方有空间且不是墙壁 if (g_ptPlayer.y \u0026gt; 1 \u0026amp;\u0026amp; GetMazeItem(g_ptPlayer.x, g_ptPlayer.y - 1) != MAP_WALL) { g_ptPlayer.y--; // 当移动到边缘时，挪动视野，以防游戏者离开视野 if (g_ptPlayer.y - g_rtSight.top \u0026lt; 8 \u0026amp;\u0026amp; g_rtSight.top \u0026gt; 0) { g_rtSight.top--; g_rtSight.bottom--; } } } // 向左移动 void OnLeft() { if (g_ptPlayer.x \u0026gt; 1 \u0026amp;\u0026amp; GetMazeItem(g_ptPlayer.x - 1, g_ptPlayer.y) != MAP_WALL \u0026amp;\u0026amp; GetMazeItem(g_ptPlayer.x - 1, g_ptPlayer.y) != MAP_ENTRANCE) { g_ptPlayer.x--; if (g_ptPlayer.x - g_rtSight.left \u0026lt; 10 \u0026amp;\u0026amp; g_rtSight.left \u0026gt; 0) { g_rtSight.left--; g_rtSight.right--; } } } // 向右移动 void OnRight() { if (g_ptPlayer.x \u0026lt; g_szMap.cx \u0026amp;\u0026amp; GetMazeItem(g_ptPlayer.x + 1, g_ptPlayer.y) != MAP_WALL) { g_ptPlayer.x++; if (g_rtSight.right - g_ptPlayer.x \u0026lt; 10 \u0026amp;\u0026amp; g_rtSight.right \u0026lt;= g_szMap.cx) { g_rtSight.left++; g_rtSight.right++; } } } // 向下移动 void OnDown() { if (g_ptPlayer.y \u0026lt; g_szMap.cy \u0026amp;\u0026amp; GetMazeItem(g_ptPlayer.x, g_ptPlayer.y + 1) != MAP_WALL) { g_ptPlayer.y++; if (g_rtSight.bottom - g_ptPlayer.y \u0026lt; 8 \u0026amp;\u0026amp; g_rtSight.bottom \u0026lt;= g_szMap.cy) { g_rtSight.top++; g_rtSight.bottom++; } } } //在地图中做标记 void OnMark(MAPITEM value) { g_aryMap[g_ptPlayer.x][g_ptPlayer.y] = value; } // 检查是否到出口 bool CheckWin() { if (g_ptPlayer.x == g_szMap.cx \u0026amp;\u0026amp; g_ptPlayer.y == g_szMap.cy - 1) { // 创建对话框 HWND hwnd = GetHWnd(); if (MessageBoxW(hwnd, _T(\u0026#34;恭喜你逃离了MAZE！\\n您想再来一局吗？\u0026#34;), _T(\u0026#34;恭喜\u0026#34;), MB_YESNO | MB_ICONQUESTION) == IDYES) { initGame(); return false; } else return true; } return false; } // 询问用户是否退出游戏 bool Quit() { HWND hwnd = GetHWnd(); return (MessageBox(hwnd, _T(\u0026#34;您确定要退出游戏吗？\u0026#34;), _T(\u0026#34;ヽ（≧□≦）ノ\u0026#34;), MB_OKCANCEL | MB_ICONQUESTION) == IDOK); } // 询问用户是否返回初始界面 bool EndGame() { HWND hwnd = GetHWnd(); return (MessageBox(hwnd, _T(\u0026#34;您确定要结束游戏并返回主界面吗？\u0026#34;), _T(\u0026#34;结束游戏\u0026#34;), MB_OKCANCEL | MB_ICONQUESTION) == IDOK); } ","date":"2025-02-23T00:00:00Z","image":"http://localhost:1313/post/project/maze/image_hu_6402a94954a2490f.png","permalink":"http://localhost:1313/post/project/maze/","title":"Escape from MAZE"},{"content":"多种排序算法的复现与比较\r前言\r背景\r大数据时代，对数据进行排序是必不可少的模块；\n通过快速排序，我们能更加容易发现数据之中的规律，进而为实现统计、快速查找等操作打下基础。\n而找到更加快速、简洁易懂的排序算法也成了当下重要的任务。\n这个项目的目的就是为了比较现在流行的各个排序算法的实现难易程度与时间复杂度，以筛选出最适宜大家的排序算法。\n开发工具\rVisual Studio 2022\n开发语言\rC\n参考资料\r归并排序： https://blog.csdn.net/justidle/article/details/104203958\n堆排序： https://blog.csdn.net/weixin_51609435/article/details/122982075\n项目下载\r百度网盘： https://pan.baidu.com/s/1GhMTe3T710_YC1AHjfCgXw 提取码: vivy\n夸克网盘： https://pan.quark.cn/s/a286260cca24 提取码：uCXC\n项目截图\r使用说明\r打开Visual Studio运行解决方案sort.sln; 直接运行！ 点击运行后，将会自动生成随机数数组并自动运行6种排序算法，其中不需要任何输入和操作； 等待30秒左右后，将会在终端输出各个排序所花费的时间； 此时打开项目文件夹，在里面有两个文本文件origin.txt和sorted.txt，分别代表数组排序前后的数据； 项目内容\r主要功能\r复现以下排序算法：冒泡排序、选择排序、插入排序、快速排序、归并排序、堆排序。 对每种排序算法进行测试，并记录其在不同数据规模下的消耗时间。 设计原理\r编写各个排序算法的函数，并将所有排序函数的定义分别保存在不同源文件中。然后在main()函数中分别调用各个排序算法对同一个数组排序，并将各个算法的消耗时间打印出来。 使用\u0026lt;stdlib.h\u0026gt;里的函数rand()来生成伪随机数(用\u0026lt;time.h\u0026gt;初始化伪随机数生成器)，以用0~32767的随机数填充数组（数组里面有100000个数）。 将排序前和排序后的数组保存到文本文件中，确保所有算法排序的是同一个数组。 使用\u0026lt;time.h\u0026gt;里面的clock()函数来计算排序所需的时间，结果精确到毫秒。 运行5-10次，然后将平均运行时间作为排序算法快慢的依据。 文件汇总\rmain.c\r主函数，用于实现随机生成数组、打印排序前后的数据等功能；\nsort.h\r存放函数声明的头文件；\nsort.c\r排序主函数，用于选择排序算法分支，记录排序花费的时间；\nbubble.c choose.c insert.c quick.c merge.c heap.c\r各种排序算法的函数；\norigin.txt\r打印初始数组数据；\nsorted.txt\r打印排序后数组数据；\n主要函数\rvoid sort(int a[],int n,int cnt)\r读入给定的已知大小的数组，并根据cnt的值决定将要使用的排序算法。\n在程序执行过程中，实际会将cnt从1-6全部遍历一遍。\nvoid bubble(int a[], int n)\r对给定的已知大小的数组进行冒泡排序；\nvoid choose(int a[], int n);\r对给定的已知大小的数组进行选择排序；\nvoid insert(int a[], int n)\r对给定的已知大小的数组进行插入排序；\nvoid quick(int a[], int l, int r)\r对给定的已知左右下标的数组进行快速排序；\nvoid Merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex)\r对给定的已知左右下标的数组进行归并排序，其中使用调用的临时数组存储未合并的子数组；\nvoid MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)\r归并排序使用期间调用的递归函数；\nvoid HeapSort(int* arr, int len)\r对给定的已知大小的数组进行堆排序；\nvoid HeapAdjust(int* arr, int start, int end)\r堆排序过程中对建立的大根堆进行调整；\n项目总结\r测试之后，发现冒泡、选择运行时间都在10秒以上；而插入也在2秒以上；\n但是，剩下三种排序算法运行时间都在0.01秒以内，效率提高了数百倍；\n后续上网查找发现，冒泡、选择、插入时间复杂度均为$O(n^2)$，而快速、归并、堆排序时间复杂度均为$O(nlogn)$，因此后三种排序算法应当在现实中的应用应当较为广泛；\n而快速、归并、堆排序中，代码最简洁易懂的就是快速排序，而且它的运行时间也是所有算法中最快的，因此猜想快速排序应当就是最好最流行的排序算法；\n事实上，经查阅资料得知，头文件\u0026lt;stdlib.h\u0026gt;里面自带的排序算法就是快速排序函数qsort()，这也验证了我的猜想；\n不过，我认为其它算法也可能在代码简洁性、空间、递归复杂度上更具优势，可能也有应用空间；\n源代码查看\rsort.h\r1 2 3 4 5 6 7 8 9 10 11 // 存放函数声明的头文件 #pragma once void sort(int a[],int n,int cnt); void bubble(int a[], int n); void choose(int a[], int n); void insert(int a[], int n); void quick(int a[], int l, int r); void Merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex); void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex); void HeapAdjust(int* arr, int start, int end); void HeapSort(int* arr, int len); bubble.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void bubble(int a[], int n) { int i, j, tmp; //遍历n遍数组 for (i = 0; i \u0026lt; n; i++) { //比较相邻元素大小，然后小的在左大的在右 for (j = 0; j \u0026lt; n - i - 1; j++) { if (a[j] \u0026gt; a[j + 1]) { tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; } } //每次遍历都能保证最大的元素在最右边 } return; } choose.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void choose(int a[], int n) { int i, j, tmp; //遍历n遍数组 for ( i = 0; i \u0026lt; n; i++ ) { for ( j = i + 1; j \u0026lt; n; j++ ) { //如果元素比最左边的数小，就把它与最左边的元素交换 if ( a[ i ] \u0026gt; a[ j ] ) { tmp = a[ i ]; a[ i ] = a[ j ]; a[ j ] = tmp; } } //每次遍历都能保证最小的元素在最左边 } return; } heap.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // It is clear that I\u0026#39;m not the origin writer; It comes from CSDN; // And I don\u0026#39;t understand it at all. void HeapAdjust(int* arr, int start, int end) { int tmp = arr[ start ]; for ( int i = 2 * start + 1; i \u0026lt;= end; i = i * 2 + 1 ) { if ( i \u0026lt; end \u0026amp;\u0026amp; arr[ i ] \u0026lt; arr[ i + 1 ] )//有右孩子并且左孩子小于右孩子 { i++; }//i一定是左右孩子的最大值 if ( arr[ i ] \u0026gt; tmp ) { arr[ start ] = arr[ i ]; start = i; } else { break; } } arr[ start ] = tmp; } void HeapSort(int* arr, int len) { //第一次建立大根堆，从后往前依次调整 for ( int i = ( len - 1 - 1 ) / 2; i \u0026gt;= 0; i-- ) { HeapAdjust(arr, i, len - 1); } //每次将根和待排序的最后一次交换，然后在调整 int tmp; for ( int i = 0; i \u0026lt; len - 1; i++ ) { tmp = arr[ 0 ]; arr[ 0 ] = arr[ len - 1 - i ]; arr[ len - 1 - i ] = tmp; HeapAdjust(arr, 0, len - 1 - i - 1); } } insert.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void insert(int a[], int n) { int tmp, i, j; //遍历数组 for ( i = 1; i \u0026lt; n; i++ ) { tmp = a[ i ];//记录要插入的元素 for ( j = i - 1; j \u0026gt;= 0; j-- ) { //元素如果大于它则右移，否则留出空位让其插入 if ( a[ j ] \u0026gt; tmp ) { a[ j + 1 ] = a[ j ]; } else break; } a[ j + 1 ] = tmp;//将元素插入空位 } return; } merge.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // It is clear that I\u0026#39;m not the origin writer; In fact it comes from CSDN; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; void Merge(int sourceArr[], int tempArr[], int startIndex, int midIndex, int endIndex) { int i = startIndex, j = midIndex + 1, k = startIndex; while ( i != midIndex + 1 \u0026amp;\u0026amp; j != endIndex + 1 ) { if ( sourceArr[ i ] \u0026gt; sourceArr[ j ] ) tempArr[ k++ ] = sourceArr[ j++ ]; else tempArr[ k++ ] = sourceArr[ i++ ]; } while ( i != midIndex + 1 ) tempArr[ k++ ] = sourceArr[ i++ ]; while ( j != endIndex + 1 ) tempArr[ k++ ] = sourceArr[ j++ ]; for ( i = startIndex; i \u0026lt;= endIndex; i++ ) sourceArr[ i ] = tempArr[ i ]; } //内部使用递归 void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex) { int midIndex; if ( startIndex \u0026lt; endIndex ) { midIndex = startIndex + ( endIndex - startIndex ) / 2;//避免溢出int MergeSort(sourceArr, tempArr, startIndex, midIndex); MergeSort(sourceArr, tempArr, midIndex + 1, endIndex); Merge(sourceArr, tempArr, startIndex, midIndex, endIndex); } } quick.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void quick(int a[], int l, int r) { int i = l, j = r, flag = a[ ( l + r ) / 2 ], tmp; //记录左右下标、以及哨兵元素（数组中间的元素） do { //寻找左边大于哨兵的元素和右边小于哨兵的元素 while ( a[ i ] \u0026lt; flag )i++; while ( a[ j ] \u0026gt; flag )j--; //如果i和j没有相遇，就将这两个元素换位，并继续搜索 if ( i \u0026lt;= j ) { tmp = a[ i ]; a[ i ] = a[ j ]; a[ j ] = tmp; i++; j--; } //当i和j相遇时，在哨兵的左侧都是小于其的值，右侧都是大于其的值 } while ( i \u0026lt;= j ); //如果i和j还没有到边界，就调用递归函数对小份的数组再次进行快速排序 if ( l \u0026lt; j )quick(a, l, j); if ( i \u0026lt; r )quick(a, i, r); return; } sort.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 // 实现排序功能的主函数 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026#34;sort.h\u0026#34; void sort(int a[],int n,int cnt) { clock_t start, end; double duration; //用clock()函数记录排序所花的时间，精确到0.001秒； start = clock( ); switch ( cnt ) { //根据cnt的数值选择分支，决定使用排序的类型 case 1: { printf(\u0026#34;bubble:\u0026#34;); bubble(a, n); break; } case 2: { printf(\u0026#34;choose:\u0026#34;); choose(a, n); break; } case 3: { printf(\u0026#34;insert:\u0026#34;); insert(a, n); break; } case 4: { // \u0026lt;stdlib.h\u0026gt;里面也有快排函数qsort() printf(\u0026#34;quick:\u0026#34;); quick(a, 0, n - 1); break; } case 5: { //这东西得开两个数组才能带到函数里面去，故使用动态内存分配 printf(\u0026#34;merge:\u0026#34;); int* b = ( int* ) malloc(n * sizeof(int)); MergeSort(a, b, 0, n - 1); free(b); break; } case 6: { printf(\u0026#34;heap:\u0026#34;); HeapSort(a, n); break; } } end = clock( ); duration = ( end - start ) * 1.0 / CLOCKS_PER_SEC; printf(\u0026#34;%.3fs\\n\u0026#34;, duration); return; } main.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026#34;sort.h\u0026#34; #define N 100000 int a[ N ] = { 0 }; int tmp[ N ] = { 0 }; int main() { int i, cnt; time_t t; FILE* fp1, * fp2; //生成0 ~ 32767范围的随机数数组; srand(( unsigned ) time(\u0026amp;t)); for (i = 0; i \u0026lt; N; i++) { a[i] = rand(); } //将数组数据存储到临时数组中，进行6次序的排; for ( cnt = 1; cnt \u0026lt;= 6; cnt++ ) { for ( i = 0; i \u0026lt; N; i++ ) { tmp[ i ] = a[ i ]; } sort(tmp, N, cnt); } //将排序前后的数组数据写到文本文件中 fp1 = fopen(\u0026#34;origin.txt\u0026#34;, \u0026#34;w\u0026#34;); fp2 = fopen(\u0026#34;sorted.txt\u0026#34;, \u0026#34;w\u0026#34;); for ( i = 0; i \u0026lt; N; i++ ) { fprintf(fp1, \u0026#34;%7d\u0026#34;, a[ i ]); fprintf(fp2, \u0026#34;%7d\u0026#34;, tmp[ i ]); if ( ( i + 1 ) % 10 == 0 ) { fprintf(fp1, \u0026#34;\\n\u0026#34;); fprintf(fp2, \u0026#34;\\n\u0026#34;); } if ( ( i + 1 ) % 100 == 0 ) { fprintf(fp1, \u0026#34;\\n\u0026#34;); } } fclose(fp1); fclose(fp2); return 0; } ","date":"2025-02-23T00:00:00Z","image":"http://localhost:1313/post/project/sort/image_hu_43554a35699c9624.png","permalink":"http://localhost:1313/post/project/sort/","title":"Sort"},{"content":"python_learning\r介绍\r学习python的笔记！\n","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/readme/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/readme/","title":"Python基础-00.简介"},{"content":"交互\r输出\r输出使用print；\n需要注意的是，如果想要直接输出一句话，比如hello world，必须在这句话的前后加上引号 (单双引号都可以的哦 )\n1 print(\u0026#34;hello world\u0026#34;) 输出：hello world\n但是如果是其它的什么东西，比如数字，就不需要加引号，甚至还可以直接在函数里面进行运算，十分自由；\n1 print(100+200) 输出： 300\n变量\r即便输出是万物的基础，但是单单一个输出当然是什么都干不了。\n需要一些东西来储存用来输出的内容，管它叫变量就行；\n变量在使用之前需要定义。可以用赋值操作实现；\n像这样就可以了：a=5\n定义之后变量就可以参与运算了，也可以用作函数的参数；\n同样不需要加括号，因为不是字符串；\n1 2 a=\u0026#34;hello world\u0026#34; print(a) 输出：hello world\n输入\r至于输入，input即可，它的作用是读取键盘输入，按回车键结束输入，然后给变量赋值；\n此外，还可以在input函数里面添加参数让它输出提示信息；\n比如说：(hello.py)\n1 2 a=input(\u0026#34;input:\u0026#34;) print(a) 运行后程序显示：\n1 2 input:5 a = 5 交互模式\r在python中，交互的方式不止一种；\n常见的一种方式是先编写源代码.py，然后用python解释器运行程序，接着从终端输入输出；\n除此之外，还有一种更加简便的交互方式，叫做python交互模式；\n在终端的命令行模式下输入python，就可以进入交互模式下的python；\n在交互模式下输入exit()，即可退出交互模式并返回命令行模式；\n交互模式下的python会用提示符\u0026gt;\u0026gt;\u0026gt;来提示你输入代码，按下回车后即运行代码并输出结果；\n以下是一些交互模式下运行的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026gt;\u0026gt;\u0026gt; 1+1 2 \u0026gt;\u0026gt;\u0026gt; print(1+1) 2 \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;哈喽，世界！\u0026#39;) 哈喽，世界！ \u0026gt;\u0026gt;\u0026gt; a=5 \u0026gt;\u0026gt;\u0026gt; a 5 \u0026gt;\u0026gt;\u0026gt; b=input() 6 \u0026gt;\u0026gt;\u0026gt; print(b) 6 \u0026gt;\u0026gt;\u0026gt; exit() # 退出到命令行 ","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/01.helloworld/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/01.helloworld/","title":"Python基础-01.Hello World"},{"content":"数据类型与运算\r数据类型\rpython不像C那么复杂，这使得C语言里的数据类型到了python里面就只有4种：整数、浮点数、字符串和布尔值; 另外还有python特有的数据类型：复数；\n尽管有数据类型这种东西，但是由于python是动态语言（相对C、Java是静态语言），变量定义的时候并不需要指明数据类型，同时数据类型也是可变的；\n如下面的区分动态和静态语言的例子：\n1 2 3 # python: a=123 a=\u0026#39;hello\u0026#39; # 正确，python是动态语言，可以改变变量的类型 1 2 3 // C int a=123 a=\u0026#34;hello\u0026#34; // 错误，C是静态语言，变量一旦定义，类型不可以改变 整数\r没有大小限制。想写多大就多大。\n支持二、八、十、十六进制；其中二进制是0b、八进制是0o、十六进制是0x，十进制不需要特别标注前缀；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; 0b10 2 \u0026gt;\u0026gt;\u0026gt; 0o10 8 \u0026gt;\u0026gt;\u0026gt; 0x10 16 浮点数\r也没有大小限制，无论是整数还是小数部分。支持e的科学计数法形式。\n对于小数部分为0的数字，可以通过加上.0的方式让这个数默认为浮点数而不是整数；\n有时候，浮点数会由于尾数问题产生奇怪的误差；\n1 2 \u0026gt;\u0026gt;\u0026gt; 0.1+0.2 0.30000000000000004 字符串\r就像之前提到的，单双引号都可以的；\n字符串内容甚至还可以是中文；\n布尔值\rTrue是1，False是0。注意大小写要写对；\n复数\r复数由实部和虚部组成，然而在python中虚数符号是j，而不是i；\n当复数的虚部为1时，也不可以省略；\n1 2 \u0026gt;\u0026gt;\u0026gt; 1j*1j (-1+0j) 若要创建一个复数变量，除了使用a+bj形式以外，还可以使用complex函数进行创建；\n比如：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a=complex(1,3) \u0026gt;\u0026gt;\u0026gt; a (1+3j) 运算\r数学运算\r和C语言大部分相同；但要注意：\npython里面的除法含有2种：\n一种是普通除法/，相当于浮点数的除法；\n另一种是地板除//，相当于整数的除法；\n如下面的例子：divide.py\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a=10 \u0026gt;\u0026gt;\u0026gt; b=3 \u0026gt;\u0026gt;\u0026gt; a/b 3.3333333333333335 \u0026gt;\u0026gt;\u0026gt; a//b 3 除此之外，python新增了乘方的功能，它是**；\n它的优先级在最前面；\n1 2 \u0026gt;\u0026gt;\u0026gt; 2**3 8 逻辑运算\r逻辑运算无非进行与或非运算；\n不过运算符不再是\u0026amp;\u0026amp;、||、!这些，而是货真价实的英文单词！\n与是and，或是or，非是not；\n数学库\r经常要进行更加复杂的运算；\n因此有了集合一些常见函数，比如乘方、开方以及常量，比如pi、e的数学库；\n在引用数学库的一些函数或常量之前，首先需要调用数学库：\n1 import math 这类似于C语言对头文件的include；\n接下来是使用其中一些函数和常量的例子：\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.pi 3.141592653589793 \u0026gt;\u0026gt;\u0026gt; math.sqrt(9) 3.0 类型转换\r虽然前面提到python是动态语言，变量的类型不固定，但是不同类型的变量还是无法进行运算的；\n因此类型转换还是十分有必要的；\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt;\u0026gt;\u0026gt; a=input() 9 \u0026gt;\u0026gt;\u0026gt; a \u0026#39;9\u0026#39; \u0026gt;\u0026gt;\u0026gt; int(a) 9 \u0026gt;\u0026gt;\u0026gt; b=5 \u0026gt;\u0026gt;\u0026gt; a+b Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: can only concatenate str (not \u0026#34;int\u0026#34;) to str \u0026gt;\u0026gt;\u0026gt; int(a)+b 14 注意：int()会直接将字符去掉引号，而不是转换为其UTF-8值；\n这也就意味着，不是数字的字符串在python中将无法进行类型转换；\n类型转换函数\r类型转换是通过函数实现的，并不是运算符；\n类型转换可能有不止一个参数；\n下面是一些常见的类型转换函数；\nbool()\r根据参数的逻辑值将其转换为对应的布尔值；\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; bool(2) True \u0026gt;\u0026gt;\u0026gt; bool(-1) True \u0026gt;\u0026gt;\u0026gt; bool(0) False \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;a\u0026#39;) True int() float() complex() str()\r将传入的参数转换为对应数据类型的值；\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; int(3.0) 3 \u0026gt;\u0026gt;\u0026gt; float(3) 3.0 \u0026gt;\u0026gt;\u0026gt; complex(1,2) 1+2j \u0026gt;\u0026gt;\u0026gt; str(123) \u0026#39;123\u0026#39; bin() oct() hex()\r将整数转换为2、8、16进制的字符串；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; bin(31) \u0026#39;0b11111\u0026#39; \u0026gt;\u0026gt;\u0026gt; oct(31) \u0026#39;0o37\u0026#39; \u0026gt;\u0026gt;\u0026gt; hex(31) \u0026#39;0x1f\u0026#39; python字符串\rpython的字符串功能更加复杂，所以多写一点；\nUnicode和UTF-8编码字符串\rpython的字符串除了支持中文以外，还支持日文和韩文，以及更多奇形怪状的语言；\n这是因为python采用了更加广泛的字符编码方式，即Unicode格式；\n它可以看作是ASCII编码的拓展版本，可以容纳更多的字符；\n而UTF-8可以看成Unicode的缩减版本，即删去了前导的0；\n这样，本来在Unicode里面，\n英文字母需要占据2个字节，到了UTF-8里面就只需要1个字节；\n汉字需要占据4个字节，到了UTF-8里面最少只需要2个字节；\n并且，那些较短的编码在UTF-8和ASCII编码里面是完全一致的，这也简化了两种编码之间的转换操作；\n一般来说，在应用场景，比如内存中使用Unicode编码，而在磁盘等存储场景中使用UTF-8编码；\n字符和其编码之间的转换\r和ASCII一样，UTF-8编码也是和字符一一对应的，相对于C语言需要使用%c来输出所对应的字符，python有类型转换函数来实现字符和编码之间的相互转换； 它们是ord()和chr()；\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;A\u0026#39;) 65 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;中\u0026#39;) 20013 \u0026gt;\u0026gt;\u0026gt; chr(66) \u0026#39;B\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(25991) \u0026#39;文\u0026#39; 不过，当字符串长度大于1时，函数ord()就会失效；\n字符串长度\r使用函数len()；\n汉字、字母、字符的长度都是1；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; len(\u0026#39;ABC\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; len(\u0026#39;中文\u0026#39;) 2 \u0026gt;\u0026gt;\u0026gt; len(\u0026#39;......\u0026#39;) 6 如果字符串是以字节byte形式计算的，字符串长度就会计算字节数而不是字符数；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; len(\u0026#39;中文\u0026#39;) 2 \u0026gt;\u0026gt;\u0026gt; len(\u0026#39;中文\u0026#39;.encode(\u0026#39;utf-8\u0026#39;)) 6 encode('utf-8')表示使用UTF-8改写字符串；\n格式化字符串\rpython的字符串格式化与C语言相近，都是通过%实现的；\n不同点是，python的格式化字符串不一定是要在输入输出函数里面才能使用，一般的字符串也可以使用； 换句话说，格式化字符串不是参数，而是python中独立存在的功能；\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; a=1 \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;%d\u0026#39; % a) 1 \u0026gt;\u0026gt;\u0026gt; \u0026#39;%d\u0026#39; % a \u0026#39;1\u0026#39; \u0026gt;\u0026gt;\u0026gt; s=(\u0026#39;%d\u0026#39; % a) \u0026gt;\u0026gt;\u0026gt; s \u0026#39;1\u0026#39; 使用该功能的方法是在字符串中加入需要被格式化的内容，如%d，然后在字符串后面马上跟一个%用括号括起格式化的内容，如有多个中间用逗号隔开；\n1 2 \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;%d,%d\u0026#39; % (a,b)) 1,2 此外还可以使用函数format()或者字符串f-string来格式化输出；\n但是个人觉得没有%容易理解和操作；\n转义字符\r相应地，转义字符（如\\n）也不再是输入输出函数特有的功能； 然而它只对输入输出函数转义；\n也就是说并不会像格式化字符串一样实时改变字符串的内容，只有在输入输出函数里面才会对字符串进行翻译，输出特定结果；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;hello\\nworld\u0026#39; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;hello\\nworld\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(s) hello world ","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/02.data-calc/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/02.data-calc/","title":"Python基础-02.数据类型和运算"},{"content":"序列\r能够容纳多个值的变量叫做数据结构；\n现在又将数据结构分成序列和非序列；\n通俗来说，序列是一种线性的数据结构；\n在python中，常见的序列类型有列表、元组、字符串；\n下面会依次介绍三种序列类型及其操作；\n列表\r列表类似于C语言中的数组，不过拥有更多功能和操作；\n与数组不同，列表的大小不固定，也没有数据类型的限制；\n因此，整数、浮点数、字符串、甚至列表都可以同时出现在同一个列表中；\n1 a=[1, 3, 5, 7, 9, 1.5, \u0026#39;a\u0026#39;, [1, 3]] 列表的创建\r定义列表变量里的元素与数组相近，但是大括号{}要改成方括号[]；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a [1, 3, 5, 7, 9] 用函数创建列表\r使用list()函数创建一个列表而不是中括号[]；\n该方法针对字符串有效；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a=list(\u0026#39;hello world\u0026#39;) \u0026gt;\u0026gt;\u0026gt; a [\u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;d\u0026#39;] 列表元素的访问\r根据元素下标访问列表；\n第1个元素下标仍然是0；\n不同的是，下标虽然会越界，但是却可以是负数，这时从列表末尾开始查找元素；\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; a[0] 1 \u0026gt;\u0026gt;\u0026gt; a[1] 3 \u0026gt;\u0026gt;\u0026gt; a[-2] 7 \u0026gt;\u0026gt;\u0026gt; a[5] Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range 列表元素的赋值\r简单易懂。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a[0]=2 \u0026gt;\u0026gt;\u0026gt; a [2, 3, 5, 7, 9] \u0026gt;\u0026gt;\u0026gt; a=[[1,3],[5,7],9] \u0026gt;\u0026gt;\u0026gt; a[0][0]=2 \u0026gt;\u0026gt;\u0026gt; a [[2, 3], [5, 7], 9] 列表元素的添加\r使用列表函数来实现；\nL.append(x)\r用于在列表末尾添加值为x的元素；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a.append(11) \u0026gt;\u0026gt;\u0026gt; a [1, 3, 5, 7, 9, 11] 此方法也可用于空列表的初始化；\nL.insert(index,x)\r用于在下标为index处插入值为x的元素；\n插入后，x的下标为index，其余元素下标+1；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a.insert(1,2) \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 5, 7, 9] 列表元素的删除\r使用函数或语句实现；\nL.pop(index)\r删去下标为index的元素，index右边的元素下标-1；\n若没有指定下标，则默认删去最后一个元素；\n调用函数后会输出删去元素的值；\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a.pop() 9 \u0026gt;\u0026gt;\u0026gt; a.pop(1) 3 \u0026gt;\u0026gt;\u0026gt; a [1, 5, 7] L.remove(x)\r删去值为x的元素，该元素右边的元素下标-1； 若有多个元素值为x，则优先删去下标小的元素； 若没有元素值为x，则报错；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt;\u0026gt;\u0026gt; a=[1,1,4,5,1,4] \u0026gt;\u0026gt;\u0026gt; a.remove(1) \u0026gt;\u0026gt;\u0026gt; a [1, 4, 5, 1, 4] \u0026gt;\u0026gt;\u0026gt; a.remove(1) \u0026gt;\u0026gt;\u0026gt; a [4, 5, 1, 4] \u0026gt;\u0026gt;\u0026gt; a.remove(1) \u0026gt;\u0026gt;\u0026gt; a [4, 5, 4] \u0026gt;\u0026gt;\u0026gt; a.remove(1) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: list.remove(x): x not in list L.clear()\r删除列表的所有元素，使其成为空列表；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a.clear() \u0026gt;\u0026gt;\u0026gt; a [] del\rdel是语句，不是函数；\ndel后不会输出删去的元素值；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; del a[1] \u0026gt;\u0026gt;\u0026gt; a [1, 5, 7, 9] 更多列表函数\rL.count(x)\r计算列表中x出现的次数；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a=[1,1,4,5,1,4] \u0026gt;\u0026gt;\u0026gt; a.count(1) 3 \u0026gt;\u0026gt;\u0026gt; a.count(2) 0 L.index(x[, start[, end]])\r该函数有3个参数，其中start和end可选；\nx指定了需要寻找的值；\nstart指定了开始寻找的下标位置（含该下标）；\n若没有start，则默认从头开始；\nend指定了结束寻找的下标位置（含该下标）；\n若没有end，则默认寻找到列表尾部；\n只有传入了start参数才能设定end参数，且end必须大于start；\n该函数将返回设定范围内所有元素中的最小下标；\n若没有符合条件的元素，将会报错；\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; a=[1,2,3,1,2,3,1,2,3] \u0026gt;\u0026gt;\u0026gt; a.index(3) 2 \u0026gt;\u0026gt;\u0026gt; a.index(3,2) 2 \u0026gt;\u0026gt;\u0026gt; a.index(3,3) 5 \u0026gt;\u0026gt;\u0026gt; a.index(3,3,5) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; ValueError: 3 is not in list 此外，还可以用运算符in和not in来判断元素是否在（不在）列表中，不过结果是布尔值，不能指明元素的下标；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; 1 in a True \u0026gt;\u0026gt;\u0026gt; 2 not in a True L.extend(x)\r将列表x扩充到列表L的末尾；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; b=[2,4,6,8] \u0026gt;\u0026gt;\u0026gt; a.extend(b) \u0026gt;\u0026gt;\u0026gt; a [1, 3, 5, 7, 9, 2, 4, 6, 8] 还可以用a+=b来实现这个函数的功能；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; b=[2,4,6,8] \u0026gt;\u0026gt;\u0026gt; a+=b \u0026gt;\u0026gt;\u0026gt; a [1, 3, 5, 7, 9, 2, 4, 6, 8] 此外，还有乘法来实现列表的快速叠加；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,2,3] \u0026gt;\u0026gt;\u0026gt; a*=3 \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 1, 2, 3, 1, 2, 3] L.reverse()\r倒置列表；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; a.reverse() \u0026gt;\u0026gt;\u0026gt; a [9, 7, 5, 3, 1] min() max()\r找出列表中的最小值和最大值； 注意只能用于所有元素数据类型相同的列表； 对于字符串，比较的是其Unicode编码值；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,7,9] \u0026gt;\u0026gt;\u0026gt; min(a) 1 \u0026gt;\u0026gt;\u0026gt; max(a) 9 L.sort()\r将列表中的元素排序，默认从小到大；\n注意只能用于所有元素数据类型相同的列表；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[4,3,5,1,6,2] \u0026gt;\u0026gt;\u0026gt; a.sort() \u0026gt;\u0026gt;\u0026gt; a [1, 2, 3, 4, 5, 6] 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[\u0026#39;d\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;b\u0026#39;] \u0026gt;\u0026gt;\u0026gt; a.sort() \u0026gt;\u0026gt;\u0026gt; a [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;] 元组\r元组和列表大部分相同，只是元组一旦初始化，元素便不可修改，除非重新初始化；\n因此列表的一些内容，包括增删、修改元素及其相关函数都不能使用；\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; a=(1,3,5,7,9) \u0026gt;\u0026gt;\u0026gt; a[0]=2 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; a.append(11) Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; AttributeError: \u0026#39;tuple\u0026#39; object has no attribute \u0026#39;append\u0026#39; \u0026gt;\u0026gt;\u0026gt; a=(2,3,5,7,9) \u0026gt;\u0026gt;\u0026gt; a (2, 3, 5, 7, 9) 元组的初始化\r为了和列表区分，元组用小括号()表示；\n1 a=(1,3,5,7,9) 但是，要定义一个只有1个元素的tuple，如果你这么定义：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a = (1) \u0026gt;\u0026gt;\u0026gt; a 1 定义的不是元组，而是1这个数！\n这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义；\n因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。\n所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; t = (1,) \u0026gt;\u0026gt;\u0026gt; t (1,) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。\n元组和列表的嵌套\r当元组里面有列表元素时，列表元素可变，其它不可变；\n当列表里面有元组元素时，元组元素不可变，其它可变；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=(1,3,5,[7,9]) \u0026gt;\u0026gt;\u0026gt; a[3][0]=8 \u0026gt;\u0026gt;\u0026gt; a (1, 3, 5, [8, 9]) 1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a=[1,3,5,(7,9)] \u0026gt;\u0026gt;\u0026gt; a[4][0]=8 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; IndexError: list index out of range 字符串\r前面提到，字符串也是序列的一种；\n其实，字符串功能类似于元组，也是初始化后无法修改；\n字符串的区别在于元素是字符，而且功能更加丰富；\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; s[0] \u0026#39;h\u0026#39; \u0026gt;\u0026gt;\u0026gt; s[0]=\u0026#39;H\u0026#39; Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;str\u0026#39; object does not support item assignment \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;Hello\u0026#39; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;Hello\u0026#39; 常见字符串函数\rS.find(sub[,start,[end]])\r类似于L.index()；\n不过，S.find()不限于单个元素，也可以是多个元素组成的字符串，此时返回sub字符串的第1个字符的下标；\n此外，若没有找到，不会报错，而是返回-1；\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;this is a test\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#39;a\u0026#39;) 8 \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#39;is\u0026#39;) 2 \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#39;c\u0026#39;) -1 \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#39;is\u0026#39;,3) 5 \u0026gt;\u0026gt;\u0026gt; s.find(\u0026#39;is\u0026#39;,3,6) -1 S.count(sub[,start,[end]])\r相对于L.count()，该函数可以搜寻多个字符以及指定搜索范围；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;this is a test\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.count(\u0026#39;is\u0026#39;) 2 \u0026gt;\u0026gt;\u0026gt; s.count(\u0026#39;is\u0026#39;,0,4) 1 S.title() S.upper() S.lower()\r这些函数只针对于英文字符串；\nS.title()返回将每个单词的首字母大写的字符串；\nS.upper()返回全部大写的字符串；\nS.lower()返回全部小写的字符串；\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;hello wORLD\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.title() \u0026#39;Hello World\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.upper() \u0026#39;HELLO WORLD\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.lower() \u0026#39;hello world\u0026#39; \u0026gt;\u0026gt;\u0026gt; S.strip() S.lstrip() S.rstrip()\r分别返回去除两端、左边、右边空格的字符串；\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39; py \u0026#39; \u0026gt;\u0026gt;\u0026gt; s.strip() \u0026#39;py\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.lstrip() \u0026#39;py \u0026#39; \u0026gt;\u0026gt;\u0026gt; s.rstrip() \u0026#39; py\u0026#39; S.replace(old,new)\r将字符串中所有old字符串替换为new字符串，然后返回（不改变原有字符串）；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;This is a test\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.replace(\u0026#39;is\u0026#39;,\u0026#39;IS\u0026#39;) \u0026#39;ThIS IS a test\u0026#39; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;This is a test\u0026#39; S.join(X)\r将序列X里的元素 合并为新字符串，之间用字符串S做间隔；\n其中X必须是字符串序列；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a=[\u0026#39;1\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;9\u0026#39;] \u0026gt;\u0026gt;\u0026gt; \u0026#39;,\u0026#39;.join(a) \u0026#39;1,3,5,7,9\u0026#39; S.split([sep])\r将S分割成多个元素，然后组成列表；\nsep为分割标志，如果没有该参数，就不分割，列表中只有1个元素，即该字符串；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; s=\u0026#39;1,3,5,7,9\u0026#39; \u0026gt;\u0026gt;\u0026gt; s.split(\u0026#39;,\u0026#39;) [\u0026#39;1\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;9\u0026#39;] \u0026gt;\u0026gt;\u0026gt; s.split() [\u0026#39;1,3,5,7,9\u0026#39;] ","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/03.sequence/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/03.sequence/","title":"Python基础-03.序列"},{"content":"","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/04.sentence/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/04.sentence/","title":"Python基础-04.语句"},{"content":"集合（set）\r集合也是一种数据结构，其意义和数学上的集合相近，具有确定性、无序性和互异性；\n其中无序性和互异性使得集合不是一个线性的数据结构，因而集合不是序列；\n集合的创建\r元组用小括号表示，列表用中括号表示，而集合用大括号{}表示；\n定义集合的与列表一样有2种方式；\n传统创建\r1 2 3 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; a {1, 3, 5, 7, 9} 其中若集合中有元素重复出现，则只会保留1个；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a={1,1,4,5,1,4} \u0026gt;\u0026gt;\u0026gt; a {1, 4, 5} 函数创建\r使用set()将列表或元组转换为集合，重复的元素同样只会保留1个；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a=[1,1,4,5,1,4] \u0026gt;\u0026gt;\u0026gt; b=set(a) \u0026gt;\u0026gt;\u0026gt; b {1, 4, 5} 集合元素的添加\r使用s.add(x)即可往集合s中添加值为x的元素；\n若添加集合中已有的元素，则没有效果；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; a.add(11) \u0026gt;\u0026gt;\u0026gt; a {1, 3, 5, 7, 9, 11} 集合元素的删除\r使用s.remove(x)移除集合s中值为x的元素，没有则移除失败；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; a.remove(9) \u0026gt;\u0026gt;\u0026gt; a {1, 3, 5, 7} 集合元素的访问\r由于没有下标，集合无法访问单个元素，只能全部输出；\n值得一提的是，for-in语句对集合也有效，可以取出集合的元素，但元素显示的顺序不表示集合是有序的；\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; a {1, 3, 5, 7, 9} \u0026gt;\u0026gt;\u0026gt; for i in a: ... i ... 1 3 5 7 9 集合有关的函数\rlen(s) min(s) max(s)\r这些是和序列通用的函数；\nsum(s)\r将集合s中的所有元素累加起来输出；\n其中数字和字符串不能做累加；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; sum(a) 25 集合的运算\r集合相比列表是无序且互异的，这样虽然不能用下标访问元素，却为更多的运算提供了方便；\nin not in\r用于判断元素是否在（不在）集合中；\n返回布尔值；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; 5 in a True \u0026gt;\u0026gt;\u0026gt; 7 not in a False s1.issubset(s2) s1.issubset(s2)\r这两个函数用于判断s1是否是s2的子集（超集）\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; b={1,2,3,4,5,6,7,8,9} \u0026gt;\u0026gt;\u0026gt; a.issubset(b) True \u0026gt;\u0026gt;\u0026gt; b.issuperset(a) True 子集和真子集的运算也可以用运算符\u0026gt;、\u0026gt;=等判断；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a\u0026lt;b True \u0026gt;\u0026gt;\u0026gt; b\u0026gt;=a True == !=\r判断两个集合是否相等（不等）；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; b={5,7,3,1,9} \u0026gt;\u0026gt;\u0026gt; a==b True s1.union(s2) or |\r输出s1和s2的并集；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; b={2,3,4,5,6} \u0026gt;\u0026gt;\u0026gt; a.union(b) {1, 2, 3, 4, 5, 6, 7, 9} \u0026gt;\u0026gt;\u0026gt; a|b {1, 2, 3, 4, 5, 6, 7, 9} s1.intersection(s2) or \u0026amp;\r输出s1和s2的交集；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; b={2,3,4,5,6} \u0026gt;\u0026gt;\u0026gt; a.intersection(b) {3, 5} \u0026gt;\u0026gt;\u0026gt; a\u0026amp;b {3, 5} s1.difference(s2) or -\r输出s1对s2的差集；\n差集是出现在s1但不出现在s2的元素的集合；\n即s1和s2的交集对s1的补集；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; b={2,3,4,5,6} \u0026gt;\u0026gt;\u0026gt; a.difference(b) {1, 9, 7} \u0026gt;\u0026gt;\u0026gt; b-a {2, 4, 6} s1.symmetric_difference(s2) or ^\r输出s1和s2的对称差；\n对称差就是除了两个集合共同元素之外的所有元素集合； 即交集对并集的补集；\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; a={1,3,5,7,9} \u0026gt;\u0026gt;\u0026gt; b={2,3,4,5,6} \u0026gt;\u0026gt;\u0026gt; a.symmetric_difference(b) {1, 2, 4, 6, 7, 9} \u0026gt;\u0026gt;\u0026gt; a^b {1, 2, 4, 6, 7, 9} 字典（dict）\r字典在集合的基础上，每个元素由“键”和“值”组成；\n其中集合的互异性和无序性被键所继承；\n因此，字典可以通过键访问值，弥补了集合没有下标的不足；\n字典和列表一样都可以访问元素，但是字典的访问速度明显快于列表；\n这是因为字典内置了索引表，不需要像列表那样遍历所有元素；\n字典快速访问的代价就是会占用大量的内存；\n字典的创建\r分为传统创建和函数创建；\n传统创建\r字典的每个元素都必须同时具备键和值，并通过key:value的形式呈现在同一元素中；\n字典和集合一样都是用的大括号；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 2, 3: 3} 字典的值可以相同，但是键不能重复；\n若有元素出现重复的键，则取重复元素中的最后一个；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,2:3} \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 3} 字典的值可以相同，但是键不能重复；\n若有元素出现重复的键，则取重复元素中的最后一个；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={[1]:1} Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: unhashable type: \u0026#39;list\u0026#39; 函数创建\r使用dict()函数创建； 而dict()也有2种用法；\n序列转换法\r用于将特定格式的序列转换为字典；\n1 2 3 \u0026gt;\u0026gt;\u0026gt; a=[[1,1],[2,2],[3,3]] \u0026gt;\u0026gt;\u0026gt; dict(a) {1: 1, 2: 2, 3: 3} 标识符法\r用类似于创建变量的方式创建字典；\n1 2 \u0026gt;\u0026gt;\u0026gt; dict(a=1,b=2,c=3) {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} 字典元素的访问和赋值\r通过键来访问和赋值；\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; a={1:0,\u0026#39;a\u0026#39;:1,(0):2} \u0026gt;\u0026gt;\u0026gt; a[1] 0 \u0026gt;\u0026gt;\u0026gt; a[\u0026#39;a\u0026#39;] 1 \u0026gt;\u0026gt;\u0026gt; a[(0)] 2 \u0026gt;\u0026gt;\u0026gt; a[1]=[1,2] \u0026gt;\u0026gt;\u0026gt; a {1: [1, 2], \u0026#39;a\u0026#39;: 1, 0: 2} 此外也可以使用函数d.get(key)来返回键对应的值；\n若没有该键，不会报错，而是返回None，无事发生；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; a.get(1) 1 \u0026gt;\u0026gt;\u0026gt; a.get(4) #没有输出 此外，for-in语句同样支持字典；但是是字典的键；\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; for i in a: ... print(\u0026#39;a[%d]=%d\u0026#39; %(i,a[i])) ... a[1]=1 a[2]=2 a[3]=3 字典元素的添加\r在对某键赋值的时候，如果没有该键，则会添加新的元素，其键和值为输入的数据；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; a[4]=4 \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 2, 3: 3, 4: 4} 此外还可以使用d.update()来添加元素，参数和对应功能与dict()相似；\n但是d.update()支持用字典合并元素；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; a.update([[4,4]]) \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 2, 3: 3, 4: 4} 1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; a.update({4:4}) \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 2, 3: 3, 4: 4} 1 2 3 \u0026gt;\u0026gt;\u0026gt; a.update(a=4) \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 2, 3: 3, \u0026#39;a\u0026#39;: 4} 字典元素的删除\r使用del语句来删除指定键的元素；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={1:1,2:2,3:3} \u0026gt;\u0026gt;\u0026gt; del a[3] \u0026gt;\u0026gt;\u0026gt; a {1: 1, 2: 2} 还可以使用d.pop()函数；\n删除时会输出键对应的值；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a={\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3} \u0026gt;\u0026gt;\u0026gt; a.pop(\u0026#39;c\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; a {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} 字典的常用运算\rin，not in，==，!=\n其中两个字典只有所有的键和值都相同才相等；\n字典的常见函数\rd.keys()\r返回一个由所有键组成的序列；\n返回后需要用类型转换函数将其转换成列表或元组；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a={\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3} \u0026gt;\u0026gt;\u0026gt; a.keys() dict_keys([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]) \u0026gt;\u0026gt;\u0026gt; list(a.keys()) [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] d.values()\r返回一个由所有值组成的序列；\n返回后需要用类型转换函数将其转换成列表或元组；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a={\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3} \u0026gt;\u0026gt;\u0026gt; a.values() dict_values([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; list(a.values()) [1, 2, 3] d.items()\r返回一个由2个元素的元组组成的序列； 返回后需要用类型转换函数将其转换成列表或元组；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; a={\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3} \u0026gt;\u0026gt;\u0026gt; a.items() dict_items([(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3)]) \u0026gt;\u0026gt;\u0026gt; list(a.items()) [(\u0026#39;a\u0026#39;, 1), (\u0026#39;b\u0026#39;, 2), (\u0026#39;c\u0026#39;, 3)] d.clear()\r将字典d清空为空字典；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; a={\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3} \u0026gt;\u0026gt;\u0026gt; a.clear() \u0026gt;\u0026gt;\u0026gt; a {} ","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/05.set-dict/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/05.set-dict/","title":"Python基础-05.集合与字典"},{"content":"函数\rPython内置了很多有用的函数，并且可以定义自己的函数。\n在交互模式中，使用help()可以查看参数对应函数的原型以及用法；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; help(abs) Help on built-in function abs in module builtins: abs(x, /) Return the absolute value of the argument. 函数的定义\r使用def定义函数；\n当函数重复定义时，取后面一个定义；\n1 2 3 4 5 6 7 def func(x): if(x\u0026gt;0): return 1 elif(x==0): return 0 else: return -1 该函数用于判断数的正负；\n函数的调用\r在定义函数后可以在后面的程序中调用函数；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt;\u0026gt;\u0026gt; def func(x): ... if(x\u0026gt;0): ... return 1 ... elif(x==0): ... return 0 ... else: ... return -1 ... \u0026gt;\u0026gt;\u0026gt; func(5) 1 \u0026gt;\u0026gt;\u0026gt; func(-2) -1 \u0026gt;\u0026gt;\u0026gt; func(0) 0 函数的参数\r默认值参数\r在python中，函数的参数可以有默认值；\n这样，在调用函数时如果少写了参数，就会使用默认值，而不是报错；\n给参数赋值以让参数有默认值；\n比如下面计算两点之间的距离，如果没有足够数量的参数，就会默认为0；\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; def dis(x1=0,y1=0,x2=0,y2=0): ... return math.sqrt((x1-x2)**2+(y1-y2)**2) ... \u0026gt;\u0026gt;\u0026gt; dis(1,1,2,2) 1.4142135623730951 \u0026gt;\u0026gt;\u0026gt; dis(1,1) 1.4142135623730951 \u0026gt;\u0026gt;\u0026gt; dis() 0.0 使用默认值参数时要注意，函数的参数必须是不可变对象，否则参数的默认值每次都会改变；\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; def add(l=[]): ... l.append(1) ... return l ... \u0026gt;\u0026gt;\u0026gt; add() [1] \u0026gt;\u0026gt;\u0026gt; add() [1, 1] \u0026gt;\u0026gt;\u0026gt; add() [1, 1, 1] \u0026gt;\u0026gt;\u0026gt; add() [1, 1, 1, 1] 此时正确做法是将默认值设为None，等到它没有传入参数时才将其变成空列表[]；\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; def add(l=None): ... if(l==None): ... l=[] ... l.append(1) ... return l ... \u0026gt;\u0026gt;\u0026gt; add() [1] \u0026gt;\u0026gt;\u0026gt; add() [1] \u0026gt;\u0026gt;\u0026gt; add() [1] 可变参数\r可变的是参数的数量，如下面一个函数：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; def sum(*num): ... sum=0 ... for i in num: ... sum+=i ... return sum ... \u0026gt;\u0026gt;\u0026gt; sum(1) 1 \u0026gt;\u0026gt;\u0026gt; sum(1,8,9,54,3) 75 \u0026gt;\u0026gt;\u0026gt; sum() 0 这里通过对参数加*的方式，使得参数变成了元组里面的元素；\n这时无论是传入多少个参数，甚至不传，都不会出现问题；\n此外，序列无法作为函数参数，但是给序列加上*就可以将序列解开为多个元素；\n1 2 \u0026gt;\u0026gt;\u0026gt; sum(*(1,2,3)) 6 关键字参数\r关键字参数在函数调用的时候，相对于位置参数而言的；\n位置参数就是常规的调用参数方式，将参数按照位置顺序依次赋值给函数里的参数；\n这样有个坏处，就是参数太多容易搞混位置；\n比如前面的dis(x1,y1,x2,y2)函数，y1和x2的位置就容易搞混；\n而关键字参数则通过指明形参的形式来定向给某参数赋值，无视位置限制；\n还可以搭配默认值参数使用；\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; def dis(x1=0,y1=0,x2=0,y2=0): ... return math.sqrt((x1-x2)**2+(y1-y2)**2) ... \u0026gt;\u0026gt;\u0026gt; dis(y1=1) 1.0 \u0026gt;\u0026gt;\u0026gt; dis(x2=3,y2=4) 5.0 但是要注意的是，一旦前面使用了关键字参数，后面就不能再使用位置参数； 比如下面的调用，由于前面2个参数是关键字参数，所以后面2个参数不能是位置参数：\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; dis(y1=3,x1=4,4,5) File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1 dis(y1=3,x1=4,4,5) ^ SyntaxError: positional argument follows keyword argument 但是在关键字参数前面使用位置参数是不影响的；\n1 2 \u0026gt;\u0026gt;\u0026gt; dis(1,1,y2=4,x2=3) 3.605551275463989 此外，还可以使用关键字参数向函数传入没有的参数，此时需要用**来收集成一个字典；\n1 2 def person(name, age, **kw): print(\u0026#39;name:\u0026#39;, name, \u0026#39;age:\u0026#39;, age, \u0026#39;other:\u0026#39;, kw) 此时，name，age以外的关键字参数参数都会被收集进字典kw中；\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Bob\u0026#39;, 35, city=\u0026#39;Beijing\u0026#39;) name: Bob age: 35 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Adam\u0026#39;, 45, gender=\u0026#39;M\u0026#39;, job=\u0026#39;Engineer\u0026#39;) name: Adam age: 45 other: {\u0026#39;gender\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} 和可变参数类似，也可以先组装出一个字典，然后，把该字典转换为关键字参数传进去：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; extra = {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} \u0026gt;\u0026gt;\u0026gt; person(\u0026#39;Jack\u0026#39;, 24, **extra) name: Jack age: 24 other: {\u0026#39;city\u0026#39;: \u0026#39;Beijing\u0026#39;, \u0026#39;job\u0026#39;: \u0026#39;Engineer\u0026#39;} 复杂的传参数情况\r默认值参数、可变参数、关键字参数相结合可以极大地拓展函数的功能；\n但是，也极大地复杂了函数的理解难度以及参数传入的规则；\n因此在这里展示复杂的传入参数情况；\n1 2 def f1(a, b, c=0, *args, **kw): print(\u0026#39;a =\u0026#39;, a, \u0026#39;b =\u0026#39;, b, \u0026#39;c =\u0026#39;, c, \u0026#39;args =\u0026#39;, args, \u0026#39;kw =\u0026#39;, kw) 1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; f1(1, 2) a = 1 b = 2 c = 0 args = () kw = {} \u0026gt;\u0026gt;\u0026gt; f1(1, 2, c=3) a = 1 b = 2 c = 3 args = () kw = {} \u0026gt;\u0026gt;\u0026gt; f1(1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) a = 1 b = 2 c = 3 args = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) kw = {} \u0026gt;\u0026gt;\u0026gt; f1(1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, x=99) a = 1 b = 2 c = 3 args = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;) kw = {\u0026#39;x\u0026#39;: 99} \u0026gt;\u0026gt;\u0026gt; f2(1, 2, d=99, ext=None) a = 1 b = 2 c = 0 d = 99 kw = {\u0026#39;ext\u0026#39;: None} 当参数个数较少时，会优先传给必有参数； 如果还是不够，导致非默认值必有参数没有赋值，则报错； 如果必有的参数（可变参数之前）满足了，剩下的参数都会传给可变参数，而可变参数之后的参数只能通过默认值参数来传； 函数的返回值\r函数的返回值只有1个，没有返回值指的是返回值为None的情况；\n但是，可以通过返回元组的方式返回多个值；\n1 2 def twice(x,y): return 2*x,2*y 1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; twice(2,4) (4, 8) \u0026gt;\u0026gt;\u0026gt; a=twice(2,4) \u0026gt;\u0026gt;\u0026gt; a[0] 4 \u0026gt;\u0026gt;\u0026gt; a[1] 8 可以看到，返回的其实是一个元组，只是省略了括号； 相应地，也可以通过省略括号的元组来接收返回值；\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; x,y=twice(2,4) \u0026gt;\u0026gt;\u0026gt; x 4 \u0026gt;\u0026gt;\u0026gt; y 8 ","date":"2025-02-22T00:00:00Z","image":"http://localhost:1313/post/tutor/python_learning/06.function/py_hu_edb346c21e1e3999.png","permalink":"http://localhost:1313/post/tutor/python_learning/06.function/","title":"Python基础-06.函数"},{"content":"c_cpp_learning\r介绍\r学习C和C++的笔记！\n从2024年10月29日开始，将会逐渐将代码和注释分离，并将注释用markdown文件重写；而代码会成为markdown笔记的附件；\n本笔记前面大部分是C的学习内容，还有少量C++的拓展。后面C++的内容会多一些。已经在笔记中用标题做了区分，并用c和cpp后缀来区分代码附件。 所以，虽然C和C++交替出现，抛弃掉C++的拓展也能获得详尽的C语言笔记。\n笔记没有完全按照学习顺序分布，而是模块化的；若感到理解困难，不妨跳到对应的模块查看相关内容，或自行上网查询资料；\n由于编译时可能会出现中文乱码问题，因此代码中的输出均使用英文表示。\n本笔记现已在GitHub和Gitee上发行。\n更新日志\r2024/11/29 14:51 v0.0.0\r芜湖！鸽了好久的正式版终于上线啦！\n在发布v -1.7.0 时，我曾经说过下个版本要大更新；\n当时只剩指针和引用没有被重制了；\n结果后来遇到各种事情，就暂时把上线放到了后面；\n没想到这一耽搁就是18天!!!\n但是还好，自上次 v -1.0.0 于10月29日上线以来到现在，刚好过去了一个月；\n以后如果有人问起来，还可以说自己是为了凑整一个月才推迟的；哈哈\nOK，这个版本就像之前说的一样，笔记已经100%使用markdown编写；\n代码部分以附件的形式存在于文件夹中；希望你们喜欢这种新形式的排版！\n2025/1/11 20:07 v0.1.0\r放假咯！\n之前因为学习把笔记的编写耽误了太久，现在终于有时间来专心写笔记了；\n接下来会将链表和文件的内容补齐，那么C语言的内容就差不多了；\n届时会推行正式版v1.0.0！\n接下来的安排就是C++了；\n此外还会推行新的仓库python和数据结构，敬请期待！\n2025/1/17 15:02 v1.0.0\r这是正式版！\n现在已经将链表和文件的内容补齐了，那么C语言的内容差不多就结束了；\n之后对于C语言只会对现有内容做一些修补工作，应该不会再添加新的内容了；\n但是，此后还会更新C++的新内容，等到C++更新完毕后会推出2.0版本，敬请期待！\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/readme/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/readme/","title":"C/C++基础-00.简介"},{"content":"最基础的C程序\r1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } stdio.h是C中掌管输入输出的头文件，必须要 #include它才能实现后续的输出操作； main是主函数，用来执行你的代码操作； printf是C语言的标准输出函数，它可以向你的屏幕打印 hello world；\n最基础的C++程序\r1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt;\u0026#34;Hello World\\n\u0026#34;; return 0; } iostream是c++的头文件;\n还想用C的头文件的话就只能在前面加“c”(不用加.h); 如stdio.h变成cstdio；\nstd是标准命名空间，包含大量基本函数。不同命名空间的函数定义是不一样的。 cout可以被认为是C++里的printf，加上\u0026laquo;即可。\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/01.helloworld/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/01.helloworld/","title":"C/C++基础-01.hello world"},{"content":"printf\rprintf还可以用来做计算。见下方代码(printf.c)：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello，114+514=%d\\n\u0026#34;, 114+514); return 0; } 这个代码可以输出数字之间的运算；\n1 printf(\u0026#34;hello，114+514=%d\\n\u0026#34;, 114 + 514); %d 说明后面要有1个整数输出在这个位置上，在后面接一个逗号，填入计算式（当然也可以是一个数）； 则程序运行过程中，%d 将被替换为计算结果 114+514=628，所以输出：\nhello，114+514=628\n在C语言中，四则运算符略有不同： 加号与减号不变； 乘号为 * ，不是 ×;\n除号为 / ，不是 ÷ （实际上也很难打出错误的那一个）\n另外，还有取余符号%，读作“模”;\n514%14即为514/14=36\u0026hellip;10，取余数10，所以514%14=10\nscanf\r相对于printf用于输出，函数scanf可以用于输入数据用于计算; 不过最后还是要用printf输出计算后的数据; 例(scanf.c)：\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int atk=0;//定义变量atk，初始值为0（也可以是其它数值，但必须是整数） printf(\u0026#34;I have 100 hp now,and please attack me.\\n All you need to do is to input your attack here:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;atk); int hp = 100 - atk;//定义另一个变量hp，它的初始值为 100 - atk ;若先前输入20，则hp的初始值为 100 - 20 = 80 ; printf(\u0026#34;OK,now I only have %d hp.\\n\u0026#34;, hp); return 0; } 运行代码，此时屏幕上显示：\nI have 100 hp now,and please attack me.\\n All you need to do is to input your attack here:\n此时可以在窗口输入内容； 若为整数，则 \u0026amp;atk 会将输入的内容存储到变量atk上；若 \u0026amp;atk 没有 \u0026amp; ，代码会直接崩溃。 若不为整数，则直接忽略你输入的内容，atk仍为初始值0；\n接下来就很熟悉了，若输入20，则应该输出:\nOK,now I only have 80 hp.\n注意：若攻击超过100，血量可以为负；\nstdio：C语言标准输入输出\r都讲了C++的输出了，是时候讲一下stdio到底是什么了；\n看到stdio.h时，会发现，std就是C++里面的标准命名空间，而i代表input，o代表output；\n因此，stdio的意思就是标准输入输出；\n那我们就知道了，stdio包括stdin stdout，此外还有stderr，用来记录报错；\n正是引入的头文件里面这些标准输入输出，让我们能够实现人机交互；\n通过向机器输入一些数据，让机器通过程序计算来向人类输出预期结果；\n在C语言中，stdin和stdout主要是由scanf和printf函数来完成的；\n除此之外还有getchar/putchar;gets/puts等形式；\nscanf用于从标准输入获取数据并格式化，而printf用于向标准输出发送数据并格式化; 没错，在这里标准输入就是键盘，标准输出就是你的电脑屏幕;\n什么是格式化呢？就是通过一些特殊字符（如百分号或转义字符）将函数后面的参数转化; 比如%d可以转换为整型变量，%f可以转换为浮点型变量; 此外，还可以在百分号后面加上若干正则，来进一步修饰限制参数格式;\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/02.i-o/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/02.i-o/","title":"C/C++基础-02.输入输出"},{"content":"数据类型与运算\r走进变量\r之前我们定义变量，并用变量来存储用函数scanf输入的数据，并用printf输出存储值；\n那么，现在让我们更深入的了解一下变量；\n当要在程序里保存数据时，就需要一个变量来保存它； 用一个变量保存了数据，它才能参加到后面的计算中； 不定义变量，函数scanf就无法使用，因为数据得不到保存；\n变量定义的一般形式就是：\u0026lt;类型名称\u0026gt; \u0026lt;变量名称\u0026gt;； int就是一种类型名称，除此之外还有很多种类型名称；\n变量名称自己任意取，只能由字母、数字和下划线 _ 组成，数字不可以出现在第一个位置上，区分大小写；\n此外，C语言的关键字（如int）不可以用作变量名称。\n利用变量来储存数据时，常用赋值运算符“=”；\n在C语言中，“=”不表示相等关系，而是赋值动作，是动态过程；\n如 int a = 114 ；就表示把114储存在a这个变量中，并不代表a和114相等；\n除此之外，还可以用scanf一次输入多个变量或者常量，或者是用printf展示多个变量，如以下的例子：(int.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0 ;//定义变量 int atk2 = 0 ; const int ATK3 = 10 ;//定义常量 int originalhp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); int hp = originalhp - atk1 - atk2 - ATK3; printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n \u0026#34;,originalhp,atk1,atk2,ATK3,hp); return 0; } int为定义变量，不必多说；\nconst int为定义常量,用const int定义的常量数值永远不会发生变化，因此常用大写字母表示(ATK3)；\n如果想要强行用赋值表达式改变常量数值，会报错； const int 的意义在于给予常数名字，从而增强代码的可读性； 如ATK3即玩家3的攻击，它的数值为10；如想修改玩家3的攻击，只需找到ATK3，而不是10；\n1 2 3 4 5 printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); 这里连续使用多个scanf函数，以输入两名玩家的攻击。\n注意：在函数scanf中，只有输入数据并按回车后，才会执行下面的代码； 同理，碰到scanf后，会暂停读后面的代码；\n1 2 int hp = originalhp - atk1 - atk2 - ATK3; printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n \u0026#34;,originalhp,atk1,atk2,ATK3,hp); 这里的printf一次展示了多个变量； 想输出几个变量，就在前面放入几个 %d ，用 %d 代替要展示的变量；\n相应地，在后面，要填入等量的变量，中间用逗号隔开，注意变量之间的顺序；\n一种代码运行示例：\nI have 100 hp now.\nThere have 3 players that will attack me.\nWe have known player3\u0026rsquo;s attack is 10.\ninput player1\u0026rsquo;s attack:20\ninput player2\u0026rsquo;s attack:30\n(20 和 30 为运行时自己输入，可更改。)\nOK,Now I only have 100-20-30-10=40 hp.\n更多变量类型\r在生活中，常用到小数；\n例如 10/3 ，结果为3.33333333（循环）;\n但如用C语言计算，如 printf(\u0026quot;%d\\n\u0026quot;,10/3) ，答案却是3！\n这是在C语言中，整数的运算结果只能是整数；\n因为10和3都是整数，所以，3.33333333（循环）进行了向下取整，得到10/3=3。\n如此，便会得到10/3*3=9这样的离谱结果！\n此时，有一个解决方案，就是利用C语言中的浮点数。 浮点数就是带小数点的数值。浮点这个词的本意就是指小数点是浮动的， 是计算机内部表达非整数（包含分数和无理数）的一种方式。\n如下面的例子：(divider.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { //dividend 被除数\tdivisor 除数 int a = 0, b = 0, c = 0, d = 0; double g = 0; printf(\u0026#34;It\u0026#39;s a calculator for division.\\n\u0026#34;); printf(\u0026#34;input dividend and divisor in order:\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); c = a / b; d = a % b; g = a *1.0/ b; printf(\u0026#34;%d÷%d=%d...%d\\n\u0026#34;, a, b, c, d); printf(\u0026#34;%d÷%d=%f\\n\u0026#34;,a,b,g ); return 0; } 以10/3为例，得到的结果为：\n10÷3=3\u0026hellip;1 ；\n10÷3=3.333333 ；\n1 2 int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0; double g = 0; 与int类似，double也是类型名称；\n只不过int类型的变量始终为整数，而double类型的变量始终为浮点数；\n因此，初始值a=b=c=d=e=f=0;\n而g=0.000000（其实还有更多位，但只显示6位小数）\n1 g = e *1.0/ f; 需要注意的是，不能直接写 g = e / f ;\n因为上面提到，整数的运算结果只能是整数；\n而 e 和 f 都是 int 类型的变量，显然会抹掉结果的小数部分；\n这样，即使 g 是 double 类型的变量，也不会得到正确结果；\n比如，当 e=10 ，f=3 时，显示 10÷3=3.000000 ;\n而不幸的是，虽然问题出在 a 和 b 的类型名称 int 上，更改 int 为 double 并不能解决问题;\n因为，这样会让 e 变为10.000000， f 变为3.000000； 显示的会是：\n10.000000÷3.000000=3.333333；\n虽然结果对了，但是我输入的是整数，来这么多小数干啥！而且浮点数取余也会出错；\n因此，我们不更改 int 为 double ，而是 e * 1.0 ； 这样既利用1.0这个浮点数将结果设置为浮点数 3.333333 ，又不会影响结果；最终显示：\n10÷3=3.333333\n1 printf(\u0026#34;%d÷%d=%f\\n\u0026#34;,e,f,g ); 同理，在使用浮点数变量时，函数printf和scanf也有对应的改变； printf中 %d 变为 %f ；scanf中 %d 变为 %lf ；\n用了%d会发生什么\r如果在 double 类型的变量中，用了%d会发生什么?\n下面是关于上述问题的探究。\n1.编写以下代码(%d-test.c)，输入1，观察输出结果；\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { int a ; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } 2.改变变量类型名称，printf，scanf，重复上述操作\n3.输出结果记录如下：\n定义 scanf printf 输入1后的输出 int %d %d 1 int %d %f 0.000000 int %lf %d 0（代码报错） int %lf %f 0.000000（代码报错） double %d %d 1 double %d %f -92559592117457364459447783688012762948756726027711679117131776.000000(就离谱) double %lf %d 0 double %lf %f 1.000000 结论：只有 printf 和 scanf 与变量类型配套，才能输出正确结果，否则输出离谱结果！\n数据类型\r我们已经知道：C语言是有类型的语言； C语言中的类型包含整数类型、浮点数类型、字符类型、逻辑类型、以及指针和自定义类型； 接下来将详细讲解整数类型、浮点数类型、字符类型和逻辑类型； 指针和自定义类型放到后面再讲；\n整数类型\r整数包括5种类型；\n分别是 short char int long 和 long long ； 它们的字节数不同；\nchar 1 (8 bit)\nshort 2\nint 取决于编译器类型；一般为4个字节；\nlong 4\nlonglong 8 具体可通过sizeof函数查验。\n以int类型为例：(sizeof.c)\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, sizeof(int)); return 0; } 可以看到输出结果是4；代表本编译器int类型变量为4个字节；\nbit是什么呢？ 就是二进制中的一个数，因此8个二进制数就表示一个字节；\n补码\r在计算机内部，一切都是二进制数，所有数都可以用二进制数表达；\n那么，负数如何表达?\n答：补码\n一个正数的相反数与其相加可以得到0；\n利用这个特性可以用补码来表达二进制下的负数；\n例如，对于char类型的变量，因为是一个字节，所以可以表达2^8=256个数；比如1是0000 0001；\n已知-1+1=0；那么与0000 0001相加等于0的自然就是-1；\n事实上，对于char类型的变量，我们只需得到八位是零即可，剩下一位会溢出；\n因此，相加等于1 0000 0000即可； 所以-1就是1111 1111，它就是0000 0001的补码；\n这样做，会使变量在正数范围表达的数变少；\n比如1111 1111如不当作补码看待，就是255；\n为了不重复，char类型的变量范围将从0255变为-128127；\n其中-128是1000 0000；127是0111 1111；\n以此类推，short可以表达-32768~32767的整数;\n而int、long、long long就更多了；\n一个数的正负，主要看最高位，若为1则是负数，若为0则是正数或0；\n如果想让char类型的变量范围变回0~255，可以在前面加上unsigned；\n比如，unsigned char的1111 1111 表达的就是255； 但它仍不能表达高于255的数；\n如果超出了数据范围进行运算，变量可能会越界并溢出； 如下面的例子(full.c)：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { char a = 127; a = a + 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); return 0; } 输出结果：\na = -128；\n这是因为0111 1111 + 0000 0001 = 1111 1111\n而1111 1111 根据补码就是-128；\n同理，也可以得到 -128+1=0这样的离谱结果；\n在初始化变量的值时，输入的值默认为int类型； 如果想要输入其它形式，可以加上后缀字母； 比如，加上u可以输出unsigned；加上l可以输出long和longlong；\n此时可以省略int；\n除了后缀，数字还可以加上前缀； 前缀一般表示数的进制； 比如八进制在数字前面加上0，十六进制在数字前面加上0x；\n比如,输入012,就是十进制的10;\n输入0x12，就是十进制的18；\n对于在scanf和printf中整数的输入输出，之前提到了%d； 事实上，一共有4种形式：\n%d %u %ld %llu int unsigned (int) long long (int) unsigned long long (int) 其中字节小于等于int的变量，即char、short、int都按int类型输入输出；\n字节大于int的变量，即long和long long都按long long类型输出；\n此外，还有%o和%x，它们分别表示八进制数和十六进制数，且输出的数不带有前缀；\n浮点数类型\r在数据类型中，与整数相对的就是浮点数；\n浮点数包括三种类型，分别是：float、double、long double；\n它们的内存分别是8个字节、16个字节、32个字节；\n由于long double极少用到，这里只介绍float和double；\nfloat变量的范围为 ±(1.2e-383.4e38)和0；\ndouble变量的范围为 ±(2.2e-3081.79e308)和0；\n这代表它们在极其接近0的部分仍有一小部分数无法表达（不包括0）；\n此外，浮点数可以输出 ±inf 和 nan；\ninf即infinite，即无穷大；\n与一般的算数规则不同，正数除以0可以得到+inf，负数除以0可以得到-inf；\nnan即not a number，表示非数；即不存在的数；\n0除以0可以得到nan；\n另外，由于计算机内部的数均为二进制数，对于小数位数过多的数，计算机只能以近似的数去拟合；\n这就是说，浮点数的范围区间并不是连续的，而是离散的；\n拟合的精度有限。所以把浮点数准确的小数位数称为有效位数； float的有效位数为7，double的有效位数为15； 所以double又叫“双精度浮点数”； 因此，当两个浮点数的差小于1e-7时，就可以认为它们是相等的了；\n用 == 判定两个浮点数相等反而是错误的；\n与整数类似，浮点数输入输出也有其特定形式； float输入用%f，输出也用%f； double输入用%lf，输出用%f；\n此外，还可以用%e输出，此时输出的是浮点数的科学计数法； 浮点数输入可直接使用科学计数法形式；\n浮点数的二进制表达形式一般如下：\n以double为例，它由64bit； 第一位（最高位）用来记录数的正负（补码）； 2-12位用来记录浮点数的数量级；\n后面的位用来表示浮点数的有效数字；\n由于用来表达有效数字的bit终究是有限的，所以在小数位数过多时会产生误差；\n正如整数输入的类型默认为int，浮点数输入的类型默认为double； 想要表达float可以在数字后面加上f；\n如果没有特殊需要，整数类型用int，浮点数类型用float就行了；\n字符类型\rchar除了表示整数，还可以表示字符；\n因为char是character的缩写；\n除了字母、符号，数字同时也可以是字符；\n输入输出char类型变量可以使用**%c**；\n由于计算机内部全部是二进制数，因此要想办法把字符转换为二进制数；\n因此要使用ASCII编码，每个字符与ASCII中的一个数字编码一一对应；\n再将ASCII编码转换为二进制数，就能实现字符在计算机内部的表达；\n想要初始化char类型的变量为字符，不管它是不是数字，都必须加上单引号； ‘1’，以将字符变量和一般变量做区分；\n如果数字没加单引号，char将会存储数字对应的ASCII编码的字符；\n如果非数字没加单引号，如果这不是一个变量，会报错；\n值得一提的是，‘’也是一个字符，即使单引号里面没有任何东西；\n它的ASCII码是0；\n字符也可以进行计算，但实际计算的是字符的ASCII编码； 比如， 一个字符加一个数字得到ASCII码表中加上那个数之后的字符； 两个字符运算，先将字符转换为ASCII编码，算完后再转换为字符； 如下面的例子(char.c)：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { char x = \u0026#39;a\u0026#39; + 1; char y = \u0026#39;b\u0026#39;-\u0026#39;a\u0026#39;; printf(\u0026#34;%c\\n\u0026#34;,x); printf(\u0026#34;%d\\n\u0026#34;,y); } 输出结果：\nx=‘b\u0026rsquo;；y=1\n除此之外，还有一类特殊的字符，称为“逃逸字符”；\n它们以反斜杠 \\ 开头，作用是控制 printf 输出的内容； 逃逸字符主要包括以下这些：\n\\b \\ \u0026quot; \\t \\ ' \\n \\ \\ \\r 回退一格 双引号 到下一个表格位 单引号 换行 反斜杠本身 回车 其中\\t可以起到让数据在表格位对齐的作用（即输入一个TAB键）；\n类型转换\r类型转换分为自动类型转换和强制类型转换；\n当运算符(双目)的两个变量类型不同时，会发生自动类型转换；\n自动类型转换很简单，一般是把小的往大的转换；\n比如把整数转换为浮点数，内存小的转换为内存大的；\n有时，我们需要在各个变量类型之间做转换； 这时，我们就要用到强制类型转换符； 它的格式是 （类型名）值；\n如下面的例子：\nint a;\na= (int) 3.5;\n则a的值为3；\n同时强制类型转换也是一个运算符；\n它的优先级为1，比任何运算符都高；\nbool类型\rboll类型更像是逻辑类型。它的值只能是0和1；\n0非1是；\n因此，使用bool类型可以加快代码运行速度；\nC语言中的简单运算\r数学运算\r一个表达式是一系列运算符和算子的组合，用来计算一个值；\n运算符是指进行运算的动作；\n算子是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个函数的返回值；\n运算符有很多种，比如 + - * / % 都是运算符；\n当多个运算符出现在同一个表达式中时，是如何进行运算的呢？\n类似于“先乘除，后加减”，运算符之间也有优先级，用1，2，3\u0026hellip;表示，数字小的优先级高；\n下面是一些运算符的优先级：\n优先级 运算符 运算 结合关系 举例 1 () 括号 自左向右 a(b+c) 2 + 单目不变 自右向左 a*+b 2 - 单目取负 自右向左 a*-b 2 ++ 自增 自右向左 a++ 2 \u0026ndash; 自减 自右向左 a\u0026ndash; 3 * 乘 自左向右 a*b 3 / 除 自左向右 a/b 3 % 取余 自左向右 a%b 4 + 加 自左向右 a+b 4 - 减 自左向右 a-b 14 = 赋值 自右向左 a=b 14 += 加法赋值 自右向左 a+=b 14 -= 减法赋值 自右向左 a-=b 14 *= 乘法赋值 自右向左 a*=b 14 /= 除法赋值 自右向左 a/=b 14 %= 取余赋值 自右向左 a%=b 运算符可以以算子数目分类；\n单目运算符指只有一个算子的运算符，此外还有双目和三目运算符；\n一般来说，单目运算符的优先级更高；\n单目不变和单目取负是指对它右边的数不变或取负； 如 a*-b ，即a乘以b的相反数； 因此它们的优先级最高；\n结合关系是当优先级相等时运算的顺序；例：\na/b*c即为a/b后，再乘以c；\n\u0026ndash;a即-(-a)，因为单目取负结合关系为自右向左；\na=b=c 即先把c的值赋给b，再把b的值赋给a，因为赋值运算符结合关系为自右向左；\n优先级一致的运算符结合关系也相同；\n此外，还有复合赋值和自增自减运算符；\n赋值运算符包含 *+= -= = /= ，它们的作用是快速将变量变成新的值；\n如 a+=1 ，等价于 a = a + 1 ；\n另外，要注意的是，*=和/=在使用时，由于运算优先级，会先将右边的结果算完再赋值；\n如 a *= 6+12 等价于 a *=(6+12) 等价于 a = a * (6+12);\n自增自减运算符可快速将变量的值变化1；\n如 a++ 等价于 a+=1 等价于 a = a + 1 ：\n此外，又有 a++ 和 ++a 两种表达方式；\na++的值是a加1以前的值，而++a的值是加了1以后的值；\n无论哪个，a自己的值都加了1了； 具体，可以看下面的例子：(Self-incrementing.c)\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); printf(\u0026#34;a++=%d\\n\u0026#34;, a++); a = 1; printf(\u0026#34;++a=%d\\n\u0026#34;,++a); return 0; } 输出结果：\na=1\na++=1\n++a=2\n这就是因为++a先把值赋给了a再参与运算； 而a++先参与运算再赋值； 故 a++ =1；但此时a的值已经是2了；\n另外，表达式在使用时应该尽量简便； 应避免使用复杂的表达式，而是拆成多个简单的，便于我们理解。\n像 ++a++ 这样的就是典型的错误案例；\n关系运算\rif函数离不开的就是关系运算符；以下是常见的关系运算符：\n优先级 运算符 运算 结合关系 示例 6 \u0026gt; 大于 从左向右 a\u0026gt;b 6 \u0026gt;= 大于或等于 从左向右 a\u0026gt;=b 6 \u0026lt; 小于 从左向右 a\u0026lt;b 6 \u0026lt;= 小于或等于 从左向右 a\u0026lt;=b 7 == 等于 从左向右 a==b 7 != 不等于 从左向右 a!=b 当关系运算符所在的关系式为真时，输出1，反之输出0； 实际上，if函数等正是通过检验括号内是否为0来决定要不要进行下面的内容的；\n注意：仍然遵循从左至右的结合关系；\n例如 5\u0026gt;4\u0026gt;3 -\u0026gt; 1\u0026gt;3 -\u0026gt; 0\n但 5\u0026gt;3==4\u0026gt;2 却是另一种算法，因为等于和不等于的优先级略低； 因此 5\u0026gt;3==4\u0026gt;2 等价于 1==1 ；\n逻辑运算\r逻辑运算符如下：\n优先级 运算符 运算 结合关系 举例 2 ! 逻辑非 从右向左 !a 11 \u0026amp;\u0026amp; 逻辑与 从左向右 a\u0026amp;\u0026amp;b 12 || 逻辑或 从左向右 a||b 逻辑运算符主要检测其附近的表达式的值是否为0；\n对于逻辑与，只有两边的表达式结果均不为0时，才输出1；若有一个是0，则输出0；\n对于逻辑或，只要两边的表达式有一个结果不是0，就输出1；只有两个均是0时才输出0；\n对于逻辑非，它右边的表达式结果为0则输出1；不为0则输出0；\n例如\n2\u0026amp;\u0026amp;0=0；3||0=1；!4=0；\n注意：计算机在进行\u0026amp;\u0026amp;和||的运算时，若左边边的值足以判定结果为1还是0时，就不会看右边了！\n这种情况被称为短路。\n对于\u0026amp;\u0026amp;，左边是0时就不做右边了； 对于||，左边是非0时就不做右边了；\n具体可以看下面的例子：(logic.c)\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; int b = 0; int c; c = (a==0) \u0026amp;\u0026amp; (b+=1); printf(\u0026#34;%d\\n\u0026#34;, b); return 0; } 可以看到b的值仍然为0，b+=1并没有执行；\n为了避免短路，应该避免在逻辑运算中插入赋值运算；\n条件运算符\r它是唯一的三目运算符，其实也非常简单； 格式如下：\na ? b : c ;\n可翻译为判断a是否成立，若是，进行b；若否，进行c；\n作为运算符，它的运算优先级为13，仅仅高于一系列赋值运算符；\n逗号运算符\r逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。\n逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算；\n逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。\n说实话这个运算符没什么用\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/03.data-calc/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/03.data-calc/","title":"C/C++基础-03.数据类型和运算"},{"content":"条件与循环\r在这一章里面，你将化身数个玩家来攻击solxr。\n为了更好的折磨solxr，你需要设计一些程序，来模拟solxr的痛苦；\n可是，在你设计程序的时候，却在面对选择和循环时无从下手；\n幸运的是，你找到了下面这个教程，来帮助你快速掌握选择与循环的相应知识；\nif/else : 条件判断\r编程不能仅限于输入输出，有时还要判断。\nif函数就是用来做判断的；\n一个基本的if语句由一个关键字if开头，跟上在圆括号()里的一个表达条件的逻辑表达式；\n然后是一对大括号{}之间的若干条语句；\n具体怎样发挥作用，看下面的例子：(if.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; const int ATK3 = 10; const int DEATH = 0; int originalhp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); int hp = originalhp - atk1 - atk2 - ATK3; if (hp\u0026gt; DEATH) { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n\u0026#34;, originalhp, atk1, atk2, ATK3, hp); printf(\u0026#34;Fantastic! I\u0026#39;m still ALIVE!\\n\u0026#34;); } else { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=...\\n\u0026#34;, originalhp, atk1, atk2, ATK3); printf(\u0026#34;No!!My hp come to the bottom!\\nOops!I DEAD!\\n\u0026#34;); } if (hp \u0026lt;= 0) { printf(\u0026#34;Congratulation to your success!Goodbye!!\\n\u0026#34;); } return 0; } 输入样例1：\n10\n20\n输出结果1：\nOK,Now I only have 100-10-20-10=60 hp.\nFantastic! I\u0026rsquo;m still ALIVE!\n输入样例2：\n50\n90\n输出结果：\nOK,Now I only have 100-50-90-10=\u0026hellip;\nNo!!My hp come to the bottom!\nOops! I DIED!\nCongratulation to your success! Goodbye!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (hp\u0026gt; DEATH) { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n\u0026#34;, originalhp, atk1, atk2, ATK3, hp); printf(\u0026#34;Fantastic! I\u0026#39;m still ALIVE!\\n\u0026#34;); } else { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=...\\n\u0026#34;, originalhp, atk1, atk2, ATK3); printf(\u0026#34;No!!My hp come to the bottom!\\nOops!I DEAD!\\n\u0026#34;); } if (hp \u0026lt;= 0) { printf(\u0026#34;Congratulation to your success!Goodbye!!\\n\u0026#34;); } if函数如果条件为真，则执行大括号里的语句，否则跳过，继续执行下面的语句；\n但如果if函数后面出现了else，则若不满足条件，就会执行else大括号里的语句，保证不会出现遗漏条件的情况；\n如上面的if函数，若hp \u0026lt;= 0，会输出死亡对话；否则输出存活对话； 而下面的if函数，如hp \u0026gt; 0，则无事发生；\nswitch/case : 条件选择\rif和else之间可以嵌套使用，形成形如下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 if() {...} else if() {...} else if() {...} . . . else {...} 当需要进行多次判断时，常用嵌套的if-else函数来解决；\n但这样做有个坏处，就是会由于多个if的存在使得代码显得非常杂乱，还容易出错；\n这时，就可以使用switch函数来解决问题； 如下面的例子：使用switch函数来判定solxr的血量范围，进而输出对应的对话；(switch.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; const int ATK3 = 10; int originalhp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); int hp = originalhp - atk1 - atk2 - ATK3; int level = hp / 10; printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=\u0026#34;, originalhp, atk1, atk2, ATK3); switch (level) { case 9:printf(\u0026#34;%d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); break; case 8:case 7:case 6:printf(\u0026#34;%d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); break; case 5:case 4:case 3:case 2:printf(\u0026#34;%d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); break; case 1:case 0:printf(\u0026#34;%d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); break; default: printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); break; } return 0; } 输入样例1：\n0\n0\n输出结果1：\nOK,Now I only have 100-0-0-10=90 hp;\nI guess you didn\u0026rsquo;t want to hurt me.\nthank you very much!\n输入样例2：\n5\n10\n输出结果2：\nOK,Now I only have 100-5-10-10=75 hp;\nMy hp is still high now!\nThanks for your mercy!\n输入样例3：\n30\n30\n输出结果3：\nOK,Now I only have 100-30-30-10=30 hp.\nIt\u0026rsquo;s really hurt\u0026hellip; But I\u0026rsquo;m still alive!\n输入样例4：\n50\n45\n输出结果4：\nOK,Now I only have 100-50-45-10=-5 hp;\nGood! I think I\u0026rsquo;m so lucky that I made it with such few hp!\n输入样例5：\n100\n200\n输出结果5：\nOK,Now I only have 100-100-200-10=\u0026hellip;No!! My hp come to the bottom!\nOops!I DIED!\nCongratulation to your success! Goodbye!!\n这里要根据“我”的剩余血量来触发对话内容，有多个判定节点；\n因此如果要用if函数，就必须要嵌套；\n下面是一种可能的例子：\n1 2 3 4 5 6 7 8 9 10 if(hp\u0026gt;=90) {...} else if(hp\u0026gt;=60) {...} else if(hp\u0026gt;=20) {...} else if(hp\u0026gt;0) {...} else {...} 这样写，编译器必须从上读到下，而且我们也难以第一时间读懂代码想表达什么；\n因此，这时，就可以使用switch函数来解决问题，这时编译器只需读取一种情况就可以了；\n1 2 3 4 5 6 7 8 9 10 11 switch (level) { case 9:printf(\u0026#34;%d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); break; case 8:case 7:case 6:printf(\u0026#34;%d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); break; case 5:case 4:case 3:case 2:printf(\u0026#34;%d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); break; case 1:case 0:printf(\u0026#34;%d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); break; default: printf(\u0026#34;No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); break; } switch函数由switch 和 case default 组成；\n与if一致，switch函数也需要圆括号() ，它会检测圆括号里面的变量数值来执行case里面的内容；\n注：case里面的数必须是正整数，这是switch相对于if的局限性；\n对于此代码，我们可以将100种hp换算为10种level，用hp/10就可以了！\n不然，要我写100个case，还不如用if函数！\ncase后面也要加大括号{}；\n想要表示一种情况，case和数之间要加空格，之后要有冒号:\n在冒号后面加上想要添加的代码，满足case后就可以执行以下的代码内容；\n在每种case最后，要加上 break;\n否则就会直接执行下一个case里面的内容；\n不过，也可以利用这个特性，合并多种case，使它们执行相同的内容；\n如上面就将case01；case2345；case678合并了；\n在switch函数的最后，还有一个东西，就是default； 当条件都不满足case时，执行default里面的内容；\n如果你保证switch函数的所有条件都在你的case里面，可以不写default；\n不然，忘记写了你就等着报错吧！\n小技巧：如果想要使用switch函数，但又没有正整数，可以尝试将其化为正整数；\n如利用关系运算符输出的结果只有0和1，把区间化为整数；\nwhile/do-while ：循环操作\r无论是if还是switch函数，编译器都只会读取1次；\n当需要多次执行判断时，使用if或switch都会显得非常麻烦；\n特别是当不知道判断的次数时，if和switch都会无能为力；\n这时，就需要while：循环函数来帮忙；\n如下面的例子，当我们需要攻击多轮且记录solxr被战胜前攻击的回合数时，就需要用到while函数：(while.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; const int ATK3 = 10; int originalhp = 0; int hp = 0; int n = 0; printf(\u0026#34;There have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\\ninput my hp:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); hp = originalhp; do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); printf(\u0026#34;I have 100 hp now.\\n\u0026#34;,hp); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); while (atk1\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk1); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1); } printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); while (atk2\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk2); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2); } hp = hp - atk1 - atk2 - ATK3; printf(\u0026#34;OK;Now I only have\u0026#34;); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34; %d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34; %d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34; %d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); }while (hp \u0026gt; 0); printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); return 0; }\twhile循环包含两个重要组成部分，一是循环条件，二是循环内容；\n循环条件指判断是否开始或继续循环的内容，需要在while后面用圆括号()括起来，与if类似；\n循环内容也与if类似，用大括号{}括起来；\n循环成功搭建后，只要满足循环条件，就会不断的执行循环内容，直到条件不满足为止； 因此，一定要有条件让系统有机会脱离循环，否则就会陷入死循环！\nwhile循环分为两种，一种循环条件写在前；另一种写在后面；\n第一种：\n1 2 while (...) {...} 第二种：\n1 2 3 do {...} while (...); 在必须先判定时，应该用第一种；在必须要执行一次循环时，应该用第二种； 需要注意的是，第二种最后依然需要分号，因为结尾不是大括号，不能成为语句；\n先看第一个循环：\n1 2 3 4 5 6 7 while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); 如果你没有输入正确的血量，程序就无法继续正常进行；\n因此设置了这个循环来提醒输错的玩家，并引导他们纠正；\n在这个循环中，先判断玩家有没有输对，如果不对，则报错提示玩家正确输入；\n如再次输错，则循环此命令，直到玩家输对为止，再执行下面的程序； 后面关于atk1和atk2的处理也是如此；\n这里一定要先判断，所以使用第一种循环；\n接下来是第二个循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); printf(\u0026#34;I have %d hp now.\\n\u0026#34;,hp); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); while (atk1\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack is too ABNORMAL!\\n\u0026#34;,atk1); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1); } printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); while (atk2\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack is too ABNORMAL!\\n\u0026#34;,atk2); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2); } hp = hp - atk1 - atk2 - ATK3; printf(\u0026#34;\\nNow I only have\u0026#34;); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34;%d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34;%d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34;%d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); }while (hp \u0026gt; 0); 1.先输入玩家1和2的攻击，必须为正，否则报错；\n2.根据玩家123的攻击计算玩家的剩余血量；\n3.输出“我”的剩余血量，并根据“我”的剩余血量来触发对话内容；\n（这里没有用switch而选择if else级联的原因是switch函数不好对hp=0的情况进行判定）\n4.回合数+1；\n5.若hp\u0026gt;0，提示玩家继续攻击，并重复1-4步骤；直到hp\u0026lt;=0为止；\n6.结束循环；\n这里一定要进行第一回合，所以使用第二种循环；\n1 2 3 printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); 结算阶段，不完成上面的循环无法执行最后的结算代码；\n用printf输出回合数；\n这里展示一种测试时终端输出的样例：\nThere have 3 players that will attack me.\nWe have known player3\u0026rsquo;s attack is 10.\ninput my hp:-1\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of -1!!\nPlease input it again:5\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of 5!!\nPlease input it again:100\nOK;\nRound 1 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!!\nPlease input it again:0\ninput player2\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!! Please input it again:0 OK;Now I only have 90 hp;\nI guess you didn\u0026rsquo;t want to hurt me.\nthank you very much!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 2 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:5\ninput player2\u0026rsquo;s attack:5\nOK;Now I only have 70 hp;\nMy hp is still high now!\nThanks for your mercy!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 3 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:10\nOK;Now I only have 40 hp.\nIt\u0026rsquo;s really hurt\u0026hellip; But I\u0026rsquo;m still alive!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 4 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:15\nOK;Now I only have 5 hp;\nGood! I think I\u0026rsquo;m so lucky that I made it with such few hp!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 5 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:10\nOK;Now I only have\u0026hellip;No!!My hp come to the bottom! Oops!I DIED!\nYou only take 5 round(s) to defeat me!!\nCongratulation to your success! Goodbye!!\nfor : 循环计数器\r在C语言中，除了while循环和do-while循环，还存在第三种循环，即for循环；\n作为最早的循环，for循环结构简单，也更难被理解；\n以下就是一个使用for循环的例子(for.c)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; int main() { int atk; const int ATK10 = 10; int sumatk=0; int originalhp = 0; int hp = 0; int n = 0; int player = 0; printf(\u0026#34;There have 10 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\\ninput my hp:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); hp = originalhp; do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); printf(\u0026#34;I have %d hp now.\\n\u0026#34;,hp); sumatk = 0; for (player = 1; player \u0026lt;= 9; player++) { printf(\u0026#34;input player%d\u0026#39;s attack:\u0026#34;,player); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk ); for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } sumatk += atk; } sumatk += ATK10; hp -= sumatk; printf(\u0026#34;OK;You hurt me with the sum of %d attack in this round;\\nNow I only have\u0026#34;,sumatk); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34; %d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34; %d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34; %d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); } while (hp \u0026gt; 0); printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); return 0; } 如果把玩家人数提升到10位，使用for循环就会显得比while循环更加方便与简洁；\n1 2 3 4 5 6 7 8 9 10 11 12 for (player = 1; player \u0026lt;= 9; player++) { printf(\u0026#34;input player%d\u0026#39;s attack:\u0026#34;,player); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk ); while (atk\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } sumatk += atk; } for循环在形式上与其它判断语句类似，也是由小括号()和大括号{}组成；\n但不同的是，for循环的小括号里面有3条语句，中间用两个分号隔开；\n即:\n1 2 for(a;b;c) {d} 三条语句分别代表初始动作，循环继续的条件和每次循环结束做的动作；\n大括号里和其它循环相同，都用来做每次循环中做的动作；\n例如第一个for，它的流程如下： 1.初始化player的值为1；\n2.判定player的值是否大于10，若大于，则继续进行下面的步骤，反之直接结束循环；\n3.执行大括号内的代码；\n4.让player的值加1，以便输入下一名玩家的攻击；\n5.重复2-4步骤；\n为了理解方便，可将for翻译为“对于”； 这样，for循环的流程可以理解为：\n对于 一开始的player=1，如果player\u0026lt;10，就重复执行大括号里的内容，并让player的值加1，直到player\u0026gt;=10为止；\n（注意：循环结束时，player==11）\n用字母来表示就是：\n对于\nfor(a;b;c)\n{d}\n执行顺序为a b d c b d c b d c\u0026hellip;（直到b不满足为止）；\n此外，for循环小括号里的三条语句都可以省略，但是两个分号不可以省略； 如第二个for：\n1 2 3 4 5 6 for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } 就省略了第一条和第三条语句；\n同为循环，for和while稍加改动就可以等价互换；\n如第二个for：\n1 2 3 4 5 6 for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } 就和之前的\n1 2 3 4 5 6 while(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } 完全等价；\n值得一提的是，for语句在省略第一条和第三条语句的情况下，单词“for”完全可以被平替为单词“while”；\n在有三种循环时，用哪种循环最好呢？\n一般遵循以下原则：\n如果有固定次数，用for\n如果必须执行一次，用do_while\n如果必须先进行判断，用while\n这里展示一种测试时终端输出的样例：\nThere have 10 players that will attack me.\nWe have known player3\u0026rsquo;s attack is 10.\ninput my hp:-1\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of -1!!\nPlease input it again:5\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of 5!!\nPlease input it again:1000\nOK;\nRound 1 begin!\nI have 1000 hp now.\ninput player1\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!!\nPlease input it again:0\ninput player2\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!!\nPlease input it again:0\ninput player3\u0026rsquo;s attack:0\ninput player4\u0026rsquo;s attack:0\ninput player5\u0026rsquo;s attack:0\ninput player6\u0026rsquo;s attack:0\ninput player7\u0026rsquo;s attack:0\ninput player8\u0026rsquo;s attack:0\ninput player9\u0026rsquo;s attack:0\nOK;You hurt me with the sum of 10 attack in this round;\nNow I only have 990 hp;\nI guess you didn\u0026rsquo;t want to hurt me.\nthank you very much!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 2 begin!\nI have 990 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:10\ninput player3\u0026rsquo;s attack:10\ninput player4\u0026rsquo;s attack:10\ninput player5\u0026rsquo;s attack:10\ninput player6\u0026rsquo;s attack:10\ninput player7\u0026rsquo;s attack:10\ninput player8\u0026rsquo;s attack:10\ninput player9\u0026rsquo;s attack:10\nOK;You hurt me with the sum of 100 attack in this round;\nNow I only have 890 hp;\nMy hp is still high now!\nThanks for your mercy!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 3 begin!\nI have 890 hp now.\ninput player1\u0026rsquo;s attack:4\ninput player2\u0026rsquo;s attack:40\ninput player3\u0026rsquo;s attack:40\ninput player4\u0026rsquo;s attack:50\ninput player5\u0026rsquo;s attack:4\ninput player6\u0026rsquo;s attack:40\ninput player7\u0026rsquo;s attack:50\ninput player8\u0026rsquo;s attack:50\ninput player9\u0026rsquo;s attack:40\nOK;You hurt me with the sum of 328 attack in this round;\nNow I only have 562 hp.\nIt\u0026rsquo;s really hurt\u0026hellip; But I\u0026rsquo;m still alive!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 4 begin!\nI have 562 hp now.\ninput player1\u0026rsquo;s attack:60\ninput player2\u0026rsquo;s attack:60\ninput player3\u0026rsquo;s attack:60\ninput player4\u0026rsquo;s attack:60\ninput player5\u0026rsquo;s attack:60\ninput player6\u0026rsquo;s attack:60\ninput player7\u0026rsquo;s attack:60\ninput player8\u0026rsquo;s attack:60\ninput player9\u0026rsquo;s attack:20\nOK;You hurt me with the sum of 510 attack in this round;\nNow I only have 52 hp;\nGood! I think I\u0026rsquo;m so lucky that I made it with such few hp!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 5 begin!\nI have 52 hp now.\ninput player1\u0026rsquo;s attack:52\ninput player2\u0026rsquo;s attack:20\ninput player3\u0026rsquo;s attack:20\ninput player4\u0026rsquo;s attack:20\ninput player5\u0026rsquo;s attack:20\ninput player6\u0026rsquo;s attack:20\ninput player7\u0026rsquo;s attack:20\ninput player8\u0026rsquo;s attack:20\ninput player9\u0026rsquo;s attack:20\nOK;You hurt me with the sum of 222 attack in this round;\nNow I only have\u0026hellip;No!!My hp come to the bottom!\nOops!I DIED!\nYou only take 5 round(s) to defeat me!!\nCongratulation to your success! Goodbye!!\nbreak/continue : 循环控制\r循环在解决实际问题方面有很广泛的应用；\n然而，要想发挥其最大作用，必须引入控制循环的元素，即break和continue；\n此外，函数goto也可以控制循环， 但由于其权限太大，可以跳到代码任意位置，破坏了代码的逻辑，故在此不做介绍；\n简单来说，函数break可以跳出其所在循环；\n而函数continue可以无视其所在循环体中接下来的所有内容，直接进入下一轮循环；\n（对于for循环，仍会执行圆括号中的第三条语句）\n具体可以看下面的例子:(break.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; int atk3 = 0; int a, b, c; int solution = 0; const int hp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have still 3 players that will attack me.\\n\u0026#34;); printf(\u0026#34;What\u0026#39;s different is everyone can attck for 1 ~ 10 times;\\n\u0026#34;); printf(\u0026#34;But you can\u0026#39;t succeed unless my hp come to exactly 0;\\n\u0026#34;); printf(\u0026#34;Can you make it?\\n\u0026#34;); do { printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); while (atk1\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk1); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1); } printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); while (atk2\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk2); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2); } printf(\u0026#34;input player3\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk3 ); while (atk3\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk3); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk3); } for (a = 1; a \u0026lt;= 10; a++) { for (b = 1; b \u0026lt;= 10; b++) { for (c = 1; c \u0026lt;= 10; c++) { if (a * atk1 + b * atk2 + c * atk3 == hp) { solution = 1; break; } } if (solution == 1)break; } if (solution == 1)break; } if(solution == 0) printf(\u0026#34;Pity! The players tried for so long... But still can\u0026#39;t succeed!\\nTry it again!\\n\u0026#34;); } while (solution == 0); printf(\u0026#34;Congratulations!\\nPlayer1 attack for %d times, Player2 attack for %d times, Player3 attack for %d times can change my hp to exactly 0!\\nYOU WIN!!!\\n\u0026#34;, a, b, c); return 0; } 这里我们要根据三个玩家的攻击来判定是否能刚好战胜“我”；\n而每个人最多能攻击10次；\n因此我们采用穷举法，判定是否有解法符合条件；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for (a = 1; a \u0026lt;= 10; a++) { for (b = 1; b \u0026lt;= 10; b++) { for (c = 1; c \u0026lt;= 10; c++) { if (a * atk1 + b * atk2 + c * atk3 == hp) { solution = 1; break; } } if (solution == 1)break; } if (solution == 1)break; } 以上便是具体操作；\n使用嵌套for循环，用排列组合的方式一个个判定结果是否符合；\n一旦遇到符合的情况，就让solution=1，说明可以过关；\n之后，便用break结束循环；\n但要注意的是，函数break只能跳出其所在循环，而上面共有3个循环；\n因此，在剩下两个循环下面设置了两个 if (solution == 1)break 语句；\n表明如果找到解法就一次性结束3个循环；\n这样，3个break接力完成了对循环的控制；\n附：输入样例和输出结果：\n输入样例1：\n3\n5\n7\n输出结果1：\nCongratulations!\nPlayer1 attack for 2 times, Player2 attack for 9 times, Player3 attack for 7 times can change my hp to exactly 0!\nYOU WIN!!!\n输入样例2：\n3\n6\n9\n输出结果2：\nPity! The players tried for so long\u0026hellip; But still can\u0026rsquo;t succeed!\nTry it again!\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/04.choice-circle/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/04.choice-circle/","title":"C/C++基础-04.条件与循环"},{"content":"函数\r在此之前，我们已经知道了printf、scanf、if、while、for等函数；\n然而，这些函数的定义是库函数里面本来就有的；\n如果要创造一个自己定义的函数，该怎么做呢？\n具体看下面的例子：(function.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #include \u0026lt;stdio.h\u0026gt; int sumatk(int hp);//函数声明 void judge(int hp, int originalhp); //函数声明，void表示无返回值 int main() { int originalhp,hp,n=0; const int ATK10 = 10; printf(\u0026#34;There have 10 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\\ninput my hp:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;I have %d hp now.\\n\u0026#34;,originalhp); hp = originalhp; do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); int sum = sumatk(hp)+ATK10; //调用sumatk函数，返回的值再参与到sum的计算中； hp -= sum; printf(\u0026#34;OK;You hurt me with the sum of %d attack in this round;\\nNow I only have\u0026#34;,sumatk); judge(hp, originalhp); //调用judge函数，根据两个变量打印结果，不返回值； n++; if (hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); } while (hp \u0026gt; 0); printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); return 0; } //sumatk函数的定义，其中sunatk里面的hp、player等变量一旦离开作用域，内存即被释放，变量不复存在； int sumatk(int hp) { int sumatk=0, player, atk; for (player = 1; player \u0026lt;= 9; player++) { printf(\u0026#34;input player%d\u0026#39;s attack:\u0026#34;,player); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk ); for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } sumatk += atk; } return sumatk; } //judge函数的定义 void judge(int hp, int originalhp) { int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34; %d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34; %d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34; %d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); } //可以无return语句或加上无返回值的 (return;) 语句 函数一般由声明，定义组成；\n声明要讲出函数的返回类型和输入类型，必须写在主程序前，格式如下：\n返回类型 函数名(输入类型若干)\n其中返回类型与变量类型相似，可以填int、double等；\n那么在函数的最后，就要使用return语句返回一个值给主程序，它的类型就是返回类型；\n但有一种返回类型例外，它就是void，它代表“没有”，用void做返回类型不需要return语句返回值；\n但是也可以使用不加返回值的return;来结束函数运行；\n注意：任何函数最多只能返回1个值，因为函数的自变量只能有唯一的因变量对应；\n输入类型指主程序向函数传递的若干值，与定义变量类似； 输入类型仍然可以是void，这时主程序无需向函数输入任何值；\n如 void judge(int hp, int originalhp)\n就是声明一个函数名为judge的函数，主程序将向其传递2个值，它们将会依次定义给变量hp和originalhp，最终不返回任何值；\n声明最后要加上分号；\n函数的定义则是指在函数内部利用输入的变量进行的一系列代码；\n其第一行必须是函数的声明，因此可以将函数的定义和声明写在一起；\n但一般不这么做，因为把定义放在后面显得代码更加模块化；\n之后用大括号括起要执行的代码，构成定义；\n注意：函数禁止嵌套定义，会出现非常严重的错误；\n但允许嵌套调用，甚至自己调用自己，我们称之为递归；\n函数与main函数以及函数与函数之间是完全不相干的，它们只以互相输入的值来联系 (指值传递的函数，地址传递不算) ；\n这就是说，你可以在主程序和函数中定义两个完全相同的变量，但它们是互不影响的；\n函数中的变量有自己的起作用范围，就是在大括号里面，我们管它叫作用域；\n一旦离开了作用域，变量就会不复存在，直到下一次调用该函数时才会出现；\n在调用函数时，无需输入函数类型，只要输入函数名，后面跟小括号输入要传递的若干个值即可；\n值得注意的是，main也是函数；\n因为计算机内部的一些计算，main函数也要返回值，所以int main返回0；\n如果函数发生了非零返回，很可能是出现了错误，故 return 0; 是代码正常运行的重要标志；\n在小括号里面，本可以放进去void，然而由于种种原因，还是不加为好；\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/05.function/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/05.function/","title":"C/C++基础-05.函数"},{"content":"同类型变量容器：数组\r有一个东西，它和变量非常相似，但相比于变量只能储存值，它却能储存多个变量，它就是数组；\n数组可以看成很多个变量；其中的变量必须具有相同的类型；\n定义一个数组和定义一个变量类似，区别是数组需要加上方括号[]，里面写上数组的大小；\n如 int a[3]；\n数组的大小代表了它能存放变量的个数；\n但要注意的是，数组的下标却是从0开始，因此数组a[3]实际上只有:\na[0] a[1] a[2];\n这样是为了编译器的方便；\n数组需要初始化； 可以通过赋值大括号里面的数的方式来初始化；\n如 int a[3] = {0,1,2}\n这样 a[0]=0 a[1]=1 a[2]=2；\n需要注意的是，当输入的值不足的时候，剩下的值都将默认为0；\n但是必须要输入第一个值,否则所有的数都是乱码；\n除此之外，在初始化的情况下，定义可以省略大小，此时的大小就是输入的数字个数；\n这种方法又叫做集成初始化；\n除此之外，还可以“精准”初始化，只需要用**[n]**在初始化数据中给出定位；\n在初始化后，就可以往数组内部赋值以存储多个数据；\n具体可以看下面的例子：(array.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; int main() { int atk[9] = { 0 }; int sumatk = 0, n = 0, originalhp, hp, player; const int ATK10 = 10; printf(\u0026#34;There have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\\ninput my hp:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); hp = originalhp; do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); sumatk = 0; for (player = 0; player \u0026lt; 9; player++) { printf(\u0026#34;input player%d\u0026#39;s attack:\u0026#34;, player+1); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk[player]); while (atk[player] \u0026lt; 0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now player %d\u0026#39;s attack %d is too ABNORMAL!\\n\u0026#34;,player+1 ,atk[player]); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk[player]); } } printf(\u0026#34;The 9 attacks you input are:\u0026#34;); for (player = 0; player \u0026lt; 9; player++) { printf(\u0026#34;%d\\t\u0026#34;, atk[player]); sumatk += atk[player]; } printf(\u0026#34;Then adds player 10\u0026#39;s attack;\\n\u0026#34;); sumatk += ATK10; hp -= sumatk; printf(\u0026#34;OK;You hurt me with the sum of %d attack in this round;\\nNow I only have\u0026#34;, sumatk); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34; %d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34; %d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34; %d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); } while (hp \u0026gt; 0); printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); return 0; } 1 2 3 4 5 6 7 8 9 10 11 for (player = 0; player \u0026lt; 9; player++) { printf(\u0026#34;请输入玩家%d的攻击:\u0026#34;, player+1); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk[player]); while (atk[player] \u0026lt; 0) { printf(\u0026#34;我知道你不想攻击我，但也别把玩家%d的攻击设置成“%d”啊！\\n\u0026#34;,player+1 ,atk[player]); printf(\u0026#34;这可是个负数！我不接受治疗！请重新输入：\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk[player]); } } 以上就是用for循环来给数组依次赋值的例子，需要注意player要从0开始；\n用for循环对数组处理又称为遍历数组；\nsizeof和数组\rsizeof可以给出整个数组所占据的内容的大小，单位是字节；\n因此，用sizeof(a)/sizeof(a[0])就能得到数组的大小，不随数组数据的增减而变化；\n高维数组\r就像一维空间可以拓展到二维三维一样，数组也可以拓展维数；\n因此，就有了二维，三维乃至n维数组；\n以二维数组为例：\n二维数组定义需要加上两个方括号，分别代表行、列；\n若要集成初始化，只能省略第一个方括号里的内容；\n初始化时，除了一整个大括号，每一行要加上一层大括号；\n如 int a[3][3]=\n{\n{1,1}\n{1}\n}\n初始化后，a[0][0]=1;a[1][0]=1;a[0][1]=1;其余6个数都是0；\n至于更高维度数组，以此类推就行了，只不过比较抽象；\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/06.array/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/06.array/","title":"C/C++基础-06.数组"},{"content":"指针\r前言\r根据学习经验，指针是C语言最困难的地方；\n其原因不仅在于需要理解地址、访问等计算机底层概念，更为抽象；\n而且指针仅在C语言和C++语言中存在，没有其它语言作为基础；\n但是指针的用处十分广泛，内存分配、文件操作等都离不开指针；\n并且学习指针还能对计算机系统有一定的认识；\n故曰：学习指针是掌握C语言过程中必不可少的步骤；\n地址: 数据存放点\r地址代表一个变量存放的位置；\n运算符 \u0026amp; 可以用于获取变量的地址，但是它必须针对一个变量操作；\n地址一般使用十六进制表示；\n因此scanf函数运作的真正原理是将输入的数据存入指定的地址中；\n而不是直接赋值；\n除此之外，我们还可以使用 %p 来获取一个变量的地址；\n例如下面的程序可以看到变量 i 的地址；(address.c)\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 114; printf(\u0026#34;\u0026amp;i=%X\\n\u0026#34;, \u0026amp;i); printf(\u0026#34;\u0026amp;i=%p\\n\u0026#34;, \u0026amp;i); //仍需输入\u0026amp;； return 0; } 输出结果如下：\n\u0026amp;i=12FF8D0\n\u0026amp;i=012FF8D0\n可以看到，虽然上下两行代码几乎相同，但是上下两个结果并不相同； 其中下面的地址多了一位；\n除此之外，编译器可能还会有一个警告，叫做：\n“printf”: 格式字符串“%X”需要类型“unsigned int”的参数，但可变参数 1 拥有了类型“int *”\n这是因为编译器的架构不同；\n%X输出的是整型 int ，而%p输出的是地址的专属变量类型 int*； 因此要获取一个变量的地址最好还是使用%p；\n指针：快捷访问\r指针取地址\r前面谈到了 int* ；这就是指针类型的变量；\n指针变量也是储存值的，只不过存的是存放具体值的变量的地址；\n用 int *p = \u0026amp;i;\np就可以储存具有实际值的变量i的地址；\n换句话说，p指向了i（ p-\u0026gt;i ）；\n需要注意的是，int *p = \u0026amp;i中，\u0026amp;不可以省略，因为你要赋地址给指针；\n而int *p = i，给指针 p 传递的是 i 的值；编译器会直接报错；\n我们将i的地址赋给了指针p；在输出指针p指向的i的地址时，与\u0026amp;i完全一致；\nNULL: 空地址\r除此之外，我们还可以用NULL来表示一个没有指向任何地址的空指针；\n当我们试图找到它的地址时，你就会发现它是0或者是null；\n在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。\n注意：如果没有给指针赋值，会发生严重的编译错误!!\nvoid* : 迷失的指针\r指针如变量一样有许多类型；但还有额外的类型，就是 void* 类型；\n它表示该指针所指的变量类型未知；\n由于变量类型未知，所以无法通过取值运算符访问指针所指的变量数值； 但变量本身类型没有变化；\nvoid* 类型所占的字节数也为1；\n目前暂时没想到它有什么用。\n对地址取值\r前面提到运算符 \u0026amp; 可以访问变量所在的地址；\n那么反过来，我们有运算符 * ，可以找到地址所在的变量的值；\n具体看下面的例子：(pointer.c)\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main() { int i = 114; int *p = \u0026amp;i; int *q = NULL; printf(\u0026#34;p=%p\\n\u0026#34;,p); printf(\u0026#34;q=%p\\n\u0026#34;,q); printf(\u0026#34;i=%d\\n\u0026#34;,i); printf(\u0026#34;*p=%d\\n\u0026#34;,*p); return 0; } 输出结果：\np=001BFD70\nq=00000000\ni=114\n*p=114\n*p 找到了指针p储存的地址指向的变量i，因此输出i的值，上下两行结果完全一致；\n可以理解为：*先访问到了p的地址指向的是变量 i ，之后 p 再将 i 拿来运算；\n由此可见，运算符和\u0026amp;作用相反，互为逆运算符；\n优先级 运算符 运算 结合关系 举例 2 取值 * 自右向左 *p（p为指针） 2 取地址 \u0026amp; 自右向左 \u0026amp;i（i为变量） 指针之力： 跨函数使用\r事实上，在大部分情况下， *p 可以看作 i；\u0026amp;i 可以看作 p ;\n那要这两个运算符和指针有啥用额？\n答案就是：跃过函数赋值！ 我们知道，函数与main之间，只能用值连接，二者其中的变量毫不相干；\n但有了指针，一切就改变了，因为地址只有一个，函数形参和实参的地址是相同的！\n如下面的例子：(pointerInFunction.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; void changeInFunction(int *p) { *p=514; } int main() { int i=114; int *p=\u0026amp;i; printf(\u0026#34;former: i=%d\\n\u0026#34;,i); changeInFunction(p); printf(\u0026#34;after: i=%d\\n\u0026#34;,i); return 0; } 输出：\nformer: i=114;\nafter: i=514;\n尽管位于不同的函数，但i的地址是唯一的；\n而指针p指向的又是同一个地址；\n因此相当于p直接访问到了 main 中的 i，并“隔空”进行了替换；\n在函数的最后，指针p作为形参同样被抹去了；\n但地址里的变量i已经被修改了； 因此前面i的值还是114，后面就变成514了；\n指针与数组\r数组 -\u0026gt; 指针\r告诉你们，数组就是特殊的指针！！\n已知运算符 * 可以访问指针指向的变量的值；\n同理， * 也可以访问数组“指向”的变量，即数组储存的第一个变量a[0]；\n自然，数组也可以有“跃过函数赋值”的操作；\n除此之外，用数组定义指针时不用加\u0026amp; ；\n因为不加[]的数组标识符就是特殊的指针；\n如下面的例子：(pointerAndArray.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; void changeInFunction(int a[]) { *a+=1; a[1]+=1; a[2]+=1; } int main() { int a[]={1, 2, 3}; int *p=a;\t// *p=\u0026amp;a[0]; printf(\u0026#34;a[0]=%d; *a=%d;\\n\u0026#34;,a[0],*a); printf(\u0026#34;p[0]=%d; p[1]=%d; p[2]=%d;\\n\u0026#34;,p[0],p[1],p[2]); printf(\u0026#34;a[0]=%d; a[1]=%d; a[2]=%d; (former)\\n\u0026#34;,a[0],a[1],a[2]); changeInFunction(a); printf(\u0026#34;a[0]=%d; a[1]=%d; a[2]=%d; (after)\\n\u0026#34;,a[0],a[1],a[2]); return 0; } 输出结果：\na[0]=1; *a=1;\np[0]=1; p[1]=2; p[2]=3;\na[0]=1; a[1]=2; a[2]=3; (former)\na[0]=2; a[1]=3; a[2]=4; (after)\n可以看到 a[0] 和 *a 的值完全一致，都是1；\n类比于指针，我们可以解释为 * 访问了 a “指向”的变量，正好它就是a作为数组时储存的变量a[0]；\n在函数changeInFunction中，无论是 *a 还是 a[1] a[2] 都能成功地对数组a的值进行改动； 因此，b[1] b[2] 也是取值运算符；它们也是直接访问到 b[1] b[2] 指向的变量的地址，并“隔空”修改变量的值；\n指针 -\u0026gt; 数组\r以此类推，在某些情况下，指针也可以当作数组，使用[ ]；\n还是上面的例子。\np[0]=1; p[1]=2; p[2]=3;\na[0]=1; a[1]=2; a[2]=3;\n可以看到 p[0],p[1],p[2] 的值和 a[0],a[1],a[2] 的值完全一致；\n可以解释为p[0]作为1个变量“储存”了1个值，\n而这个值就是 p 作为指针时访问到的变量 i 的值；\n对于数组而言,数组储存的变量的地址都是连续的；\n这也就意味着指针也有机会以数组访问的方式访问自己以外的数组变量；\n也就是说，可以出现p[-1]这样的东西 (只要地址前面有变量)；\n数组 VS 指针\r数组与指针的不同之处，在于数组指向的地址不可以被改变；\n比如，你不能进行a++来试图改变数组a指向的地址，它永远是\u0026amp;a[0]；\n这一点和常数const int 很像：一旦被定义，就不能再被改变；\n实际上，int a[ ] 实际上等价于 int * const a ；代表指针a是常量； 数组就是指向的地址不能被改变的常量指针！\n除此之外，需要区分的是，还有另一种常量指针，就是 const int *a；\n它的意思是 *a是常量；\n也就无法通过*a或a[0]这些方式来改变它所指的变量的值；\n但它指向的地址可以被改变，即 a++是可行的；\n这两种常量指针的区别在于 *a 是常量还是 a 是常量；\n例如，int const *a；就是 *a 是常量，与第二种常量指针一致；\n当数组被定义成常量时，（ const int a[] ） 此时数组储存的每一个变量都是常量，同时所指的地址也不能被修改； 等价于 const int * const a；\n指针的好处在于可以跃过函数；但它的坏处也在于此：无需限制就把你外面的变量修改了；\n因此，就可以在函数里面使用常量指针（或数组）；\n一旦你用取值运算符做了修改，编译器就会报错,\n相当于在运行前就发现了错误；\n这样就可以保护指针类型的变量不会改变外面的值；\nn重指针\r除此之外，还有指针数组和指向指针的指针；\n理论上可以用指针数组来表示字符串数组，\n但是感觉没有二维数组那么方便；\n指针运算\r指针也可以用于运算，可以对一个指针进行加减常数；\n运算后的结果就是指针所指的地址加或减了一个数字；\n注意：加减的数字必须是指针字节内存的倍数！\n或者是自增自减，结果是向前移动一个字节（4bit）内存大小；\n除此之外，两个指针之间也可以相减；\n得到的是指针之间的字节数减一，再除以变量的字节长度；\n如以下的程序：(calculateInPointer.c)\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main() { int a[6]={0}; int *p=\u0026amp;a[0]; int *q=\u0026amp;a[6]; printf(\u0026#34;q-p=%d\\n\u0026#34;,q-p); return 0; } 由于a[0]和a[6]之间有28个字节；\n所以减一后除以4 sizeof(int)，最后输出6；（6-0=6）\n另外，两个指针之间也可以做比较，依据是它们的地址；\n主要包括以下两种：\n相等性比较 (== 和 !=)\n关系比较 (\u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=)\n动态内存分配\r借空间\r在实际情况中，有时我们事先不知道数组的内存，或者数组的内存要循环使用；\n由于定义数组长度时必须使用常数，而数组长度又不可变，\n因此分配内存时极易造成数组越界或者空间浪费、内存溢出；\n这时，我们就需要使用malloc函数，来进行动态内存分配；\n所谓动态内存分配，就是内存可以随时分配和释放；\n不过在使用malloc系列的函数时，我们要先加入如下头文件：\n#include \u0026lt;stdlib.h\u0026gt;\nmalloc函数的使用方法是在malloc函数中用小括号输入一个数字，这个数字就是指针的内存大小（单位：字节）\n注意：指针返回的就是 void 类型的指针，所以还需要用强制转换运算符来把malloc得到的内存返回；\n然后就可以把指针当作大小确定的数组使用了；\n还空间\rmalloc函数是从系统内存中借来的连续空间，不是自己地址的空间；\n所以，使用完数组之后，还得还给系统；\n这时就需要使用free函数；\n如下面的例子：(malloc.c)\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int i=0; int *a=\u0026amp;i; a=(int*) malloc(4*sizeof(int)); free(a); return 0; } 当你没有使用free函数时，占用的内存就会积累下来，直到程序结束再释放；\n如果你非常不幸地把内存用完了，malloc找不到新的内存了，就会返回0地址；\n而若返回了0地址，程序立即结束；\n值得一提的是，free函数只能释放申请来的地址，而地址不能有任何变化； 这也就是说，a++后就不能再使用free函数；\n引用：变量的别名\r在C++中还有一种与指针类似的变量，名叫引用；\n引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。\n一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。\n引用变量的定义方式为加上\u0026amp;；\n即 int \u0026amp;r = i；\n具体可以看下面的例子：(reference.cpp)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int i; double d; int \u0026amp;r = i; double \u0026amp;s = d; i = 5; cout \u0026lt;\u0026lt; \u0026#34;Value of i : \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of i reference : \u0026#34; \u0026lt;\u0026lt; r \u0026lt;\u0026lt; endl; d = 11.7; cout \u0026lt;\u0026lt; \u0026#34;Value of d : \u0026#34; \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Value of d reference : \u0026#34; \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } 运行输出：\nValue of i : 5\nValue of i reference : 5\nValue of d : 11.7\nValue of d reference : 11.7\n在这里我们能体会到，引用其实就是变量的另一个名字；\n引用 VS 指针\r引用很容易与指针混淆，它们之间有三个主要的不同：\n引用必须在创建时被初始化。\n指针没有此限定； 1 2 int \u0026amp;r; //错误 int *p; //正确 不存在空引用。引用必须连接到一块合法的内存。\n而指针可以指向空地址NULL；\n一旦引用被初始化为一个对象，就不能被指向到另一个对象。\n而指针可以在任何时候指向到另一个对象。（除非是const指针）\n1 2 3 4 int \u0026amp;r = i; r=j; //错误 int *p = \u0026amp;i; *p = j; //正确 引用和函数\r引用和指针一样都可以作为函数形参；\n但不同的是，引用不仅可以作为函数参数引进，还可以作为返回值输出,\n但是指针不能作为左值被赋值； 此时，函数类型为 int\u0026amp; ;\n如下面的例子：(referenceInFunction.cpp)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; using namespace std; int num[5]={1, 2, 3, 4, 5}; // 设置全局变量 int\u0026amp; changeInFunction(int i) { int \u0026amp;a=num[i]; return a; } int main() { cout \u0026lt;\u0026lt; \u0026#34;former:\u0026#34; \u0026lt;\u0026lt; endl; for ( int i = 0; i \u0026lt; 5; i++ ) { cout \u0026lt;\u0026lt; \u0026#34;num[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34;; cout \u0026lt;\u0026lt; num[i] \u0026lt;\u0026lt; endl; } changeInFunction(0)=114; changeInFunction(2)=514; cout \u0026lt;\u0026lt; \u0026#34;after:\u0026#34; \u0026lt;\u0026lt; endl; for ( int i = 0; i \u0026lt; 5; i++ ) { cout \u0026lt;\u0026lt; \u0026#34;num[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;] = \u0026#34;; cout \u0026lt;\u0026lt; num[i] \u0026lt;\u0026lt; endl; } return 0; } 输出结果：\nformer:\nnum[0] = 1\nnum[1] = 2\nnum[2] = 3\nnum[3] = 4\nnum[4] = 5\nafter:\nnum[0] = 114\nnum[1] = 2\nnum[2] = 514\nnum[3] = 4\nnum[4] = 5\n可以看到，返回引用的函数能正常运行，但是返回指针的函数（上面的注释）却不行；\n比如，把上面函数 changeInFunction 的定义改成：\n1 2 int *p=\u0026amp;num[i]; return p; 则会发生错误；\n究其原因，是因为当函数返回一个引用时，则返回一个指向返回值的隐式指针。\n这样，函数就可以放在赋值语句的左边。\n但引用也有它的不足之处，就是不能返回局部变量的引用； 编译时会出现警告，运行时会出现段错误（Segmentation fault）；\n比如，设计下面一个函数：\n1 2 3 4 5 int\u0026amp; Function() { int i=666; return i; } 上述代码是执行不了的；但是如果把函数里面的i改成全局变量，就没问题；\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/07.ptr-ref/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/07.ptr-ref/","title":"C/C++基础-07.指针和引用"},{"content":"C风格字符串\rC风格字符串即字符数组char[]，但是在最后有空字符\u0026rsquo;\\0\u0026rsquo;;\n由于在数组的末尾存储了空字符，所以字符数组的大小比字符串的字符数多一个。\n字符串除了像数组一样定义，还可以用双引号字符串定义。\n下面是两种定义方式：\nchar site[6] = {\u0026lsquo;H\u0026rsquo;, \u0026lsquo;E\u0026rsquo;, \u0026lsquo;L\u0026rsquo;, \u0026lsquo;L\u0026rsquo;, \u0026lsquo;O\u0026rsquo; \u0026lsquo;\\0\u0026rsquo;}; char site[] = \u0026ldquo;HELLO\u0026rdquo;;\n注意到，双引号定义的字符串无需加上后置的空字符，因为它本身就是字符串，而不是相互独立的字符数组；\n有大量的函数用来操作字符串； (需要头文件\u0026lt;string.h\u0026gt;或\u0026lt; string\u0026gt;)\n具体有以下几个：\nstrcpy(s1, s2)：复制 复制字符串 s2 到字符串 s1。 strcat(s1, s2)：连接\n连接字符串 s2 到字符串 s1 的末尾。 strlen(s1)： 长度\n返回字符串 s1 的长度。 strcmp(s1, s2)：比较\n如果 s1 和 s2 是相同的，则返回 0；如果 s1\u0026lt;s2 则返回值小于 0； 如果 s1\u0026gt;s2 则返回值大于 0。 这里比较的是字符串中第一个字符的ASCII编码，而非整个字符串。\n若不相等，返回的是两个字符的编码差值；\nstrchr(s1, ch)：查找字符\n返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。\nstrstr(s1, s2)：查找字符串 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。\n以下是一些字符串函数的实例：(string.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int main() { //用字符串初始化字符数组 char str1[13]=\u0026#34;hello\u0026#34;; //等价于 char str1[13]={\u0026#39;h\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;.\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;\\0\u0026#39;}; char str2[13]=\u0026#34;world\u0026#34;; char str3[13]={0}; int len;//定义整型变量以记录字符串长度 //将str1复制到str3 strcpy(str3,str1); printf(\u0026#34;strcpy(str3,str1): %s\\n\u0026#34;,str3); //将str2连接到str1后面 strcat(str1,str2); printf(\u0026#34;strcat(str1,str2): %s\\n\u0026#34;,str1); //输出连接后的str1字符串长度 len=strlen(str1); printf(\u0026#34;strlen(str1): %d\\n\u0026#34;,len); return 0; } 输出结果：\nstrcpy(str3,str1): hello\nstrcat(str1,str2): helloworld\nstrlen(str1): 10\nC++风格的字符串\r学了C++以后；字符串可以用两种形式表示；即：\nC 风格字符串 C++ 引入的 类 string ；\n如你所见，C++风格的字符串是一个类；\n它保存在命名空间std里面；里面包含许多成员函数和运算符重载操作；\n可以代替部分string头文件里面的函数；\nstring类型的字符串兼容C风格的字符串功能，而且不需要初始化字符串的长度，同时还可以做赋值和四则运算 (重载 + - =)\n这是C风格的字符串所做不到的；\n接下来让我们用C++风格的字符串来改写一下上面的代码，看一看它的简便之处；(string.c -\u0026gt; string++.cpp)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { //使用类string来定义字符串变量 string str1=\u0026#34;hello\u0026#34;; string str2=\u0026#34;world\u0026#34;; string str3={0}; int len; //在类的内部进行了运算符的重载，可以直接使用 = 来进行 strcpy() str3=str1; cout\u0026lt;\u0026lt;\u0026#34;str3: \u0026#34;\u0026lt;\u0026lt;str3\u0026lt;\u0026lt;endl; //用 + 进行 strcat() \u0026#34;+=也可以接受哦\u0026#34; str1+=str2; cout\u0026lt;\u0026lt;\u0026#34;str1+str2= \u0026#34;\u0026lt;\u0026lt;str1\u0026lt;\u0026lt;endl; //使用string类里面的成员函数length来提取长度; len=str1.length(); cout\u0026lt;\u0026lt;\u0026#34;the length of str1: \u0026#34;\u0026lt;\u0026lt;len\u0026lt;\u0026lt;endl; return 0; } ","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/08.string/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/08.string/","title":"C/C++基础-08.字符串"},{"content":"结构体\r自定义类型：结构体\r在C语言中，有两大基本的数据结构；\n一个是数组，支持存储多个相同类型的变量；\n那么，另外一个就是存储不同类型的变量的数据结构，它叫结构体。\n结构体struct由于能够存储不同类型的变量，因此形式多样，可以满足用户需要的自定义类型；\n定义\r定义一个结构体变量需要使用struct语句。struct 语句的格式如下：\n1 2 3 4 5 6 7 struct type_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3; . . } object_names; type_name 是结构体类型的名称，\nmember_type1 member_name1 是标准的变量定义，\n比如 int i ; 或者 float f ; 或者其他有效的变量定义。\n在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。\n具体可以看下面的例子：\n1 2 3 4 5 6 7 struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } book1; 在这个结构体里面，我们把类型名称定义为了Books；\n里面存储了字符串变量标题、作者、类目以及int变量ID；\n并顺带着指定了一个变量book1；\n等价于在main函数里面输入struct Books book1；\n在定义结构体变量时，最好将其设置为全局变量，以便我们在整个程序中都能访问；\n在定义了结构体类型之后，就可以在main函数中使用struct+结构体类型+结构体变量名称来定义结构体变量了；\n如： struct Books book2\n此外，我们还可以使用typedef指令来进一步简化结构体类型的调用；\n只需要使用以下一行命令：\ntypedef struct Books Books;\n之后，就能省略结构体定义中的struct了；\n初始化\r现在我们已经定义了结构体类型以及结构体变量；\n那么，如何对结构体内部的若干变量进行初始化呢？\n在数组里面，我们可以使用[]来依次访问数组内部的各个变量；\n同理，在结构体里面，我们也有新的运算符 . (小数点) 来进行结构体成员访问；\n实际上，我们也有另一种方式来初始化一个结构体变量； 就是像数组一样，在定义的时候就用大括号来初始化；不过仅限于定义的时候，之后还是要用运算符来访问；\n如 Books book2= { \u0026ldquo;CSS\u0026rdquo; , \u0026ldquo;Runoob\u0026rdquo; , \u0026ldquo;front\u0026rdquo; , 12346 };\n如下面的例子：(struct.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct Books //定义结构体类型Books { char title[50]; char author[50]; char subject[100]; int book_id; } book1; typedef struct Books Books;//简化结构体变量调用 int main() { Books book2; // Book1 详述 strcpy( book1.title, \u0026#34;C++\u0026#34;); strcpy( book1.author, \u0026#34;Runoob\u0026#34;); strcpy( book1.subject, \u0026#34;program\u0026#34;); book1.book_id = 12345; // Book2 详述 strcpy( book2.title, \u0026#34;CSS\u0026#34;); strcpy( book2.author, \u0026#34;Runoob\u0026#34;); strcpy( book2.subject, \u0026#34;front\u0026#34;); book2.book_id = 12346; // 输出 Book1 信息 printf(\u0026#34;1.title :%s\\n\u0026#34;,book1.title); //使用小数点提取出结构体变量里面的单个变量进行操作。 printf(\u0026#34;1.author :%s\\n\u0026#34;,book1.author); printf(\u0026#34;1.subject :%s\\n\u0026#34;,book1.subject); printf(\u0026#34;1.ID :%d\\n\u0026#34;,book1.book_id); // 输出 Book2 信息 printf(\u0026#34;2.title :%s\\n\u0026#34;,book2.title); printf(\u0026#34;2.author :%s\\n\u0026#34;,book2.author); printf(\u0026#34;2.subject :%s\\n\u0026#34;,book2.subject); printf(\u0026#34;2.ID :%d\\n\u0026#34;,book2.book_id); return 0; } 输出结果：\n1.title :C++\n1.author :Runoob\n1.subject :program\n1.ID :12345\n2.title :CSS\n2.author :Runoob\n2.subject :front\n2.ID :12346\n可以看到,使用小数点可以提取出结构体变量里面的单个变量进行操作。\n事实上， . 也是一个运算符，名字叫做成员访问运算符;\n它的优先级是极高的 ( 1 ) ，甚至和括号一样；\n优先级 运算符 运算 结合关系 举例 1 . 成员访问 从右向左 book1.title 结构体与其它数据类型\r结构体与数组\r有没有试过把两种常见的数据结构结合起来？\n在结构体里面存储数组，这是很常见的；\n比如书的名称里面就包含了字符数组；\n在数组里面存储结构体，其实也简单，就把数组当成一个能储存不同变量的二维数组就行了；\n结构体与自己\r在结构体里面嵌套结构体，也是常规操作，当引用最底层的结构体成员时，需要使用多个成员调用运算符；\n结构体与指针\r有没有试过把指针掺和进结构体里面？难点\n我们可以让指针指向结构体，这时它的地址是结构体最开始的地方；\n要通过指针引用结构体里的成员，除了用取值运算符 * 以及成员调用运算符 . 之外，\n还可以使用特有运算符：成员引用运算符 -\u0026gt;\n(这东西看起来就像一个指针)\n优先级 运算符 运算 结合关系 举例 1 -\u0026gt; 成员引用 从左向右 p-\u0026gt;title 可以看到，-\u0026gt;的优先级也是相当高的；\n-\u0026gt;可以用于结构体数组，只需要把它当成一般数组就行；\n结构体里面可以存储指针变量。这个不在多说；\n结构体与函数\r有没有试过把函数掺和进结构体里面？\n现阶段(指C语言)，我们还无法在结构体里面存储函数；\n不过等到升级为C++了就可以了； 只讲在函数里面调用和返回结构体的情形；\n函数调用结构体：参数列表里面写上结构体变量的定义即可；\n在主函数里面输入变量时不需要加上前缀，就像数组不需要加上[] ;\n函数返回结构体：函数类型为结构体类型，return时不需要加上struct，就像数组不需要加上[] ;\n调用或返回结构体指针也是可行的。可以在不返回值的情况下访问或修改结构体成员；\n好了，说了这么多，来看一个实例，用指针和函数改写之前的代码；\n( struct.c -\u0026gt; struct++.c )\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } book1; typedef struct Books Books; void printBook( Books *book ) //调用结构体指针的打印函数，用来输出书的标题、作者、类目、ID { printf(\u0026#34;title :%s\\n\u0026#34;,book-\u0026gt;title); printf(\u0026#34;author :%s\\n\u0026#34;,book-\u0026gt;author); printf(\u0026#34;subject :%s\\n\u0026#34;,book-\u0026gt;subject); printf(\u0026#34;ID :%d\\n\u0026#34;,book-\u0026gt;book_id); //由于传进来的是指针，所以用运算符 -\u0026gt; 。若传进来的是结构体而不是指针，则使用运算符 . } int main() { Books book2; // Book1 详述 strcpy( book1.title, \u0026#34;C++\u0026#34;); strcpy( book1.author, \u0026#34;Runoob\u0026#34;); strcpy( book1.subject, \u0026#34;program\u0026#34;); book1.book_id = 12345; // Book2 详述 strcpy( book2.title, \u0026#34;CSS\u0026#34;); strcpy( book2.author, \u0026#34;Runoob\u0026#34;); strcpy( book2.subject, \u0026#34;front\u0026#34;); book2.book_id = 12346; printBook(\u0026amp;book1);//把book1地址传给结构体指针，令其输出数据 printBook(\u0026amp;book2);//把book2地址传给结构体指针，令其输出数据 return 0; } 输出结果：\ntitle :C++\nauthor :Runoob\nsubject :program\nID :12345\ntitle :CSS\nauthor :Runoob\nsubject :front\nID :12346\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/09.struct/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/09.struct/","title":"C/C++基础-09.结构体"},{"content":"动态数据结构：链表\r到目前为止，我们接触到的数据结构还只有2种：数组和结构体；\n如果只需要储存同一种数据类型，那么数组无疑是最合适的选择；\n但是，数组也有它的缺陷：大小固定，增减元素困难；\n同时，即使你数组还有空位，要在数组里面插入一个元素，也不得不移动数组里面的大量元素，效率极低；\n因此，我们需要一种新的数据结构，它应该具有以下优点：\n大小不固定，甚至不需要在定义时确定大小； 插入元素方便，无需挪动整个结构； 这个新的数据结构就是链表；\n链表是一种大小可变，通过节点存储数据，通过指针实现连接的数据结构；可以看成一根线串着若干个节点；\n当它插入和删除元素时，只需要修改相邻2个元素的连接关系就可以了，无需移动任何其它东西；\n节点以结构体的形式呈现，结构体里面存放着一个节点数据和指向下一个（也可能是上一个）的1个或2个指针；一般形式如下：\n1 2 3 4 5 typedef struct tagNODE { int data; struct tagNODE *link; } node; 这时通过对指针link取值可以访问到它连接的另一个节点数据；\n由于链表可以存放1~2个指针，因此也有单链表和双链表之分；\n通常链表里面还包含一个头节点L，它作为链表访问的入口，不储存数据，只有1~2个指针值；\n单链表\r单链表差不多就是上面这种形式：\n1 2 3 4 5 typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; 其中node是节点的结构体数据类型，通过node可以知道任意节点占用的内存；\n而*linklist是指向链表某一节点的指针；\n至于为什么要设计成指针，这与后面链表的创建有关；\n取下一个节点数据只需要next-\u0026gt;data即可；\n双链表\r双链表相比于单链表，多了指向上一个元素的指针：这样头尾可以互换；\n1 2 3 4 5 typedef struct tagNODE { int data; struct tagNODE *prev,*next; } node,*linklist; 它不仅可以取下一个节点数据，还可以往回取，因此这种链表虽然更加复杂，但是更加容易维护，一条链断了或者数据缺失了都可以使用另外的方法恢复链表；\n循环链表\r循环链表就是最后一个节点的指针指向第一个节点；循环链表让链表数据的访问变得更加快捷；\n比如，从倒数第2个节点访问第2个节点只需要跨过2个节点，而不是将近整个链表；\n单双链表和是否循环使得链表有4种形式；但是考虑到占用空间和访问速度，常用的链表只有2种：不循环单链表和循环双链表；\n链表的创建\r在C语言中，一般使用动态内存分配的方法为链表里的数据分配内存空间，然后再使用头插法或者尾插法实现数据的填写；\n因此，头文件stdlib.h在链表的创建里面是必要的；\n头节点的创建\r每个链表都需要一个头节点作为入口，同时和其它链表进行区分；\n当程序中只出现一个链表时，一般将其设置成L;\n创建一个链表时，必须先创建一个头节点，并为其分配空间； 代码如下：\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdlib.h\u0026gt; // 定义链表结构体 typedef struct tagNODE { int data; struct tagNODE *prev,*next; } node,*linklist; linklist L=NULL; L=(linklist)malloc(sizeof(node)); 分配空间\r只能一个节点一个节点的分配；且和头节点的内存分配类似；\n由于malloc的内存分配的地址具有随机性，因此链表的数据是不连续存放的，这点与数组不同；\n但是不妨碍，通过指针prev和next可以轻松访问到相邻的节点，而且这样还可以充分利用内存空间；\n创建单链表\r在创建链表的时候，需要知道头节点L的地址和节点的个数n;\n常常用到头节点指针p进行辅助，它的作用是记录当前节点的地址，以让下一个节点与当前节点相邻；\n头插法\r头插法最先插入的是最后一个节点，它的next设定为NULL；\n头插法的步骤如下：\n创建节点指针p，为其数据分配空间，并设置p-\u0026gt;next为NULL；这时p-\u0026gt;next可以充当链表末尾； 创建节点s，并为其动态分配内存；然后输入s的数据； 将s插入到链表末尾的位置，然后把p-\u0026gt;next移动到s； 重复2~3步骤以插入更多节点； 以下是图示:\n初始状态(p和L在同一个位置)： 将s插入到链表末尾： 将p-\u0026gt;next移动到s： 重复操作： 具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void CreateLinkF(linklist L,int n) { linklist p,s; int i; // 创建节点指针p p=L; p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); // 将s插入到p的位置，然后把p向上移动一个节点； s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; } } 尾插法\r尾插法最先插入的是第一个节点，再逐步添加节点，最后将末尾节点的next设置成NULL；\n尾插法的步骤如下：\n创建头节点p，为其数据分配空间； 创建节点s，并为其动态分配内存；然后输入s的数据； 将s插入到p的下一个节点，然后将p移动到s的位置； 重复2~3步骤以插入更多节点； 插入完毕后，将最后一个节点的next设置为NULL； 以下是图示： 初始状态： 将s移动到p-\u0026gt;next： 将p移动到s： 重复操作： 将最后一个节点的next设置成NULL： 具体代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void CreateLinkR(linklist L,int n) { linklist p,s; int i; // 创建节点指针 p=L; p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); //将s插入到p的下一个节点，然后将p移动到s的位置； p-\u0026gt;next=s; p=s; } // 将最后一个节点的next设置为NULL； p-\u0026gt;next=NULL; } 循环链表\r循环链表即最后一个节点指向的是第一个节点（不是头节点L！），而不是NULL；\n故需要tmp指针记录第一个节点的地址，并让最后一个节点的next指向它；\n空链表\r空链表指的是没有节点的链表；\n省略掉循环步骤就可以创建一个空链表；\n创建双链表\r双链表和单链表不同的地方在于双链表有2个结构体指针，分别指向前面和后面的节点，换句话说，双链表每两个相邻节点之间都有2条链；\n因此，只需要在加入一个节点时，把另外一条链(prev)连上就可以了；\n头插法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void CreateLinkF(linklist L,int n) { linklist p,s; int i; // 创建节点指针p p=L; p-\u0026gt;prev=p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); // 将s插入到p的位置 s-\u0026gt;next=p-\u0026gt;next; // 设置s的前后指针，以让两条链都链接 if(p-\u0026gt;next!=NULL)p-\u0026gt;next-\u0026gt;prev=s; p-\u0026gt;next=s; } } 尾插法\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 void CreateLinkR(linklist L,int n) { linklist p,s; int i; // 创建节点指针 p=L; p-\u0026gt;prev=p-\u0026gt;next=NULL; // n次循环 for(i=0;i\u0026lt;n;i++) { // 创建节点s并输入数据 s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); //链接s和p的2条链，然后将p移动到s的位置； p-\u0026gt;next=s; s-\u0026gt;prev=p; p=s; } // 将最后一个节点的next设置为NULL； p-\u0026gt;next=NULL; } 循环链表\r需要tmp指针记录第一个节点的地址，并让最后一个节点的next指向它；\n空链表\r省略掉循环步骤就可以创建一个空链表；\n链表的遍历\r注：此后的内容均以不循环单链表为例，循环及双链表同理可得。\n创建链表后可以像数组一样遍历它； 它的大致步骤如下：\n令节点指针p指向链表的头节点； 访问完一个节点后，让p指向p-\u0026gt;next以访问下一个节点； 重复步骤2，直到p=0; 以下是代码：\n1 2 3 4 5 6 7 8 9 void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d\\n\u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } } 其中printf可以更改为其它函数，以实现定制功能；\n比如输出节点个数（不包含头节点）、输出特定节点数据、检测链表是否循环等等；\n链表的销毁\r链表也是动态内存分配来的，它的内存也需要释放；\n不过，由于链表的内存是不连续存放的，它的销毁较为复杂；\n链表的销毁一般通过链表的遍历和free函数实现；\n链表的销毁根据对头节点的去留分为彻底销毁和重置为空表两类；\n由于2种方法仅有头节点处理的问题，因此这里只说彻底销毁的方法；\n步骤如下：\n定义节点指针p=L,q=L-\u0026gt;next; 释放p的内存，然后p和q下移1个节点； 重复步骤2直到p==NULL; 将L扔到NULL里面去，以免产生野指针；(如果还需要使用的话，就令L-\u0026gt;next=NULL) 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { // 释放`p`的内存，然后`p`和`q`下移1个节点； q=p-\u0026gt;next; free(p); p=q; } L=NULL; } 链表节点的插入和删除\rOK啊，我们对着链表说了这么多，费了那么多力气创建、遍历、销毁链表，为的是什么呢？当然就是为了现在更加快捷的插入和删除元素！\n换句话说：就是为了这碟醋包的饺子！\n节点的插入\r现在有一个孤立的节点s,现在要把插入到链表的第i个位置上，该如何做？简单分三步。\n首先，应该找到当前的第i-1个节点；\n然后，将s的next转到原来第i个，现在第i+1个节点上；\n最后，将i-1节点的next从转到s上；\n（这两步不能颠倒，否则找不到第i+1个节点）\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int ListInsert(linklist s,linklist L,int i) { linklist p=L; int t=0; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } // 如果i的值过小或过大都会报错 if(p==NULL||i\u0026lt;0)return 0; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return 1; } 节点的删除\r我们现在要删除链表的第i个节点；\n并且，为了防止误操作，需要输出被删除的节点的数据；\n步骤如下：\n找到第i-1个节点； 将第i-1个节点的next指向第i+1个节点； 将第i个节点的next指向NULL； 输出删除的节点数据，并释放内存； 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int ListDelete(linklist L,int i) { linklist p,q; int t=0; p=L; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } if(p==NULL||i\u0026lt;0)return 0; p-\u0026gt;next=q-\u0026gt;next; q-\u0026gt;next=NULL; printf(\u0026#34;%d\u0026#34;,q-\u0026gt;data); free(q); return 1; } 实例\r以下是一些链表操作的实例；\n头插法（CreateLinkF.c）\r输入：\n第一行输入插入元素的个数n，然后第二行输入n个数；\n输出：\n储存的链表数据，和输入的数据是倒序的；\n程序运行结束后销毁链表；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; void CreateLinkF(linklist L,int n) { linklist p,s; int i; p=L; p-\u0026gt;next=NULL; for(i=0;i\u0026lt;n;i++) { s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; } } void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } L=NULL; } int main() { linklist L=NULL; int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); L=(linklist)malloc(sizeof(node)); CreateLinkF(L,n); ListTrarse(L); printf(\u0026#34;\\n\u0026#34;); DestroyLink(L); return 0; } 输入：\n1 2 5 1 2 3 4 5 输出：\n1 5 4 3 2 1 尾插法（CreateLinkR.c）\r该代码和头插法仅有链表创建时使用的函数不同，其余部分均一致；\n这个输出是正序的；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; void CreateLinkR(linklist L,int n) { linklist p,s; int i; p=L; p-\u0026gt;next=NULL; for(i=0;i\u0026lt;n;i++) { s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); p-\u0026gt;next=s; p=s; } p-\u0026gt;next=NULL; } void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } L=NULL; } int main() { linklist L=NULL; int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); L=(linklist)malloc(sizeof(node)); CreateLinkR(L,n); ListTrarse(L); printf(\u0026#34;\\n\u0026#34;); DestroyLink(L); return 0; } 输入：\n1 2 5 1 2 3 4 5 输出：\n1 1 2 3 4 5 插入和删除元素(InsAndDel.c)\r在尾插法的基础上，增添了增删元素功能；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; typedef struct tagNODE { int data; struct tagNODE *next; } node,*linklist; void CreateLink(linklist L,int n) { linklist p,s; int i; p=L; p-\u0026gt;next=NULL; for(i=0;i\u0026lt;n;i++) { s=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); p-\u0026gt;next=s; p=s; } p-\u0026gt;next=NULL; } void ListTrarse(linklist L) { linklist p=L-\u0026gt;next; while(p!=NULL) { printf(\u0026#34;%d \u0026#34;,p-\u0026gt;data); p=p-\u0026gt;next; } printf(\u0026#34;\\n\u0026#34;); } int ListInsert(linklist s,linklist L,int i) { linklist p=L; int t=0; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } if(p==NULL||i\u0026lt;0)return 0; s-\u0026gt;next=p-\u0026gt;next; p-\u0026gt;next=s; return 1; } int ListDelete(linklist L,int i) { linklist p,q; int t=0; p=L; while(p!=NULL\u0026amp;\u0026amp;t\u0026lt;i-1) { p=p-\u0026gt;next; t++; } if(p==NULL||i\u0026lt;0)return 0; q=p-\u0026gt;next; p-\u0026gt;next=q-\u0026gt;next; q-\u0026gt;next=NULL; printf(\u0026#34;Deleted: %d\\n\u0026#34;,q-\u0026gt;data); free(q); return 1; } void DestroyLink(linklist L) { linklist p,q; p=L; while(p!=NULL) { q=p-\u0026gt;next; free(p); p=q; } L=NULL; } int main() { linklist L=NULL; int n,i; L=(linklist)malloc(sizeof(node)); scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); CreateLink(L,n); ListTrarse(L); linklist s=NULL; s=(linklist)malloc(sizeof(node)); s-\u0026gt;next=NULL; printf(\u0026#34;Enter a node\u0026#39;s data:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;(s-\u0026gt;data)); printf(\u0026#34;Enter a number to insert:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); if(ListInsert(s,L,i)!=1) { printf(\u0026#34;Error in insert.\\n\u0026#34;); return 0; } ListTrarse(L); printf(\u0026#34;Enter a number to delete:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); if(ListDelete(L,i)!=1) { printf(\u0026#34;Error in delete.\\n\u0026#34;); } ListTrarse(L); return 0; } 程序运行输入和输出：\n1 2 3 4 5 6 7 8 9 5 1 2 3 4 5 1 2 3 4 5 Enter a node\u0026#39;s data:6 Enter a number to insert:3 1 2 6 3 4 5 Enter a number to delete:5 Deleted: 4 1 2 6 3 5 ","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/10.linklist/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/10.linklist/","title":"C/C++基础-10.链表"},{"content":"程序结构\r任务自动化：预处理\r宏定义#define\r#define 是宏，可以将代码中所有与预处理变量相同的式子替换为处理后的式子。\n为避免混淆，宏定义的常量也用大写字母表示;\n如果要取消怎么办？使用#undef即可。\n取消之后就可以对宏进行重新定义，否则宏不能重复定义；\n不过，需要注意的是，#define只能简单粗暴的做替换工作，不能运算。\n如果#define A 3+2；\n那么 2*A 的结果就会是8而不是10.\n因为实际上代码被替换为了 2*3+2 而不是 2*(3+2);\n勤加括号可以避免这一类问题的出现。\n已有的宏定义\r除此之外，有些宏已经在头文件里面预处理好了，直接当作一般的变量使用就行；\n他们有：\n__DATE__ __TIME__ __FILE__ __LINE__ __STDC__\n(注意是两横)\n分别表示编译程序时的日期、时间、文件名、当前源代码的行号、是否兼容ANSI C标准；\n宏定义可以使代码变得更加简洁可读；\n如下面的例子(define.c)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #define LENGTH 10 #define WIDTH 5 int main() { int area; area = LENGTH * WIDTH; printf(\u0026#34;%d\\n\u0026#34;,area); printf(\u0026#34;%s\\n\u0026#34;,__DATE__); printf(\u0026#34;%s\\n\u0026#34;,__TIME__); printf(\u0026#34;%s\\n\u0026#34;,__FILE__); printf(\u0026#34;%d\\n\u0026#34;,__LINE__); return 0; } 输出结果：\n50\n(剩下的内容因人而异，请自行尝试)\n带参数的宏定义\r宏定义里面可以带参数；比如下面这个例子：\n#define max(a,b) ((a)\u0026gt;(b)?(a):(b))\n与不带参数的宏区别的地方是，带参数的在后面会给出一个参数表，并在宏调用时用main函数提供的参数来填充宏里面的未知数；\n如上面的宏将会把所有的a和b都用数字替代；\n这看起来很像函数的参数调用；但是二者却有不同，原因是宏在调用时会进行多次参数运算；\n#作为运算符\r除预处理宏之外，#还是个运算符；另外##也是个运算符；\n#运算符的作用是将文本参数“字符串化”，也就是说可以去掉双引号；\n##运算符的作用是把两个字符文本连接为一个字符文本，也就是说，宏的替换会在连接之前就发生；\n于是，我们可以对一个字符串中的部分内容替换而不需要加空格；\n比如，\n#define PRINT(x) printf(#x)\n#define SET(arg) A##arg=arg\n多文件结构\r随着编程的发展，程序的结构变得越来越复杂；\n用单个源文件来编写整个程序越来越难以实现；\n因此，必须要学习多文件程序结构，将程序设计的重点放在多文件架构下变量、函数的迁移以及程序的组织方面；\n不死之身：全局变量\r全局变量定义在大括号外面，因此它们在整个程序中都有效，不会消失。\n但是，伴随着的就是长期的内存占用和对程序模块化的破坏；\n需要注意的是，全局变量在作用域内会被同名的局部变量顶替。\n即：大的作用域服从于小的作用域；\n如下面的例子(global.c)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; // 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; printf(\u0026#34;%d\\n\u0026#34;,g); // 这里可以正常调用变量g; return 0; } 变量修饰：静态与动态存储\r前面提到，全局变量可以长期的占用内存空间；\n那么，对于局部变量，是不是也能实现静态存储呢？\n答案是肯定的。我们可以通过修饰变量来改变它的存储方式；\n一般来说，变量的存储方式分为3种；\n静态的就是静态存储；\n动态的有自动存储和自由存储；\n静态存储\r在定义变量时前面加上static来使变量变为静态变量；\nstatic int a = 10;\n完了以后它的作用域将会扩大，但是与全局变量不同的是，它无法超越它所在的函数；\n一个静态变量如果没有被初始化，默认为0；而且它只认第一次初始化；如下面的例子：(static.c)\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; void staprintf(int n) { printf(\u0026#34;%d\\n\u0026#34;,n); } int main() { static int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); staprintf(n); return 0; } 可以发现函数可以调用静态变量；\n全局变量也是如此，但局部变量不同，它会变成一个随机的值，有机会造成食物中毒。\n还是那句话，静态的东西尽量少用；\n自动存储\r这是系统默认的存储，即定义的时候分配空间，作用域结束的时候销毁； 实现这个存储你啥都不需要加，如果硬要的话也可以加个auto；\n(auto) int a = 10;\n自由存储\r自由存储指的是按照程序员的意愿指定空间分配和释放的时机，具有极大的自由性；\n但是缺点是容易忘记，分配倒还好，主要是忘记释放或者忘记已经释放；\n自由存储只能通过函数和指针实现，即\u0026lt;stdlib.h\u0026gt;里面的malloc和free函数；\n变量声明：extern\r类似于函数，变量也有声明；\n但是怎么区分声明与定义？\n函数倒还好，不写函数体就是声明了；\n但变量呢？不初始化？那是未赋初值的变量的定义，不是声明；\n因此，我们特地引入符号extern，来表示一个变量的声明；\nextern int a\n有了声明，就能够在定义的前面调用变量； 但是，与函数不同的是，变量声明后不能初始化；\n比如，extern int a = 10; 是错误的；\n由于定义包含声明，所以变量的声明看似没有多大用处；\n但是，在多文件结构中，变量的声明是极其有用的；\n它可以在不同的源文件中分离声明和定义，以达到程序模块化的效果；\n函数修饰：内部与外部\r函数修饰仅存在于多文件结构中，因为单个源文件没有内部和外部的说法；\n函数修饰分为内部修饰和外部修饰；\n内部修饰\r在函数定义的前面加上static进行内部修饰；\n1 2 3 4 static int fun(int, int) { ... // 函数体 } 函数进行内部修饰后，仅在当前源文件中有效，其它文件无法调用这个函数，要想用只能自己重新定义；\n外部修饰\r函数默认为外部修饰，因此加不加extern都无所谓了；\n外部修饰保证函数在整个多文件结构中有效；想要调用只需要声明就可以了；\n多文件结构\r多文件结构程序允许多个源程序存在；\n如果要把它们放在一起运行，应该首先分别编译成.o可重定位文件，再使用连接器把所有.o和一些杂七杂八的库函数连接在一起，生成可执行应用程序；\n另外，头文件和工程文件也是多文件程序十分有用的结构；\n头文件\r头文件就是一大堆函数的声明和宏、全局常量的集合；\n为什么要头文件呢？之前说过，源文件如果想要调用外部函数，那么就必须要先声明；\n如果有很多个源文件，就要写很多次；这不仅麻烦，还不利于修改。\n但是，头文件就可以把这些所有的声明集合到一起，之后在每个程序里边只需要一句#include就可以了；\n工程文件\r如果有很多个源文件，那么必须要把它们分别编译成.o文件以后才能连接，这样就要执行很多条指令，非常碍事；\n但是，如果我们使用工程文件，就可以自动执行编译与连接，简化操作；\n常见的工程文件就是Makefile，把它编写好以后仅需要在命令行输入一句make就可以启动自动编译；\n这里不展开，因为实际上我也不会编写makefile(\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/11.engine/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/11.engine/","title":"C/C++基础-11.程序结构"},{"content":"数据持久化：文件\r通常我们根据和终端进行输入输出来进行交互；\n这样虽然方便，但是无法长期的存储数据；\n因此，我们需要一个新的内容，它可以长期的储存像文本、应用程序一样的数据，它就是文件；\n文件系统根据操作时交换区的情况又分为缓冲区文件系统和非缓冲区文件系统；\n缓冲区文件系统\r缓冲区文件系统包括一个用于内存和磁盘之间的名叫缓冲区的交换区；\n它为每一个正在使用的文件开辟了一片临时空间；\n所有对磁盘中对文件的操作都会先由内存进入缓冲区临时储存，当缓冲区满后再一起送到磁盘中去长期保存；\n这样的好处就是存取效率高，但是有概率发生缓冲区数据丢失；\n非缓冲区文件系统\r非缓冲区文件系统没有缓冲区这个交换区，一切文件操作都是内存和磁盘二者直接进行的；\n非缓冲区虽然几乎不会发生数据丢失，但是存取效率会低很多；\nC语言文件操作使用缓冲区文件系统，因此下面文件操作都是基于缓冲区文件系统进行的；\n文件在C程序中的表示\r注：文件的操作函数大部分都在标准输入输出头文件stdio.h里面；\n不需要额外定义函数、结构体之类的东西；\n可以使用结构体FILE来定义一个文件指针变量；\n当文件指针变量指向了一个文件时，就可以通过指针来对文件进行操作；\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct _iobuf { char *_ptr; // 文件位置指针 int _cnt; // 缓冲区剩余字符数 char *_base; // 缓冲区首地址 int _flag; // 文件状态标志 int _file; // 文件有效性检查 int _charbuf; // 若无缓冲区则不读取字符 int _bufsize; // 缓冲区大小 char *_tmpfname; // 临时文件名 } FILE; // 定义文件结构体 FILE *fp; // 定义一个文件指针变量 然而结构体里面的大部分内容，我感觉现在都用不到；\n文件的打开与关闭\r在定义了一个文件指针变量后，接下来的任务就是要让它指向一个文件；\n这时候就需要用到文件打开函数fopen； 与此同时还有文件的关闭函数fclose，它们的原型如下：\n1 2 FILE *fopen(const char *filename,const char *mode); int *fclose(FILE stream); 文件的打开\rfopen函数里面的2个参数分别代表文件名、打开模式；\nfilename\rfilename是一个字符串，指示将要打开的文件名，比如file.md；\n值得注意的是，这样写的话只能打开本目录（即源程序所在目录）的文件；\n如果想要打开其它地方的文件的话，就要使用相对路径或者绝对路径；\n比如，现在想要打开本文件夹的以下文本文件，需要在filename处填入如下字符串：\n1 2 3 4 5 6 7 8 9 a.txt // 当前目录下的a.txt文件 // 相对路径（注意，斜杠应该表达成转义字符双斜杠“\\\\”形式） sub\\\\b.txt // sub子目录下的b.txt文件 ..\\\\c.txt // 上一级目录下的c.txt文件 // 绝对路径（因为绝对路径因人而异，故这里的路径仅为示例，没有真实的文件） C:\\\\d.txt // C盘根目录下的d.txt文件 C:\\\\e.txt // C盘当前目录下的e.txt文件 mode\r模式根据文件的类型、是否进行读写等等划分为多种类型，也是以字符串表示；\n下面是常见的模式类型及其功能：\n文本文件 二进制文件 含义 r或rt rb 打开文件用于只读，若无该文件则报错 r+或rt+或r+t rb+或r+b 打开文件用于读写，若无该文件则报错 w或wt wb 创建文件用于只写，若有该文件则覆盖原文件 w+或wt+或w+t wb+或w+b 创建文件用于读写，若有该文件则覆盖原文件 a或at ab 打开文件用于追加，若无该文件则创建新文件 a+或at+或a+t ab+或a+b 打开文件用于追加和读，若无该文件则创建新文件 可以看出，a模式可以看作是模式r和w的融合升级版；\n既解决了r模式下的报错问题，又克服了w模式下由于新文件会覆盖原文件，导致无法对文件进行修改的缺点；\n所以a模式总是可以用的；\n打开文件后，函数将会向FILE*指针返回对应的文件指针，若发生错误则会返回NULL指针；\n以下是文件打开的例子：\n1 2 3 FILE *fp1,*fp2; *fp1=fopen(\u0026#34;in.txt\u0026#34;,\u0026#34;r\u0026#34;); // 打开一个已存在的in.txt文本文件 *fp2=fopen(\u0026#34;out.dat\u0026#34;,\u0026#34;wb\u0026#34;); // 创建一个out.dat二进制文件 文件的关闭\r就如动态内存分配后需要释放内存一样，文件打开后也需要关闭；\n否则写入的内容会因为存放在缓冲区内没有保存，而导致文件操作失败；\n文件关闭的参数是FILE*指针，不是文件名；\nfclose函数是有返回值的，可以判定文件是否正常关闭；\n除此之外，还提供了一个函数来关闭所有已经打开的文件；它的原型如下：\n1 int _fcloseall(void) 文件的读写\r文件的读写一般是终端的输入输出在最前面加上f；\n比如fgetc，fputc，fgets，fputs等等；\n但是使用的最多的函数还是fscanf和fprintf两种，它们的原型如下：\n1 2 int fscanf(FILE *stream,const char *format [,argument] ...); int fprintf(FILE *stream,const char *format [,argument] ...); 它们的参数就是标准格式化输入输出scanf，printf在最前面加上了文件指针参数；\nfscanf\rfscanf函数的文件指针即将要读取数据的文件；\n事实上，scanf可以看作文件指针是标准输入stdin（键盘）的fscanf函数；\nfprintf\rfscanf函数的文件指针即将要写入数据的文件；\n事实上，printf可以看作文件指针是标准输出stdout（屏幕）的fprintf函数；\n文件的重定向\r文件的重定向一般涉及到“重开”函数freopen；\n它的原型如下：\n1 FILE *freopen(const char *path, const char *mode, FILE *fp); path是存储输入输出的文件名的字符串；\nmode和fopen里面的mode一样；\nfp是被“重开”文件的指针；\n常见的重定向操作是把标准输入输出文件重定向到文本文件；\n即：\n1 2 freopen(in.txt,\u0026#34;w\u0026#34;,stdin); // 标准输入重定向到in.txt文本文件 freopen(out.txt,\u0026#34;r\u0026#34;,stdout); // 标准输出重定向到out.txt文本文件 在重定向操作之后，之前的标准输入输出函数，像scanf、printf之类的都不会通过终端读写，而是通过文本文件；\n重定向有很多好处，比如储存较大的输入文件，而不是每次都在终端上敲一遍；储存输出文件，并和其它输出进行比较；通过加上和删去重定向的方式，使交互方式在终端和文件里面切换，而不需要更改任何其它内容；\n实例\r读写文件内容（file.c）\r读取位于不同位置的文本文件abc，然后将其内容（只有一行且没有空格）写到文本文件d中；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;stdio.h\u0026gt; void ReadAndWriteFile(FILE *p1, FILE *p2) { // 用于记录文件内容 char str[100]={0}; // 检测文件是否打开成功 if(p1==NULL) { printf(\u0026#34;Not Found\\n\u0026#34;); return; } fscanf(p1,\u0026#34;%s\u0026#34;,str); // 从p1所指文件里读取数据 fprintf(p2,\u0026#34;%s\\n\u0026#34;,str); // 输出数据到p2所指文件 } int main() { FILE *p1=NULL,*p2=NULL,*p3=NULL,*p4=NULL; p1=fopen(\u0026#34;a.txt\u0026#34;,\u0026#34;r\u0026#34;); // 本目录 p2=fopen(\u0026#34;sub\\\\b.txt\u0026#34;,\u0026#34;r\u0026#34;); // 子目录 p3=fopen(\u0026#34;..\\\\c.txt\u0026#34;,\u0026#34;r\u0026#34;); // 上一目录 p4=fopen(\u0026#34;d.txt\u0026#34;,\u0026#34;a\u0026#34;); // 输出文件 ReadAndWriteFile(p1,p4); ReadAndWriteFile(p2,p4); ReadAndWriteFile(p3,p4); _fcloseall(); // 关闭所有文件以正常结束程序 return 0; } 注：因为使用了a模式，所以不会删除前面的执行结果；\n因此多次运行该程序会让d.txt显示以下结果：\n1 2 3 4 5 6 7 a b c a b c …… 文件重定向（freopen.c）\r将标准输入输出文件分别重定向到in.txt和out.txt；\n然后完成A+B problem；\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;stdio.h\u0026gt; int main() { freopen(\u0026#34;in.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); freopen(\u0026#34;out.txt\u0026#34;,\u0026#34;w\u0026#34;,stdout); int a,b; scanf(\u0026#34;%d%d\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;%d\\n\u0026#34;,a+b); _fcloseall(); return 0; } 在in.txt里面输入2个数，运行程序，然后打开out.txt，即可看到结果；\n","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/12.file/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/12.file/","title":"C/C++基础-12.文件"},{"content":"类与对象\r在编程语言中，其实早已存在类和对象的概念；\n比如int、double等数据类型和array、struct等数据结构；\n而它们所承载的变量就是对象；\nC++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计，实际上就是丰富了类的功能，以及可以创造自己的类。\n类是 C++ 的核心特性，通常被称为用户定义的类型。\n类可以被看作是一种模板数据结构，可以用来创建具有相同属性和行为的多个对象。\n作为C++特有的数据结构，类相对于结构体可以定义成员函数，并且还拥有继承、封装、多态等特性，功能强大；\n类的定义\r类用于指定对象的形式，是一种用户自定义的数据类型，它是一种封装了数据和函数的组合。\n类中的数据称为成员变量，函数称为成员函数。\n使用class来定义类，定义具体结构和struct类似；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Box // 定义名为“Box”的类 { // public代表下面的成员允许被访问 public: // 成员变量，分别储存盒子的长、宽、高 double length; double breadth; double height; // 成员函数，用于计算盒子的体积 double getVolume(void) { return length * breadth * height; } }; 在创建了类之后，就可以以类作为数据类型来定义变量；\n这时候不需要typedef语句来转换；\n1 Box box1 下面是演示类基本操作的实例：box.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: double length; double breadth; double height; double getVolume(void) { return length * breadth * height; } }; int main() { Box box1; // 声明box1，类型为类Box int volume; // 存储box1的体积 // box1的详述 box1.length=3; box1.breadth=4; box1.height=5; // 计算box1的体积 volume=box1.getVolume(); // 输出box1的数据 cout\u0026lt;\u0026lt;box1.length\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.breadth\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.height\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;volume; return 0; } 输出：\n1 2 3 4 3 4 5 60 类成员函数\r成员函数和成员变量一样，都是类的成员；\n成员函数和普通函数的区别在于可以在没有传入形参的情况下引用对象里的成员；\n需要注意的是，成员函数可以只给出声明，到后面再给出实际定义；\n这样就可以将类封装在头文件中，满足多文件结构的需要；\n如下面对box.cpp的修改例子：boxInFunc.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; class Box { public: double length; double breadth; double height; // 仅给出函数声明 double getVolume(void); }; // 函数定义在类之外 double Box::getVolume(void) { return length*breadth*height; } int main() { Box box1; int volume; box1.length=3; box1.breadth=4; box1.height=5; volume=box1.getVolume(); cout\u0026lt;\u0026lt;box1.length\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.breadth\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.height\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;volume; return 0; } 输出：\n1 2 3 4 3 4 5 60 这里注意，如果要这样定义，必须使用范围解析运算符::来指明函数实际位于那个类当中；\n::和.都可以用于类，它们的区别在于一个前面是类名，另一个前面是类变量这个对象；\n1 2 3 Box box1; Box::getVolume(); // 定义成员函数，不针对特定对象 box1.getvolume(); // 调用成员函数，针对特定对象box 类访问修饰符\r前面看到，在定义类成员时，前面有public标识；\n实际上，这就是类访问修饰符，除了public以外还有private和protected的标识；\npublic即公有标识，代表着你在类的外部可以查看和修改该成员；\nprivate是私有标识，有该标识的成员在类的外部不可以被查看和修改，因此要借助内部的成员函数才能修改；\nprotected是受保护标识，平时和private几乎一致，但是在类的继承上会有区别；\n使用类访问修饰符，可以防止函数直接访问类类型的内部成员，从而保证安全性；\n比如下面的例子，只能通过成员函数对成员变量赋值；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 #include \u0026lt;iostream\u0026gt; using namespace std; class Box { // 变量使用私有标识 private: double length; double breadth; double height; // 函数使用公有标识 public: double getVolume(void); void setLength(double len); void setBreadth(double bre); void setHeight(double hei); double getLength(void); double getBreadth(void); double getHeight(void); }; double Box::getVolume(void) { return length*breadth*height; } void Box::setLength(double len) { length=len; } void Box::setBreadth(double bre) { breadth=bre; } void Box::setHeight(double hei) { height=hei; } double Box::getLength(void) { return length; } double Box::getBreadth(void) { return breadth; } double Box::getHeight(void) { return height; } int main() { Box box1; int volume; // 下面操作不行，因为私有成员不能修改 // box1.length=3; // box1.breadth=4; // box1.height=5; // 利用成员函数赋值 box1.setLength(3); box1.setBreadth(4); box1.setHeight(5); volume=box1.getVolume(); // 下面操作不行，因为私有成员不能查看 // cout\u0026lt;\u0026lt;box1.length\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.breadth\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.height\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;volume; //利用成员函数输出 cout\u0026lt;\u0026lt;box1.getLength()\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.getBreadth()\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;box1.getHeight()\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;volume; return 0; } 输出：\n1 2 3 4 3 4 5 60 构造函数与析构函数\r","date":"2025-02-20T00:00:00Z","image":"http://localhost:1313/post/tutor/c_cpp_learning/13.oop/c_hu_6c68aa95fafef068.png","permalink":"http://localhost:1313/post/tutor/c_cpp_learning/13.oop/","title":"C/C++基础-13.类与对象（未完待续）"},{"content":"正文测试\r而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用\r思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片\r1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/post/example/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"http://localhost:1313/post/example/test-chinese/","title":"中文测试"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings\rThe following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1\rH2\rH3\rH4\rH5\rH6\rParagraph\rXerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes\rThe blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution\rTiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution\rDon\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables\rTables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables\rItalics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks\rCode block with backticks\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces\r\u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block\r1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types\rOrdered List\rFirst item Second item Third item Unordered List\rList item Another item And another item Nested list\rFruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark\rGIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image\rThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/post/example/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"http://localhost:1313/post/example/markdown-syntax/","title":"Markdown语法"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nbilibilibi Shortcode\rQuote Shortcode\rStack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"http://localhost:1313/post/example/rich-content/","title":"富媒体"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt\rThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat\rVicta caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/post/example/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"http://localhost:1313/post/example/placeholder-text/","title":"文章分段"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples\rInline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$\r\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/post/example/math-typesetting/","title":"使用数学公式"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/post/example/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/post/example/emoji-support/","title":"使用emoji"}]