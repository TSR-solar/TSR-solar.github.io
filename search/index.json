[{"content":"c_cpp_learning\r介绍\r学习C和C++的笔记！\n从2024年10月29日开始，将会逐渐将代码和注释分离，并将注释用markdown文件重写；而代码会成为markdown笔记的附件；\n本笔记前面大部分是C的学习内容，还有少量C++的拓展。后面C++的内容会多一些。已经在笔记中用标题做了区分，并用c和cpp后缀来区分代码附件。 所以，虽然C和C++交替出现，抛弃掉C++的拓展也能获得详尽的C语言笔记。\n笔记没有完全按照学习顺序分布，而是模块化的；若感到理解困难，不妨跳到对应的模块查看相关内容，或自行上网查询资料；\n由于编译时可能会出现中文乱码问题，因此代码中的输出均使用英文表示。\n本笔记现已在GitHub和Gitee上发行。\n更新日志\r2024/11/29 14:51 v0.0.0\r芜湖！鸽了好久的正式版终于上线啦！\n在发布v -1.7.0 时，我曾经说过下个版本要大更新；\n当时只剩指针和引用没有被重制了；\n结果后来遇到各种事情，就暂时把上线放到了后面；\n没想到这一耽搁就是18天!!!\n但是还好，自上次 v -1.0.0 于10月29日上线以来到现在，刚好过去了一个月；\n以后如果有人问起来，还可以说自己是为了凑整一个月才推迟的；哈哈\nOK，这个版本就像之前说的一样，笔记已经100%使用markdown编写；\n代码部分以附件的形式存在于文件夹中；希望你们喜欢这种新形式的排版！\n2025/1/11 20:07 v0.1.0\r放假咯！\n之前因为学习把笔记的编写耽误了太久，现在终于有时间来专心写笔记了；\n接下来会将链表和文件的内容补齐，那么C语言的内容就差不多了；\n届时会推行正式版v1.0.0！\n接下来的安排就是C++了；\n此外还会推行新的仓库python和数据结构，敬请期待！\n2025/1/17 15:02 v1.0.0\r这是正式版！\n现在已经将链表和文件的内容补齐了，那么C语言的内容差不多就结束了；\n之后对于C语言只会对现有内容做一些修补工作，应该不会再添加新的内容了；\n但是，此后还会更新C++的新内容，等到C++更新完毕后会推出2.0版本，敬请期待！\n","date":"2025-02-20T00:00:00Z","permalink":"http://localhost:1313/post/c_cpp_learning/readme/","title":"C/C++基础-00.简介"},{"content":"最基础的C程序\r1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } stdio.h是C中掌管输入输出的头文件，必须要 #include它才能实现后续的输出操作； main是主函数，用来执行你的代码操作； printf是C语言的标准输出函数，它可以向你的屏幕打印 hello world；\n最基础的C++程序\r1 2 3 4 5 6 7 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt;\u0026#34;Hello World\\n\u0026#34;; return 0; } iostream是c++的头文件;\n还想用C的头文件的话就只能在前面加“c”(不用加.h); 如stdio.h变成cstdio；\nstd是标准命名空间，包含大量基本函数。不同命名空间的函数定义是不一样的。 cout可以被认为是C++里的printf，加上\u0026laquo;即可。\n","date":"2025-02-20T00:00:00Z","permalink":"http://localhost:1313/post/c_cpp_learning/01.helloworld/","title":"C/C++基础-01.hello world"},{"content":"printf\rprintf还可以用来做计算。见下方代码(printf.c)：\n1 2 3 4 5 6 7 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;hello，114+514=%d\\n\u0026#34;, 114+514); return 0; } 这个代码可以输出数字之间的运算；\n1 printf(\u0026#34;hello，114+514=%d\\n\u0026#34;, 114 + 514); %d 说明后面要有1个整数输出在这个位置上，在后面接一个逗号，填入计算式（当然也可以是一个数）； 则程序运行过程中，%d 将被替换为计算结果 114+514=628，所以输出：\nhello，114+514=628\n在C语言中，四则运算符略有不同： 加号与减号不变； 乘号为 * ，不是 ×;\n除号为 / ，不是 ÷ （实际上也很难打出错误的那一个）\n另外，还有取余符号%，读作“模”;\n514%14即为514/14=36\u0026hellip;10，取余数10，所以514%14=10\nscanf\r相对于printf用于输出，函数scanf可以用于输入数据用于计算; 不过最后还是要用printf输出计算后的数据; 例(scanf.c)：\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int atk=0;//定义变量atk，初始值为0（也可以是其它数值，但必须是整数） printf(\u0026#34;I have 100 hp now,and please attack me.\\n All you need to do is to input your attack here:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;atk); int hp = 100 - atk;//定义另一个变量hp，它的初始值为 100 - atk ;若先前输入20，则hp的初始值为 100 - 20 = 80 ; printf(\u0026#34;OK,now I only have %d hp.\\n\u0026#34;, hp); return 0; } 运行代码，此时屏幕上显示：\nI have 100 hp now,and please attack me.\\n All you need to do is to input your attack here:\n此时可以在窗口输入内容； 若为整数，则 \u0026amp;atk 会将输入的内容存储到变量atk上；若 \u0026amp;atk 没有 \u0026amp; ，代码会直接崩溃。 若不为整数，则直接忽略你输入的内容，atk仍为初始值0；\n接下来就很熟悉了，若输入20，则应该输出:\nOK,now I only have 80 hp.\n注意：若攻击超过100，血量可以为负；\nstdio：C语言标准输入输出\r都讲了C++的输出了，是时候讲一下stdio到底是什么了；\n看到stdio.h时，会发现，std就是C++里面的标准命名空间，而i代表input，o代表output；\n因此，stdio的意思就是标准输入输出；\n那我们就知道了，stdio包括stdin stdout，此外还有stderr，用来记录报错；\n正是引入的头文件里面这些标准输入输出，让我们能够实现人机交互；\n通过向机器输入一些数据，让机器通过程序计算来向人类输出预期结果；\n在C语言中，stdin和stdout主要是由scanf和printf函数来完成的；\n除此之外还有getchar/putchar;gets/puts等形式；\nscanf用于从标准输入获取数据并格式化，而printf用于向标准输出发送数据并格式化; 没错，在这里标准输入就是键盘，标准输出就是你的电脑屏幕;\n什么是格式化呢？就是通过一些特殊字符（如百分号或转义字符）将函数后面的参数转化; 比如%d可以转换为整型变量，%f可以转换为浮点型变量; 此外，还可以在百分号后面加上若干正则，来进一步修饰限制参数格式;\n","date":"2025-02-20T00:00:00Z","permalink":"http://localhost:1313/post/c_cpp_learning/02.i-o/","title":"C/C++基础-02.输入输出"},{"content":"数据类型与运算\r走进变量\r之前我们定义变量，并用变量来存储用函数scanf输入的数据，并用printf输出存储值；\n那么，现在让我们更深入的了解一下变量；\n当要在程序里保存数据时，就需要一个变量来保存它； 用一个变量保存了数据，它才能参加到后面的计算中； 不定义变量，函数scanf就无法使用，因为数据得不到保存；\n变量定义的一般形式就是：\u0026lt;类型名称\u0026gt; \u0026lt;变量名称\u0026gt;； int就是一种类型名称，除此之外还有很多种类型名称；\n变量名称自己任意取，只能由字母、数字和下划线 _ 组成，数字不可以出现在第一个位置上，区分大小写；\n此外，C语言的关键字（如int）不可以用作变量名称。\n利用变量来储存数据时，常用赋值运算符“=”；\n在C语言中，“=”不表示相等关系，而是赋值动作，是动态过程；\n如 int a = 114 ；就表示把114储存在a这个变量中，并不代表a和114相等；\n除此之外，还可以用scanf一次输入多个变量或者常量，或者是用printf展示多个变量，如以下的例子：(int.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0 ;//定义变量 int atk2 = 0 ; const int ATK3 = 10 ;//定义常量 int originalhp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); int hp = originalhp - atk1 - atk2 - ATK3; printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n \u0026#34;,originalhp,atk1,atk2,ATK3,hp); return 0; } int为定义变量，不必多说；\nconst int为定义常量,用const int定义的常量数值永远不会发生变化，因此常用大写字母表示(ATK3)；\n如果想要强行用赋值表达式改变常量数值，会报错； const int 的意义在于给予常数名字，从而增强代码的可读性； 如ATK3即玩家3的攻击，它的数值为10；如想修改玩家3的攻击，只需找到ATK3，而不是10；\n1 2 3 4 5 printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); 这里连续使用多个scanf函数，以输入两名玩家的攻击。\n注意：在函数scanf中，只有输入数据并按回车后，才会执行下面的代码； 同理，碰到scanf后，会暂停读后面的代码；\n1 2 int hp = originalhp - atk1 - atk2 - ATK3; printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n \u0026#34;,originalhp,atk1,atk2,ATK3,hp); 这里的printf一次展示了多个变量； 想输出几个变量，就在前面放入几个 %d ，用 %d 代替要展示的变量；\n相应地，在后面，要填入等量的变量，中间用逗号隔开，注意变量之间的顺序；\n一种代码运行示例：\nI have 100 hp now.\nThere have 3 players that will attack me.\nWe have known player3\u0026rsquo;s attack is 10.\ninput player1\u0026rsquo;s attack:20\ninput player2\u0026rsquo;s attack:30\n(20 和 30 为运行时自己输入，可更改。)\nOK,Now I only have 100-20-30-10=40 hp.\n更多变量类型\r在生活中，常用到小数；\n例如 10/3 ，结果为3.33333333（循环）;\n但如用C语言计算，如 printf(\u0026quot;%d\\n\u0026quot;,10/3) ，答案却是3！\n这是在C语言中，整数的运算结果只能是整数；\n因为10和3都是整数，所以，3.33333333（循环）进行了向下取整，得到10/3=3。\n如此，便会得到10/3*3=9这样的离谱结果！\n此时，有一个解决方案，就是利用C语言中的浮点数。 浮点数就是带小数点的数值。浮点这个词的本意就是指小数点是浮动的， 是计算机内部表达非整数（包含分数和无理数）的一种方式。\n如下面的例子：(divider.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;stdio.h\u0026gt; int main() { //dividend 被除数\tdivisor 除数 int a = 0, b = 0, c = 0, d = 0; double g = 0; printf(\u0026#34;It\u0026#39;s a calculator for division.\\n\u0026#34;); printf(\u0026#34;input dividend and divisor in order:\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); c = a / b; d = a % b; g = a *1.0/ b; printf(\u0026#34;%d÷%d=%d...%d\\n\u0026#34;, a, b, c, d); printf(\u0026#34;%d÷%d=%f\\n\u0026#34;,a,b,g ); return 0; } 以10/3为例，得到的结果为：\n10÷3=3\u0026hellip;1 ；\n10÷3=3.333333 ；\n1 2 int a = 0, b = 0, c = 0, d = 0, e = 0, f = 0; double g = 0; 与int类似，double也是类型名称；\n只不过int类型的变量始终为整数，而double类型的变量始终为浮点数；\n因此，初始值a=b=c=d=e=f=0;\n而g=0.000000（其实还有更多位，但只显示6位小数）\n1 g = e *1.0/ f; 需要注意的是，不能直接写 g = e / f ;\n因为上面提到，整数的运算结果只能是整数；\n而 e 和 f 都是 int 类型的变量，显然会抹掉结果的小数部分；\n这样，即使 g 是 double 类型的变量，也不会得到正确结果；\n比如，当 e=10 ，f=3 时，显示 10÷3=3.000000 ;\n而不幸的是，虽然问题出在 a 和 b 的类型名称 int 上，更改 int 为 double 并不能解决问题;\n因为，这样会让 e 变为10.000000， f 变为3.000000； 显示的会是：\n10.000000÷3.000000=3.333333；\n虽然结果对了，但是我输入的是整数，来这么多小数干啥！而且浮点数取余也会出错；\n因此，我们不更改 int 为 double ，而是 e * 1.0 ； 这样既利用1.0这个浮点数将结果设置为浮点数 3.333333 ，又不会影响结果；最终显示：\n10÷3=3.333333\n1 printf(\u0026#34;%d÷%d=%f\\n\u0026#34;,e,f,g ); 同理，在使用浮点数变量时，函数printf和scanf也有对应的改变； printf中 %d 变为 %f ；scanf中 %d 变为 %lf ；\n用了%d会发生什么\r如果在 double 类型的变量中，用了%d会发生什么?\n下面是关于上述问题的探究。\n1.编写以下代码(%d-test.c)，输入1，观察输出结果；\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { int a ; scanf(\u0026#34;%d\u0026#34;, \u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } 2.改变变量类型名称，printf，scanf，重复上述操作\n3.输出结果记录如下：\n定义 scanf printf 输入1后的输出 int %d %d 1 int %d %f 0.000000 int %lf %d 0（代码报错） int %lf %f 0.000000（代码报错） double %d %d 1 double %d %f -92559592117457364459447783688012762948756726027711679117131776.000000(就离谱) double %lf %d 0 double %lf %f 1.000000 结论：只有 printf 和 scanf 与变量类型配套，才能输出正确结果，否则输出离谱结果！\n数据类型\r我们已经知道：C语言是有类型的语言； C语言中的类型包含整数类型、浮点数类型、字符类型、逻辑类型、以及指针和自定义类型； 接下来将详细讲解整数类型、浮点数类型、字符类型和逻辑类型； 指针和自定义类型放到后面再讲；\n整数类型\r整数包括5种类型；\n分别是 short char int long 和 long long ； 它们的字节数不同；\nchar 1 (8 bit)\nshort 2\nint 取决于编译器类型；一般为4个字节；\nlong 4\nlonglong 8 具体可通过sizeof函数查验。\n以int类型为例：(sizeof.c)\n1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;, sizeof(int)); return 0; } 可以看到输出结果是4；代表本编译器int类型变量为4个字节；\nbit是什么呢？ 就是二进制中的一个数，因此8个二进制数就表示一个字节；\n补码\r在计算机内部，一切都是二进制数，所有数都可以用二进制数表达；\n那么，负数如何表达?\n答：补码\n一个正数的相反数与其相加可以得到0；\n利用这个特性可以用补码来表达二进制下的负数；\n例如，对于char类型的变量，因为是一个字节，所以可以表达2^8=256个数；比如1是0000 0001；\n已知-1+1=0；那么与0000 0001相加等于0的自然就是-1；\n事实上，对于char类型的变量，我们只需得到八位是零即可，剩下一位会溢出；\n因此，相加等于1 0000 0000即可； 所以-1就是1111 1111，它就是0000 0001的补码；\n这样做，会使变量在正数范围表达的数变少；\n比如1111 1111如不当作补码看待，就是255；\n为了不重复，char类型的变量范围将从0255变为-128127；\n其中-128是1000 0000；127是0111 1111；\n以此类推，short可以表达-32768~32767的整数;\n而int、long、long long就更多了；\n一个数的正负，主要看最高位，若为1则是负数，若为0则是正数或0；\n如果想让char类型的变量范围变回0~255，可以在前面加上unsigned；\n比如，unsigned char的1111 1111 表达的就是255； 但它仍不能表达高于255的数；\n如果超出了数据范围进行运算，变量可能会越界并溢出； 如下面的例子(full.c)：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { char a = 127; a = a + 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); return 0; } 输出结果：\na = -128；\n这是因为0111 1111 + 0000 0001 = 1111 1111\n而1111 1111 根据补码就是-128；\n同理，也可以得到 -128+1=0这样的离谱结果；\n在初始化变量的值时，输入的值默认为int类型； 如果想要输入其它形式，可以加上后缀字母； 比如，加上u可以输出unsigned；加上l可以输出long和longlong；\n此时可以省略int；\n除了后缀，数字还可以加上前缀； 前缀一般表示数的进制； 比如八进制在数字前面加上0，十六进制在数字前面加上0x；\n比如,输入012,就是十进制的10;\n输入0x12，就是十进制的18；\n对于在scanf和printf中整数的输入输出，之前提到了%d； 事实上，一共有4种形式：\n%d %u %ld %llu int unsigned (int) long long (int) unsigned long long (int) 其中字节小于等于int的变量，即char、short、int都按int类型输入输出；\n字节大于int的变量，即long和long long都按long long类型输出；\n此外，还有%o和%x，它们分别表示八进制数和十六进制数，且输出的数不带有前缀；\n浮点数类型\r在数据类型中，与整数相对的就是浮点数；\n浮点数包括三种类型，分别是：float、double、long double；\n它们的内存分别是8个字节、16个字节、32个字节；\n由于long double极少用到，这里只介绍float和double；\nfloat变量的范围为 ±(1.2e-383.4e38)和0；\ndouble变量的范围为 ±(2.2e-3081.79e308)和0；\n这代表它们在极其接近0的部分仍有一小部分数无法表达（不包括0）；\n此外，浮点数可以输出 ±inf 和 nan；\ninf即infinite，即无穷大；\n与一般的算数规则不同，正数除以0可以得到+inf，负数除以0可以得到-inf；\nnan即not a number，表示非数；即不存在的数；\n0除以0可以得到nan；\n另外，由于计算机内部的数均为二进制数，对于小数位数过多的数，计算机只能以近似的数去拟合；\n这就是说，浮点数的范围区间并不是连续的，而是离散的；\n拟合的精度有限。所以把浮点数准确的小数位数称为有效位数； float的有效位数为7，double的有效位数为15； 所以double又叫“双精度浮点数”； 因此，当两个浮点数的差小于1e-7时，就可以认为它们是相等的了；\n用 == 判定两个浮点数相等反而是错误的；\n与整数类似，浮点数输入输出也有其特定形式； float输入用%f，输出也用%f； double输入用%lf，输出用%f；\n此外，还可以用%e输出，此时输出的是浮点数的科学计数法； 浮点数输入可直接使用科学计数法形式；\n浮点数的二进制表达形式一般如下：\n以double为例，它由64bit； 第一位（最高位）用来记录数的正负（补码）； 2-12位用来记录浮点数的数量级；\n后面的位用来表示浮点数的有效数字；\n由于用来表达有效数字的bit终究是有限的，所以在小数位数过多时会产生误差；\n正如整数输入的类型默认为int，浮点数输入的类型默认为double； 想要表达float可以在数字后面加上f；\n如果没有特殊需要，整数类型用int，浮点数类型用float就行了；\n字符类型\rchar除了表示整数，还可以表示字符；\n因为char是character的缩写；\n除了字母、符号，数字同时也可以是字符；\n输入输出char类型变量可以使用**%c**；\n由于计算机内部全部是二进制数，因此要想办法把字符转换为二进制数；\n因此要使用ASCII编码，每个字符与ASCII中的一个数字编码一一对应；\n再将ASCII编码转换为二进制数，就能实现字符在计算机内部的表达；\n想要初始化char类型的变量为字符，不管它是不是数字，都必须加上单引号； ‘1’，以将字符变量和一般变量做区分；\n如果数字没加单引号，char将会存储数字对应的ASCII编码的字符；\n如果非数字没加单引号，如果这不是一个变量，会报错；\n值得一提的是，‘’也是一个字符，即使单引号里面没有任何东西；\n它的ASCII码是0；\n字符也可以进行计算，但实际计算的是字符的ASCII编码； 比如， 一个字符加一个数字得到ASCII码表中加上那个数之后的字符； 两个字符运算，先将字符转换为ASCII编码，算完后再转换为字符； 如下面的例子(char.c)：\n1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u0026gt; int main() { char x = \u0026#39;a\u0026#39; + 1; char y = \u0026#39;b\u0026#39;-\u0026#39;a\u0026#39;; printf(\u0026#34;%c\\n\u0026#34;,x); printf(\u0026#34;%d\\n\u0026#34;,y); } 输出结果：\nx=‘b\u0026rsquo;；y=1\n除此之外，还有一类特殊的字符，称为“逃逸字符”；\n它们以反斜杠 \\ 开头，作用是控制 printf 输出的内容； 逃逸字符主要包括以下这些：\n\\b \\ \u0026quot; \\t \\ ' \\n \\ \\ \\r 回退一格 双引号 到下一个表格位 单引号 换行 反斜杠本身 回车 其中\\t可以起到让数据在表格位对齐的作用（即输入一个TAB键）；\n类型转换\r类型转换分为自动类型转换和强制类型转换；\n当运算符(双目)的两个变量类型不同时，会发生自动类型转换；\n自动类型转换很简单，一般是把小的往大的转换；\n比如把整数转换为浮点数，内存小的转换为内存大的；\n有时，我们需要在各个变量类型之间做转换； 这时，我们就要用到强制类型转换符； 它的格式是 （类型名）值；\n如下面的例子：\nint a;\na= (int) 3.5;\n则a的值为3；\n同时强制类型转换也是一个运算符；\n它的优先级为1，比任何运算符都高；\nbool类型\rboll类型更像是逻辑类型。它的值只能是0和1；\n0非1是；\n因此，使用bool类型可以加快代码运行速度；\nC语言中的简单运算\r数学运算\r一个表达式是一系列运算符和算子的组合，用来计算一个值；\n运算符是指进行运算的动作；\n算子是指参与运算的值，这个值可能是常数，也可能是变量，还可能是一个函数的返回值；\n运算符有很多种，比如 + - * / % 都是运算符；\n当多个运算符出现在同一个表达式中时，是如何进行运算的呢？\n类似于“先乘除，后加减”，运算符之间也有优先级，用1，2，3\u0026hellip;表示，数字小的优先级高；\n下面是一些运算符的优先级：\n优先级 运算符 运算 结合关系 举例 1 () 括号 自左向右 a(b+c) 2 + 单目不变 自右向左 a*+b 2 - 单目取负 自右向左 a*-b 2 ++ 自增 自右向左 a++ 2 \u0026ndash; 自减 自右向左 a\u0026ndash; 3 * 乘 自左向右 a*b 3 / 除 自左向右 a/b 3 % 取余 自左向右 a%b 4 + 加 自左向右 a+b 4 - 减 自左向右 a-b 14 = 赋值 自右向左 a=b 14 += 加法赋值 自右向左 a+=b 14 -= 减法赋值 自右向左 a-=b 14 *= 乘法赋值 自右向左 a*=b 14 /= 除法赋值 自右向左 a/=b 14 %= 取余赋值 自右向左 a%=b 运算符可以以算子数目分类；\n单目运算符指只有一个算子的运算符，此外还有双目和三目运算符；\n一般来说，单目运算符的优先级更高；\n单目不变和单目取负是指对它右边的数不变或取负； 如 a*-b ，即a乘以b的相反数； 因此它们的优先级最高；\n结合关系是当优先级相等时运算的顺序；例：\na/b*c即为a/b后，再乘以c；\n\u0026ndash;a即-(-a)，因为单目取负结合关系为自右向左；\na=b=c 即先把c的值赋给b，再把b的值赋给a，因为赋值运算符结合关系为自右向左；\n优先级一致的运算符结合关系也相同；\n此外，还有复合赋值和自增自减运算符；\n赋值运算符包含 *+= -= = /= ，它们的作用是快速将变量变成新的值；\n如 a+=1 ，等价于 a = a + 1 ；\n另外，要注意的是，*=和/=在使用时，由于运算优先级，会先将右边的结果算完再赋值；\n如 a *= 6+12 等价于 a *=(6+12) 等价于 a = a * (6+12);\n自增自减运算符可快速将变量的值变化1；\n如 a++ 等价于 a+=1 等价于 a = a + 1 ：\n此外，又有 a++ 和 ++a 两种表达方式；\na++的值是a加1以前的值，而++a的值是加了1以后的值；\n无论哪个，a自己的值都加了1了； 具体，可以看下面的例子：(Self-incrementing.c)\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; printf(\u0026#34;a=%d\\n\u0026#34;, a); printf(\u0026#34;a++=%d\\n\u0026#34;, a++); a = 1; printf(\u0026#34;++a=%d\\n\u0026#34;,++a); return 0; } 输出结果：\na=1\na++=1\n++a=2\n这就是因为++a先把值赋给了a再参与运算； 而a++先参与运算再赋值； 故 a++ =1；但此时a的值已经是2了；\n另外，表达式在使用时应该尽量简便； 应避免使用复杂的表达式，而是拆成多个简单的，便于我们理解。\n像 ++a++ 这样的就是典型的错误案例；\n关系运算\rif函数离不开的就是关系运算符；以下是常见的关系运算符：\n优先级 运算符 运算 结合关系 示例 6 \u0026gt; 大于 从左向右 a\u0026gt;b 6 \u0026gt;= 大于或等于 从左向右 a\u0026gt;=b 6 \u0026lt; 小于 从左向右 a\u0026lt;b 6 \u0026lt;= 小于或等于 从左向右 a\u0026lt;=b 7 == 等于 从左向右 a==b 7 != 不等于 从左向右 a!=b 当关系运算符所在的关系式为真时，输出1，反之输出0； 实际上，if函数等正是通过检验括号内是否为0来决定要不要进行下面的内容的；\n注意：仍然遵循从左至右的结合关系；\n例如 5\u0026gt;4\u0026gt;3 -\u0026gt; 1\u0026gt;3 -\u0026gt; 0\n但 5\u0026gt;3==4\u0026gt;2 却是另一种算法，因为等于和不等于的优先级略低； 因此 5\u0026gt;3==4\u0026gt;2 等价于 1==1 ；\n逻辑运算\r逻辑运算符如下：\n优先级 运算符 运算 结合关系 举例 2 ! 逻辑非 从右向左 !a 11 \u0026amp;\u0026amp; 逻辑与 从左向右 a\u0026amp;\u0026amp;b 12 || 逻辑或 从左向右 a||b 逻辑运算符主要检测其附近的表达式的值是否为0；\n对于逻辑与，只有两边的表达式结果均不为0时，才输出1；若有一个是0，则输出0；\n对于逻辑或，只要两边的表达式有一个结果不是0，就输出1；只有两个均是0时才输出0；\n对于逻辑非，它右边的表达式结果为0则输出1；不为0则输出0；\n例如\n2\u0026amp;\u0026amp;0=0；3||0=1；!4=0；\n注意：计算机在进行\u0026amp;\u0026amp;和||的运算时，若左边边的值足以判定结果为1还是0时，就不会看右边了！\n这种情况被称为短路。\n对于\u0026amp;\u0026amp;，左边是0时就不做右边了； 对于||，左边是非0时就不做右边了；\n具体可以看下面的例子：(logic.c)\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; int main() { int a = 1; int b = 0; int c; c = (a==0) \u0026amp;\u0026amp; (b+=1); printf(\u0026#34;%d\\n\u0026#34;, b); return 0; } 可以看到b的值仍然为0，b+=1并没有执行；\n为了避免短路，应该避免在逻辑运算中插入赋值运算；\n条件运算符\r它是唯一的三目运算符，其实也非常简单； 格式如下：\na ? b : c ;\n可翻译为判断a是否成立，若是，进行b；若否，进行c；\n作为运算符，它的运算优先级为13，仅仅高于一系列赋值运算符；\n逗号运算符\r逗号用来连接两个表达式，并以其右边的表达式的值作为它的结果。\n逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算；\n逗号的组合关系是自左向右，所以左边的表达式会先计算，而右边的表达式的值就留下来作为逗号运算的结果。\n说实话这个运算符没什么用\n","date":"2025-02-20T00:00:00Z","permalink":"http://localhost:1313/post/c_cpp_learning/03.data-calc/","title":"C/C++基础-03.数据类型和运算"},{"content":"条件与循环\r在这一章里面，你将化身数个玩家来攻击solxr。\n为了更好的折磨solxr，你需要设计一些程序，来模拟solxr的痛苦；\n可是，在你设计程序的时候，却在面对选择和循环时无从下手；\n幸运的是，你找到了下面这个教程，来帮助你快速掌握选择与循环的相应知识；\nif/else : 条件判断\r编程不能仅限于输入输出，有时还要判断。\nif函数就是用来做判断的；\n一个基本的if语句由一个关键字if开头，跟上在圆括号()里的一个表达条件的逻辑表达式；\n然后是一对大括号{}之间的若干条语句；\n具体怎样发挥作用，看下面的例子：(if.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; const int ATK3 = 10; const int DEATH = 0; int originalhp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); int hp = originalhp - atk1 - atk2 - ATK3; if (hp\u0026gt; DEATH) { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n\u0026#34;, originalhp, atk1, atk2, ATK3, hp); printf(\u0026#34;Fantastic! I\u0026#39;m still ALIVE!\\n\u0026#34;); } else { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=...\\n\u0026#34;, originalhp, atk1, atk2, ATK3); printf(\u0026#34;No!!My hp come to the bottom!\\nOops!I DEAD!\\n\u0026#34;); } if (hp \u0026lt;= 0) { printf(\u0026#34;Congratulation to your success!Goodbye!!\\n\u0026#34;); } return 0; } 输入样例1：\n10\n20\n输出结果1：\nOK,Now I only have 100-10-20-10=60 hp.\nFantastic! I\u0026rsquo;m still ALIVE!\n输入样例2：\n50\n90\n输出结果：\nOK,Now I only have 100-50-90-10=\u0026hellip;\nNo!!My hp come to the bottom!\nOops! I DIED!\nCongratulation to your success! Goodbye!!\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 if (hp\u0026gt; DEATH) { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=%d hp.\\n\u0026#34;, originalhp, atk1, atk2, ATK3, hp); printf(\u0026#34;Fantastic! I\u0026#39;m still ALIVE!\\n\u0026#34;); } else { printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=...\\n\u0026#34;, originalhp, atk1, atk2, ATK3); printf(\u0026#34;No!!My hp come to the bottom!\\nOops!I DEAD!\\n\u0026#34;); } if (hp \u0026lt;= 0) { printf(\u0026#34;Congratulation to your success!Goodbye!!\\n\u0026#34;); } if函数如果条件为真，则执行大括号里的语句，否则跳过，继续执行下面的语句；\n但如果if函数后面出现了else，则若不满足条件，就会执行else大括号里的语句，保证不会出现遗漏条件的情况；\n如上面的if函数，若hp \u0026lt;= 0，会输出死亡对话；否则输出存活对话； 而下面的if函数，如hp \u0026gt; 0，则无事发生；\nswitch/case : 条件选择\rif和else之间可以嵌套使用，形成形如下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 if() {...} else if() {...} else if() {...} . . . else {...} 当需要进行多次判断时，常用嵌套的if-else函数来解决；\n但这样做有个坏处，就是会由于多个if的存在使得代码显得非常杂乱，还容易出错；\n这时，就可以使用switch函数来解决问题； 如下面的例子：使用switch函数来判定solxr的血量范围，进而输出对应的对话；(switch.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; const int ATK3 = 10; int originalhp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\u0026#34;); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); int hp = originalhp - atk1 - atk2 - ATK3; int level = hp / 10; printf(\u0026#34;OK,Now I only have %d-%d-%d-%d=\u0026#34;, originalhp, atk1, atk2, ATK3); switch (level) { case 9:printf(\u0026#34;%d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); break; case 8:case 7:case 6:printf(\u0026#34;%d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); break; case 5:case 4:case 3:case 2:printf(\u0026#34;%d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); break; case 1:case 0:printf(\u0026#34;%d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); break; default: printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); break; } return 0; } 输入样例1：\n0\n0\n输出结果1：\nOK,Now I only have 100-0-0-10=90 hp;\nI guess you didn\u0026rsquo;t want to hurt me.\nthank you very much!\n输入样例2：\n5\n10\n输出结果2：\nOK,Now I only have 100-5-10-10=75 hp;\nMy hp is still high now!\nThanks for your mercy!\n输入样例3：\n30\n30\n输出结果3：\nOK,Now I only have 100-30-30-10=30 hp.\nIt\u0026rsquo;s really hurt\u0026hellip; But I\u0026rsquo;m still alive!\n输入样例4：\n50\n45\n输出结果4：\nOK,Now I only have 100-50-45-10=-5 hp;\nGood! I think I\u0026rsquo;m so lucky that I made it with such few hp!\n输入样例5：\n100\n200\n输出结果5：\nOK,Now I only have 100-100-200-10=\u0026hellip;No!! My hp come to the bottom!\nOops!I DIED!\nCongratulation to your success! Goodbye!!\n这里要根据“我”的剩余血量来触发对话内容，有多个判定节点；\n因此如果要用if函数，就必须要嵌套；\n下面是一种可能的例子：\n1 2 3 4 5 6 7 8 9 10 if(hp\u0026gt;=90) {...} else if(hp\u0026gt;=60) {...} else if(hp\u0026gt;=20) {...} else if(hp\u0026gt;0) {...} else {...} 这样写，编译器必须从上读到下，而且我们也难以第一时间读懂代码想表达什么；\n因此，这时，就可以使用switch函数来解决问题，这时编译器只需读取一种情况就可以了；\n1 2 3 4 5 6 7 8 9 10 11 switch (level) { case 9:printf(\u0026#34;%d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); break; case 8:case 7:case 6:printf(\u0026#34;%d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); break; case 5:case 4:case 3:case 2:printf(\u0026#34;%d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); break; case 1:case 0:printf(\u0026#34;%d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); break; default: printf(\u0026#34;No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); break; } switch函数由switch 和 case default 组成；\n与if一致，switch函数也需要圆括号() ，它会检测圆括号里面的变量数值来执行case里面的内容；\n注：case里面的数必须是正整数，这是switch相对于if的局限性；\n对于此代码，我们可以将100种hp换算为10种level，用hp/10就可以了！\n不然，要我写100个case，还不如用if函数！\ncase后面也要加大括号{}；\n想要表示一种情况，case和数之间要加空格，之后要有冒号:\n在冒号后面加上想要添加的代码，满足case后就可以执行以下的代码内容；\n在每种case最后，要加上 break;\n否则就会直接执行下一个case里面的内容；\n不过，也可以利用这个特性，合并多种case，使它们执行相同的内容；\n如上面就将case01；case2345；case678合并了；\n在switch函数的最后，还有一个东西，就是default； 当条件都不满足case时，执行default里面的内容；\n如果你保证switch函数的所有条件都在你的case里面，可以不写default；\n不然，忘记写了你就等着报错吧！\n小技巧：如果想要使用switch函数，但又没有正整数，可以尝试将其化为正整数；\n如利用关系运算符输出的结果只有0和1，把区间化为整数；\nwhile/do-while ：循环操作\r无论是if还是switch函数，编译器都只会读取1次；\n当需要多次执行判断时，使用if或switch都会显得非常麻烦；\n特别是当不知道判断的次数时，if和switch都会无能为力；\n这时，就需要while：循环函数来帮忙；\n如下面的例子，当我们需要攻击多轮且记录solxr被战胜前攻击的回合数时，就需要用到while函数：(while.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; const int ATK3 = 10; int originalhp = 0; int hp = 0; int n = 0; printf(\u0026#34;There have 3 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\\ninput my hp:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); hp = originalhp; do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); printf(\u0026#34;I have 100 hp now.\\n\u0026#34;,hp); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); while (atk1\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk1); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1); } printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); while (atk2\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk2); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2); } hp = hp - atk1 - atk2 - ATK3; printf(\u0026#34;OK;Now I only have\u0026#34;); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34; %d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34; %d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34; %d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); }while (hp \u0026gt; 0); printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); return 0; }\twhile循环包含两个重要组成部分，一是循环条件，二是循环内容；\n循环条件指判断是否开始或继续循环的内容，需要在while后面用圆括号()括起来，与if类似；\n循环内容也与if类似，用大括号{}括起来；\n循环成功搭建后，只要满足循环条件，就会不断的执行循环内容，直到条件不满足为止； 因此，一定要有条件让系统有机会脱离循环，否则就会陷入死循环！\nwhile循环分为两种，一种循环条件写在前；另一种写在后面；\n第一种：\n1 2 while (...) {...} 第二种：\n1 2 3 do {...} while (...); 在必须先判定时，应该用第一种；在必须要执行一次循环时，应该用第二种； 需要注意的是，第二种最后依然需要分号，因为结尾不是大括号，不能成为语句；\n先看第一个循环：\n1 2 3 4 5 6 7 while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); 如果你没有输入正确的血量，程序就无法继续正常进行；\n因此设置了这个循环来提醒输错的玩家，并引导他们纠正；\n在这个循环中，先判断玩家有没有输对，如果不对，则报错提示玩家正确输入；\n如再次输错，则循环此命令，直到玩家输对为止，再执行下面的程序； 后面关于atk1和atk2的处理也是如此；\n这里一定要先判断，所以使用第一种循环；\n接下来是第二个循环：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); printf(\u0026#34;I have %d hp now.\\n\u0026#34;,hp); printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); while (atk1\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack is too ABNORMAL!\\n\u0026#34;,atk1); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1); } printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); while (atk2\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack is too ABNORMAL!\\n\u0026#34;,atk2); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2); } hp = hp - atk1 - atk2 - ATK3; printf(\u0026#34;\\nNow I only have\u0026#34;); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34;%d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34;%d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34;%d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); }while (hp \u0026gt; 0); 1.先输入玩家1和2的攻击，必须为正，否则报错；\n2.根据玩家123的攻击计算玩家的剩余血量；\n3.输出“我”的剩余血量，并根据“我”的剩余血量来触发对话内容；\n（这里没有用switch而选择if else级联的原因是switch函数不好对hp=0的情况进行判定）\n4.回合数+1；\n5.若hp\u0026gt;0，提示玩家继续攻击，并重复1-4步骤；直到hp\u0026lt;=0为止；\n6.结束循环；\n这里一定要进行第一回合，所以使用第二种循环；\n1 2 3 printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); 结算阶段，不完成上面的循环无法执行最后的结算代码；\n用printf输出回合数；\n这里展示一种测试时终端输出的样例：\nThere have 3 players that will attack me.\nWe have known player3\u0026rsquo;s attack is 10.\ninput my hp:-1\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of -1!!\nPlease input it again:5\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of 5!!\nPlease input it again:100\nOK;\nRound 1 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!!\nPlease input it again:0\ninput player2\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!! Please input it again:0 OK;Now I only have 90 hp;\nI guess you didn\u0026rsquo;t want to hurt me.\nthank you very much!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 2 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:5\ninput player2\u0026rsquo;s attack:5\nOK;Now I only have 70 hp;\nMy hp is still high now!\nThanks for your mercy!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 3 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:10\nOK;Now I only have 40 hp.\nIt\u0026rsquo;s really hurt\u0026hellip; But I\u0026rsquo;m still alive!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 4 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:15\nOK;Now I only have 5 hp;\nGood! I think I\u0026rsquo;m so lucky that I made it with such few hp!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 5 begin!\nI have 100 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:10\nOK;Now I only have\u0026hellip;No!!My hp come to the bottom! Oops!I DIED!\nYou only take 5 round(s) to defeat me!!\nCongratulation to your success! Goodbye!!\nfor : 循环计数器\r在C语言中，除了while循环和do-while循环，还存在第三种循环，即for循环；\n作为最早的循环，for循环结构简单，也更难被理解；\n以下就是一个使用for循环的例子(for.c)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;stdio.h\u0026gt; int main() { int atk; const int ATK10 = 10; int sumatk=0; int originalhp = 0; int hp = 0; int n = 0; int player = 0; printf(\u0026#34;There have 10 players that will attack me.\\nWe have known player3\u0026#39;s attack is 10.\\n\\ninput my hp:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); while (originalhp \u0026lt;= 10) { printf(\u0026#34;You\u0026#39;re kidding me absolutely! I can\u0026#39;t live with the hp of %d!!\\nPlease input it again:\u0026#34;, originalhp); scanf(\u0026#34;%d\u0026#34;, \u0026amp;originalhp); } printf(\u0026#34;OK;\\n\u0026#34;); hp = originalhp; do { printf(\u0026#34;Round %d begin!\\n\u0026#34;, n + 1); printf(\u0026#34;I have %d hp now.\\n\u0026#34;,hp); sumatk = 0; for (player = 1; player \u0026lt;= 9; player++) { printf(\u0026#34;input player%d\u0026#39;s attack:\u0026#34;,player); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk ); for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } sumatk += atk; } sumatk += ATK10; hp -= sumatk; printf(\u0026#34;OK;You hurt me with the sum of %d attack in this round;\\nNow I only have\u0026#34;,sumatk); int level = hp * 10 / originalhp; if (hp \u0026gt;= originalhp - 10) printf(\u0026#34; %d hp;\\nI guess you didn\u0026#39;t want to hurt me.\\nthank you very much!\\n\u0026#34;, hp); else if (level \u0026gt;= 6) printf(\u0026#34; %d hp;\\nMy hp is still high now!\\nThanks for your mercy!\\n\u0026#34;, hp); else if (level \u0026gt;= 1) printf(\u0026#34; %d hp.\\nIt\u0026#39;s really hurt... But I\u0026#39;m still alive!\\n\u0026#34;, hp); else if (hp \u0026gt; 0) printf(\u0026#34; %d hp;\\nGood! I think I\u0026#39;m so lucky that I made it with such few hp!\\n\u0026#34;, hp); n++; if(hp \u0026gt; 0) printf(\u0026#34;Although I don\u0026#39;t want to die now,but I must help you succeed!\\nKeep attacking!\\n\\n\u0026#34;); } while (hp \u0026gt; 0); printf(\u0026#34;...No!!My hp come to the bottom!\\nOops!I DIED!\\n\u0026#34;); printf(\u0026#34;You only take %d round(s) to defeat me!!\\n\u0026#34;, n);\tprintf(\u0026#34;Congratulation to your success! Goodbye!!\\n\u0026#34;); return 0; } 如果把玩家人数提升到10位，使用for循环就会显得比while循环更加方便与简洁；\n1 2 3 4 5 6 7 8 9 10 11 12 for (player = 1; player \u0026lt;= 9; player++) { printf(\u0026#34;input player%d\u0026#39;s attack:\u0026#34;,player); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk ); while (atk\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } sumatk += atk; } for循环在形式上与其它判断语句类似，也是由小括号()和大括号{}组成；\n但不同的是，for循环的小括号里面有3条语句，中间用两个分号隔开；\n即:\n1 2 for(a;b;c) {d} 三条语句分别代表初始动作，循环继续的条件和每次循环结束做的动作；\n大括号里和其它循环相同，都用来做每次循环中做的动作；\n例如第一个for，它的流程如下： 1.初始化player的值为1；\n2.判定player的值是否大于10，若大于，则继续进行下面的步骤，反之直接结束循环；\n3.执行大括号内的代码；\n4.让player的值加1，以便输入下一名玩家的攻击；\n5.重复2-4步骤；\n为了理解方便，可将for翻译为“对于”； 这样，for循环的流程可以理解为：\n对于 一开始的player=1，如果player\u0026lt;10，就重复执行大括号里的内容，并让player的值加1，直到player\u0026gt;=10为止；\n（注意：循环结束时，player==11）\n用字母来表示就是：\n对于\nfor(a;b;c)\n{d}\n执行顺序为a b d c b d c b d c\u0026hellip;（直到b不满足为止）；\n此外，for循环小括号里的三条语句都可以省略，但是两个分号不可以省略； 如第二个for：\n1 2 3 4 5 6 for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } 就省略了第一条和第三条语句；\n同为循环，for和while稍加改动就可以等价互换；\n如第二个for：\n1 2 3 4 5 6 for(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } 就和之前的\n1 2 3 4 5 6 while(;atk\u0026lt;0;) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk); } 完全等价；\n值得一提的是，for语句在省略第一条和第三条语句的情况下，单词“for”完全可以被平替为单词“while”；\n在有三种循环时，用哪种循环最好呢？\n一般遵循以下原则：\n如果有固定次数，用for\n如果必须执行一次，用do_while\n如果必须先进行判断，用while\n这里展示一种测试时终端输出的样例：\nThere have 10 players that will attack me.\nWe have known player3\u0026rsquo;s attack is 10.\ninput my hp:-1\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of -1!!\nPlease input it again:5\nYou\u0026rsquo;re kidding me absolutely! I can\u0026rsquo;t live with the hp of 5!!\nPlease input it again:1000\nOK;\nRound 1 begin!\nI have 1000 hp now.\ninput player1\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!!\nPlease input it again:0\ninput player2\u0026rsquo;s attack:-1\nI know you don\u0026rsquo;t want to hurt me,but now the attack -1 is too ABNORMAL!\nIf you input this atk,it means you want to heal me!I refuse it!!\nPlease input it again:0\ninput player3\u0026rsquo;s attack:0\ninput player4\u0026rsquo;s attack:0\ninput player5\u0026rsquo;s attack:0\ninput player6\u0026rsquo;s attack:0\ninput player7\u0026rsquo;s attack:0\ninput player8\u0026rsquo;s attack:0\ninput player9\u0026rsquo;s attack:0\nOK;You hurt me with the sum of 10 attack in this round;\nNow I only have 990 hp;\nI guess you didn\u0026rsquo;t want to hurt me.\nthank you very much!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 2 begin!\nI have 990 hp now.\ninput player1\u0026rsquo;s attack:10\ninput player2\u0026rsquo;s attack:10\ninput player3\u0026rsquo;s attack:10\ninput player4\u0026rsquo;s attack:10\ninput player5\u0026rsquo;s attack:10\ninput player6\u0026rsquo;s attack:10\ninput player7\u0026rsquo;s attack:10\ninput player8\u0026rsquo;s attack:10\ninput player9\u0026rsquo;s attack:10\nOK;You hurt me with the sum of 100 attack in this round;\nNow I only have 890 hp;\nMy hp is still high now!\nThanks for your mercy!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 3 begin!\nI have 890 hp now.\ninput player1\u0026rsquo;s attack:4\ninput player2\u0026rsquo;s attack:40\ninput player3\u0026rsquo;s attack:40\ninput player4\u0026rsquo;s attack:50\ninput player5\u0026rsquo;s attack:4\ninput player6\u0026rsquo;s attack:40\ninput player7\u0026rsquo;s attack:50\ninput player8\u0026rsquo;s attack:50\ninput player9\u0026rsquo;s attack:40\nOK;You hurt me with the sum of 328 attack in this round;\nNow I only have 562 hp.\nIt\u0026rsquo;s really hurt\u0026hellip; But I\u0026rsquo;m still alive!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 4 begin!\nI have 562 hp now.\ninput player1\u0026rsquo;s attack:60\ninput player2\u0026rsquo;s attack:60\ninput player3\u0026rsquo;s attack:60\ninput player4\u0026rsquo;s attack:60\ninput player5\u0026rsquo;s attack:60\ninput player6\u0026rsquo;s attack:60\ninput player7\u0026rsquo;s attack:60\ninput player8\u0026rsquo;s attack:60\ninput player9\u0026rsquo;s attack:20\nOK;You hurt me with the sum of 510 attack in this round;\nNow I only have 52 hp;\nGood! I think I\u0026rsquo;m so lucky that I made it with such few hp!\nAlthough I don\u0026rsquo;t want to die now,but I must help you succeed!\nKeep attacking!\nRound 5 begin!\nI have 52 hp now.\ninput player1\u0026rsquo;s attack:52\ninput player2\u0026rsquo;s attack:20\ninput player3\u0026rsquo;s attack:20\ninput player4\u0026rsquo;s attack:20\ninput player5\u0026rsquo;s attack:20\ninput player6\u0026rsquo;s attack:20\ninput player7\u0026rsquo;s attack:20\ninput player8\u0026rsquo;s attack:20\ninput player9\u0026rsquo;s attack:20\nOK;You hurt me with the sum of 222 attack in this round;\nNow I only have\u0026hellip;No!!My hp come to the bottom!\nOops!I DIED!\nYou only take 5 round(s) to defeat me!!\nCongratulation to your success! Goodbye!!\nbreak/continue : 循环控制\r循环在解决实际问题方面有很广泛的应用；\n然而，要想发挥其最大作用，必须引入控制循环的元素，即break和continue；\n此外，函数goto也可以控制循环， 但由于其权限太大，可以跳到代码任意位置，破坏了代码的逻辑，故在此不做介绍；\n简单来说，函数break可以跳出其所在循环；\n而函数continue可以无视其所在循环体中接下来的所有内容，直接进入下一轮循环；\n（对于for循环，仍会执行圆括号中的第三条语句）\n具体可以看下面的例子:(break.c)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 #include \u0026lt;stdio.h\u0026gt; int main() { int atk1 = 0; int atk2 = 0; int atk3 = 0; int a, b, c; int solution = 0; const int hp = 100; printf(\u0026#34;I have 100 hp now.\\nThere have still 3 players that will attack me.\\n\u0026#34;); printf(\u0026#34;What\u0026#39;s different is everyone can attck for 1 ~ 10 times;\\n\u0026#34;); printf(\u0026#34;But you can\u0026#39;t succeed unless my hp come to exactly 0;\\n\u0026#34;); printf(\u0026#34;Can you make it?\\n\u0026#34;); do { printf(\u0026#34;input player1\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1 ); while (atk1\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk1); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk1); } printf(\u0026#34;input player2\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2 ); while (atk2\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk2); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk2); } printf(\u0026#34;input player3\u0026#39;s attack:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk3 ); while (atk3\u0026lt;0) { printf(\u0026#34;I know you don\u0026#39;t want to hurt me,but now the attack %d is too ABNORMAL!\\n\u0026#34;,atk3); printf(\u0026#34;If you input this atk,it means you want to heal me!I refuse it!!\\nPlease input it again:\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;atk3); } for (a = 1; a \u0026lt;= 10; a++) { for (b = 1; b \u0026lt;= 10; b++) { for (c = 1; c \u0026lt;= 10; c++) { if (a * atk1 + b * atk2 + c * atk3 == hp) { solution = 1; break; } } if (solution == 1)break; } if (solution == 1)break; } if(solution == 0) printf(\u0026#34;Pity! The players tried for so long... But still can\u0026#39;t succeed!\\nTry it again!\\n\u0026#34;); } while (solution == 0); printf(\u0026#34;Congratulations!\\nPlayer1 attack for %d times, Player2 attack for %d times, Player3 attack for %d times can change my hp to exactly 0!\\nYOU WIN!!!\\n\u0026#34;, a, b, c); return 0; } 这里我们要根据三个玩家的攻击来判定是否能刚好战胜“我”；\n而每个人最多能攻击10次；\n因此我们采用穷举法，判定是否有解法符合条件；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for (a = 1; a \u0026lt;= 10; a++) { for (b = 1; b \u0026lt;= 10; b++) { for (c = 1; c \u0026lt;= 10; c++) { if (a * atk1 + b * atk2 + c * atk3 == hp) { solution = 1; break; } } if (solution == 1)break; } if (solution == 1)break; } 以上便是具体操作；\n使用嵌套for循环，用排列组合的方式一个个判定结果是否符合；\n一旦遇到符合的情况，就让solution=1，说明可以过关；\n之后，便用break结束循环；\n但要注意的是，函数break只能跳出其所在循环，而上面共有3个循环；\n因此，在剩下两个循环下面设置了两个 if (solution == 1)break 语句；\n表明如果找到解法就一次性结束3个循环；\n这样，3个break接力完成了对循环的控制；\n附：输入样例和输出结果：\n输入样例1：\n3\n5\n7\n输出结果1：\nCongratulations!\nPlayer1 attack for 2 times, Player2 attack for 9 times, Player3 attack for 7 times can change my hp to exactly 0!\nYOU WIN!!!\n输入样例2：\n3\n6\n9\n输出结果2：\nPity! The players tried for so long\u0026hellip; But still can\u0026rsquo;t succeed!\nTry it again!\n","date":"2025-02-20T00:00:00Z","permalink":"http://localhost:1313/post/c_cpp_learning/04.choice-circle/","title":"C/C++基础-04.条件与循环"},{"content":"正文测试\r而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用\r思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片\r1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"http://localhost:1313/post/example/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"http://localhost:1313/post/example/test-chinese/","title":"中文测试"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings\rThe following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1\rH2\rH3\rH4\rH5\rH6\rParagraph\rXerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes\rThe blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution\rTiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution\rDon\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables\rTables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables\rItalics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks\rCode block with backticks\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces\r\u0026lt;!doctype html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\rCode block with Hugo\u0026rsquo;s internal highlight shortcode\r1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block\r1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types\rOrdered List\rFirst item Second item Third item Unordered List\rList item Another item And another item Nested list\rFruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark\rGIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image\rThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/post/example/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"http://localhost:1313/post/example/markdown-syntax/","title":"Markdown语法"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nbilibilibi Shortcode\rQuote Shortcode\rStack adds a quote shortcode. For example:\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― A famous person, The book they wrote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Anonymous book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Some book Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n― Somebody","date":"2019-03-10T00:00:00Z","permalink":"http://localhost:1313/post/example/rich-content/","title":"富媒体"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt\rThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat\rVicta caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/post/example/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"http://localhost:1313/post/example/placeholder-text/","title":"文章分段"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples\rInline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$\r\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/post/example/math-typesetting/","title":"使用数学公式"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/post/example/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/post/example/emoji-support/","title":"使用emoji"}]